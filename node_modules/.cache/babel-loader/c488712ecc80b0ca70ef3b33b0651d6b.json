{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/aashan/2048/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\n\nvar utils_1 = require(\"./utils\");\n\nvar skeletons_1 = require(\"./skeletons\");\n\nvar config_1 = require(\"../config\");\n\nvar errors_1 = require(\"../errors\");\n\nvar signers_1 = require(\"./signers\");\n\nvar dummyConsensusHash = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';\nvar dummyZonefileHash = 'ffffffffffffffffffffffffffffffffffffffff';\n/**\n* @ignore\n*/\n\nfunction addOwnerInput(utxos, ownerAddress, txB) {\n  var addChangeOut = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n  // add an owner UTXO and a change out.\n  if (utxos.length <= 0) {\n    throw new Error('Owner has no UTXOs for UPDATE.');\n  }\n\n  utxos.sort(function (a, b) {\n    return a.value - b.value;\n  });\n  var ownerUTXO = utxos[0];\n  var ownerInput = txB.addInput(ownerUTXO.tx_hash, ownerUTXO.tx_output_n);\n\n  if (addChangeOut) {\n    txB.addOutput(ownerAddress, ownerUTXO.value);\n  }\n\n  return {\n    index: ownerInput,\n    value: ownerUTXO.value\n  };\n}\n/**\n* @ignore\n*/\n\n\nfunction fundTransaction(txB, paymentAddress, utxos, feeRate, inAmounts) {\n  var changeIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n\n  // change index for the payer.\n  if (changeIndex === null) {\n    changeIndex = txB.addOutput(paymentAddress, utils_1.DUST_MINIMUM);\n  } // fund the transaction fee.\n\n\n  var txFee = utils_1.estimateTXBytes(txB, 0, 0) * feeRate;\n  var outAmounts = utils_1.sumOutputValues(txB);\n  var change = utils_1.addUTXOsToFund(txB, utxos, txFee + outAmounts - inAmounts, feeRate);\n  var txInner = utils_1.getTransactionInsideBuilder(txB);\n  var txOut = txInner.outs[changeIndex];\n  txOut.value += change;\n  return txB;\n}\n/**\n* @ignore\n*/\n\n\nfunction returnTransactionHex(txB) {\n  var buildIncomplete = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (buildIncomplete) {\n    return txB.buildIncomplete().toHex();\n  } else {\n    return txB.build().toHex();\n  }\n}\n/**\n* @ignore\n*/\n\n\nfunction getTransactionSigner(input) {\n  if (typeof input === 'string') {\n    return signers_1.PubkeyHashSigner.fromHexString(input);\n  } else {\n    return input;\n  }\n}\n/**\n * Estimates cost of a preorder transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to preorder\n * @param {String} destinationAddress - the address to receive the name (this\n *    must be passed as the 'registrationAddress' in the register transaction)\n * @param {String} paymentAddress - the address funding the preorder\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the preorder. This includes a 5500 satoshi dust output for the preorder.\n *    Even though this is a change output, the payer must supply enough funds\n *    to generate this output, so we include it in the cost.\n * @private\n */\n\n\nfunction estimatePreorder(fullyQualifiedName, destinationAddress, paymentAddress) {\n  var paymentUtxos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var network = config_1.config.network;\n  var preorderPromise = network.getNamePrice(fullyQualifiedName).then(function (namePrice) {\n    return skeletons_1.makePreorderSkeleton(fullyQualifiedName, dummyConsensusHash, paymentAddress, network.getDefaultBurnAddress(), namePrice, destinationAddress);\n  });\n  return Promise.all([network.getFeeRate(), preorderPromise]).then(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        feeRate = _ref2[0],\n        preorderTX = _ref2[1];\n\n    var outputsValue = utils_1.sumOutputValues(preorderTX);\n    var txFee = feeRate * utils_1.estimateTXBytes(preorderTX, paymentUtxos, 0);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates cost of a register transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to register\n * @param {String} registerAddress - the address to receive the name\n * @param {String} paymentAddress - the address funding the register\n * @param {Boolean} includingZonefile - whether or not we will broadcast\n *    a zonefile hash as part  of the register\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the register.\n * @private\n */\n\n\nfunction estimateRegister(fullyQualifiedName, registerAddress, paymentAddress) {\n  var includingZonefile = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var paymentUtxos = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  var network = config_1.config.network;\n  var valueHash;\n\n  if (includingZonefile) {\n    valueHash = dummyZonefileHash;\n  }\n\n  var registerTX = skeletons_1.makeRegisterSkeleton(fullyQualifiedName, registerAddress, valueHash);\n  return network.getFeeRate().then(function (feeRate) {\n    var outputsValue = utils_1.sumOutputValues(registerTX); // 1 additional output for payer change\n\n    var txFee = feeRate * utils_1.estimateTXBytes(registerTX, paymentUtxos, 1);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates cost of an update transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to update\n * @param {String} ownerAddress - the owner of the name\n * @param {String} paymentAddress - the address funding the update\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the update.\n * @private\n */\n\n\nfunction estimateUpdate(fullyQualifiedName, ownerAddress, paymentAddress) {\n  var paymentUtxos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var network = config_1.config.network;\n  var updateTX = skeletons_1.makeUpdateSkeleton(fullyQualifiedName, dummyConsensusHash, dummyZonefileHash);\n  return network.getFeeRate().then(function (feeRate) {\n    var outputsValue = utils_1.sumOutputValues(updateTX); // 1 additional input for the owner\n    // 2 additional outputs for owner / payer change\n\n    var txFee = feeRate * utils_1.estimateTXBytes(updateTX, 1 + paymentUtxos, 2);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates cost of an transfer transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to transfer\n * @param {String} destinationAddress - the next owner of the name\n * @param {String} ownerAddress - the current owner of the name\n * @param {String} paymentAddress - the address funding the transfer\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the transfer.\n * @private\n */\n\n\nfunction estimateTransfer(fullyQualifiedName, destinationAddress, ownerAddress, paymentAddress) {\n  var paymentUtxos = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  var network = config_1.config.network;\n  var transferTX = skeletons_1.makeTransferSkeleton(fullyQualifiedName, dummyConsensusHash, destinationAddress);\n  return network.getFeeRate().then(function (feeRate) {\n    var outputsValue = utils_1.sumOutputValues(transferTX); // 1 additional input for the owner\n    // 2 additional outputs for owner / payer change\n\n    var txFee = feeRate * utils_1.estimateTXBytes(transferTX, 1 + paymentUtxos, 2);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates cost of an transfer transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to renew\n * @param {String} destinationAddress - the next owner of the name\n * @param {String} ownerAddress - the current owner of the name\n * @param {String} paymentAddress - the address funding the transfer\n * @param {Boolean} includingZonefile - whether or not we will broadcast a zonefile hash\n      in the renewal operation\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the transfer.\n * @private\n */\n\n\nfunction estimateRenewal(fullyQualifiedName, destinationAddress, ownerAddress, paymentAddress) {\n  var includingZonefile = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var paymentUtxos = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n  var network = config_1.config.network;\n  var valueHash;\n\n  if (includingZonefile) {\n    valueHash = dummyZonefileHash;\n  }\n\n  var renewalPromise = network.getNamePrice(fullyQualifiedName).then(function (namePrice) {\n    return skeletons_1.makeRenewalSkeleton(fullyQualifiedName, destinationAddress, ownerAddress, network.getDefaultBurnAddress(), namePrice, valueHash);\n  });\n  return Promise.all([network.getFeeRate(), renewalPromise]).then(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        feeRate = _ref4[0],\n        renewalTX = _ref4[1];\n\n    var outputsValue = utils_1.sumOutputValues(renewalTX); // 1 additional input for the owner\n    // and renewal skeleton includes all outputs for owner change, but not for payer change.\n\n    var txFee = feeRate * utils_1.estimateTXBytes(renewalTX, 1 + paymentUtxos, 1);\n    return txFee + outputsValue - 5500; // don't count the dust change for old owner.\n  });\n}\n/**\n * Estimates cost of a revoke transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to revoke\n * @param {String} ownerAddress - the current owner of the name\n * @param {String} paymentAddress  the address funding the revoke\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund the\n *    revoke.\n * @private\n */\n\n\nfunction estimateRevoke(fullyQualifiedName, ownerAddress, paymentAddress) {\n  var paymentUtxos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var network = config_1.config.network;\n  var revokeTX = skeletons_1.makeRevokeSkeleton(fullyQualifiedName);\n  return Promise.all([network.getFeeRate()]).then(function (_ref5) {\n    var _ref6 = _slicedToArray(_ref5, 1),\n        feeRate = _ref6[0];\n\n    var outputsValue = utils_1.sumOutputValues(revokeTX); // 1 additional input for owner\n    // 1 additional output for payer change\n\n    var txFee = feeRate * utils_1.estimateTXBytes(revokeTX, 1 + paymentUtxos, 2);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates cost of a namespace preorder transaction for a namespace\n * @param {String} namespaceID - the namespace to preorder\n * @param {String} revealAddress - the address to receive the namespace (this\n *    must be passed as the 'revealAddress' in the namespace-reveal transaction)\n * @param {String} paymentAddress - the address funding the preorder\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the preorder. This includes a 5500 satoshi dust output for the preorder.\n *    Even though this is a change output, the payer must supply enough funds\n *    to generate this output, so we include it in the cost.\n * @private\n */\n\n\nfunction estimateNamespacePreorder(namespaceID, revealAddress, paymentAddress) {\n  var paymentUtxos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var network = config_1.config.network;\n  var preorderPromise = network.getNamespacePrice(namespaceID).then(function (namespacePrice) {\n    return skeletons_1.makeNamespacePreorderSkeleton(namespaceID, dummyConsensusHash, paymentAddress, revealAddress, namespacePrice);\n  });\n  return Promise.all([network.getFeeRate(), preorderPromise]).then(function (_ref7) {\n    var _ref8 = _slicedToArray(_ref7, 2),\n        feeRate = _ref8[0],\n        preorderTX = _ref8[1];\n\n    var outputsValue = utils_1.sumOutputValues(preorderTX);\n    var txFee = feeRate * utils_1.estimateTXBytes(preorderTX, paymentUtxos, 0);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates cost of a namesapce reveal transaction for a namespace\n * @param {BlockstackNamespace} namespace - the namespace to reveal\n * @param {String} revealAddress - the address to receive the namespace\n *    (this must have been passed as 'revealAddress' to a prior namespace\n *    preorder)\n * @param {String} paymentAddress - the address that pays for this transaction\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address\n * @returns {Promise} - a promise which resolves to the satoshi cost to\n *    fund the reveal.  This includes a 5500 satoshi dust output for the\n *    preorder.  Even though this is a change output, the payer must have\n *    enough funds to generate this output, so we include it in the cost.\n * @private\n */\n\n\nfunction estimateNamespaceReveal(namespace, revealAddress, paymentAddress) {\n  var paymentUtxos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var network = config_1.config.network;\n  var revealTX = skeletons_1.makeNamespaceRevealSkeleton(namespace, revealAddress);\n  return network.getFeeRate().then(function (feeRate) {\n    var outputsValue = utils_1.sumOutputValues(revealTX); // 1 additional output for payer change\n\n    var txFee = feeRate * utils_1.estimateTXBytes(revealTX, paymentUtxos, 1);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates the cost of a namespace-ready transaction for a namespace\n * @param {String} namespaceID - the namespace to ready\n * @param {Number} revealUtxos - the number of UTXOs we expect will\n *  be required from the reveal address\n * @returns {Promise} - a promise which resolves to the satoshi cost to\n *  fund this namespacey-ready transaction.\n * @private\n */\n\n\nfunction estimateNamespaceReady(namespaceID) {\n  var revealUtxos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var network = config_1.config.network;\n  var readyTX = skeletons_1.makeNamespaceReadySkeleton(namespaceID);\n  return network.getFeeRate().then(function (feeRate) {\n    var outputsValue = utils_1.sumOutputValues(readyTX);\n    var txFee = feeRate * utils_1.estimateTXBytes(readyTX, revealUtxos, 1);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates the cost of a name-import transaction\n * @param {String} name - the fully-qualified name\n * @param {String} recipientAddr - the recipient\n * @param {String} zonefileHash - the zone file hash\n * @param {Number} importUtxos - the number of UTXOs we expect will\n *  be required from the importer address\n * @returns {Promise} - a promise which resolves to the satoshi cost\n *  to fund this name-import transaction\n * @private\n */\n\n\nfunction estimateNameImport(name, recipientAddr, zonefileHash) {\n  var importUtxos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var network = config_1.config.network;\n  var importTX = skeletons_1.makeNameImportSkeleton(name, recipientAddr, zonefileHash);\n  return network.getFeeRate().then(function (feeRate) {\n    var outputsValue = utils_1.sumOutputValues(importTX);\n    var txFee = feeRate * utils_1.estimateTXBytes(importTX, importUtxos, 1);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates the cost of an announce transaction\n * @param {String} messageHash - the hash of the message\n * @param {Number} senderUtxos - the number of utxos we expect will\n *  be required from the importer address\n * @returns {Promise} - a promise which resolves to the satoshi cost\n *  to fund this announce transaction\n * @private\n */\n\n\nfunction estimateAnnounce(messageHash) {\n  var senderUtxos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var network = config_1.config.network;\n  var announceTX = skeletons_1.makeAnnounceSkeleton(messageHash);\n  return network.getFeeRate().then(function (feeRate) {\n    var outputsValue = utils_1.sumOutputValues(announceTX);\n    var txFee = feeRate * utils_1.estimateTXBytes(announceTX, senderUtxos, 1);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates the cost of a token-transfer transaction\n * @param {String} recipientAddress - the recipient of the tokens\n * @param {String} tokenType - the type of token to spend\n * @param {Object} tokenAmount - a 64-bit unsigned BigInteger encoding the number of tokens\n *   to spend\n * @param {String} scratchArea - an arbitrary string to store with the transaction\n * @param {Number} senderUtxos - the number of utxos we expect will\n *  be required from the importer address\n * @param {Number} additionalOutputs - the number of outputs we expect to add beyond\n *  just the recipient output (default = 1, if the token owner is also the bitcoin funder)\n * @returns {Promise} - a promise which resolves to the satoshi cost to\n *  fund this token-transfer transaction\n * @private\n */\n\n\nfunction estimateTokenTransfer(recipientAddress, tokenType, tokenAmount, scratchArea) {\n  var senderUtxos = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  var additionalOutputs = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n  var network = config_1.config.network;\n  var tokenTransferTX = skeletons_1.makeTokenTransferSkeleton(recipientAddress, dummyConsensusHash, tokenType, tokenAmount, scratchArea);\n  return network.getFeeRate().then(function (feeRate) {\n    var outputsValue = utils_1.sumOutputValues(tokenTransferTX);\n    var txFee = feeRate * utils_1.estimateTXBytes(tokenTransferTX, senderUtxos, additionalOutputs);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Generates a preorder transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to pre-order\n * @param {String} destinationAddress - the address to receive the name (this\n *    must be passed as the 'registrationAddress' in the register transaction)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the transaction or a transaction signer object\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n * indicating whether the function should attempt to return an unsigned (or not fully signed)\n * transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\n\n\nfunction makePreorder(fullyQualifiedName, destinationAddress, paymentKeyIn) {\n  var buildIncomplete = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var network = config_1.config.network;\n  var namespace = fullyQualifiedName.split('.').pop();\n  var paymentKey = getTransactionSigner(paymentKeyIn);\n  return paymentKey.getAddress().then(function (preorderAddress) {\n    var preorderPromise = Promise.all([network.getConsensusHash(), network.getNamePrice(fullyQualifiedName), network.getNamespaceBurnAddress(namespace)]).then(function (_ref9) {\n      var _ref10 = _slicedToArray(_ref9, 3),\n          consensusHash = _ref10[0],\n          namePrice = _ref10[1],\n          burnAddress = _ref10[2];\n\n      return skeletons_1.makePreorderSkeleton(fullyQualifiedName, consensusHash, preorderAddress, burnAddress, namePrice, destinationAddress);\n    });\n    return Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate(), preorderPromise]).then(function (_ref11) {\n      var _ref12 = _slicedToArray(_ref11, 3),\n          utxos = _ref12[0],\n          feeRate = _ref12[1],\n          preorderSkeleton = _ref12[2];\n\n      var txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(preorderSkeleton, network.layer1);\n      txB.setVersion(1);\n      var changeIndex = 1; // preorder skeleton always creates a change output at index = 1\n\n      var signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0, changeIndex);\n      return utils_1.signInputs(signingTxB, paymentKey);\n    }).then(function (signingTxB) {\n      return returnTransactionHex(signingTxB, buildIncomplete);\n    });\n  });\n}\n/**\n * Generates an update transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to update\n * @param {String | TransactionSigner} ownerKeyIn - a hex string of the\n *    owner key, or a transaction signer object. This will provide one\n *    UTXO input, and also recieve a dust output.\n * @param {String | TransactionSigner} paymentKeyIn - a hex string, or a\n *    transaction signer object, of the private key used to fund the\n *    transaction's txfees\n * @param {String} zonefile - the zonefile data to update (this will be hashed\n *    to include in the transaction), the zonefile itself must be published\n *    after the UPDATE propagates.\n * @param {String} valueHash - if given, this is the hash to store (instead of\n *    zonefile).  zonefile will be ignored if this is given.\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\n\n\nfunction makeUpdate(fullyQualifiedName, ownerKeyIn, paymentKeyIn, zonefile) {\n  var valueHash = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';\n  var buildIncomplete = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var network = config_1.config.network;\n\n  if (!valueHash && !zonefile) {\n    return Promise.reject(new Error('Need zonefile or valueHash arguments'));\n  }\n\n  if (valueHash.length === 0) {\n    if (!zonefile) {\n      return Promise.reject(new Error('Need zonefile or valueHash arguments'));\n    }\n\n    valueHash = utils_1.hash160(Buffer.from(zonefile)).toString('hex');\n  } else if (valueHash.length !== 40) {\n    return Promise.reject(new Error(\"Invalid valueHash \".concat(valueHash)));\n  }\n\n  var paymentKey = getTransactionSigner(paymentKeyIn);\n  var ownerKey = getTransactionSigner(ownerKeyIn);\n  return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()]).then(function (_ref13) {\n    var _ref14 = _slicedToArray(_ref13, 2),\n        ownerAddress = _ref14[0],\n        paymentAddress = _ref14[1];\n\n    var txPromise = network.getConsensusHash().then(function (consensusHash) {\n      return skeletons_1.makeUpdateSkeleton(fullyQualifiedName, consensusHash, valueHash);\n    }).then(function (updateTX) {\n      var txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(updateTX, network.layer1);\n      txB.setVersion(1);\n      return txB;\n    });\n    return Promise.all([txPromise, network.getUTXOs(paymentAddress), network.getUTXOs(ownerAddress), network.getFeeRate()]).then(function (_ref15) {\n      var _ref16 = _slicedToArray(_ref15, 4),\n          txB = _ref16[0],\n          payerUtxos = _ref16[1],\n          ownerUtxos = _ref16[2],\n          feeRate = _ref16[3];\n\n      var ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);\n      var signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);\n      return utils_1.signInputs(signingTxB, paymentKey, [{\n        index: ownerInput.index,\n        signer: ownerKey\n      }]);\n    });\n  }).then(function (signingTxB) {\n    return returnTransactionHex(signingTxB, buildIncomplete);\n  });\n}\n/**\n * Generates a register transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to register\n * @param {String} registerAddress - the address to receive the name (this\n *    must have been passed as the 'destinationAddress' in the preorder transaction)\n *    this address will receive a dust UTXO\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key (or a TransactionSigner object) used to fund the\n *    transaction (this *must* be the same as the payment address used\n *    to fund the preorder)\n * @param {String} zonefile - the zonefile data to include (this will be hashed\n *    to include in the transaction), the zonefile itself must be published\n *    after the UPDATE propagates.\n * @param {String} valueHash - the hash of the zone file data to include.\n *    It will be used instead of zonefile, if given\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\n\n\nfunction makeRegister(fullyQualifiedName, registerAddress, paymentKeyIn) {\n  var zonefile = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var valueHash = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var buildIncomplete = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var network = config_1.config.network;\n\n  if (!valueHash && !!zonefile) {\n    valueHash = utils_1.hash160(Buffer.from(zonefile)).toString('hex');\n  } else if (!!valueHash && valueHash.length !== 40) {\n    return Promise.reject(new Error(\"Invalid zonefile hash \".concat(valueHash)));\n  }\n\n  var registerSkeleton = skeletons_1.makeRegisterSkeleton(fullyQualifiedName, registerAddress, valueHash);\n  var txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(registerSkeleton, network.layer1);\n  txB.setVersion(1);\n  var paymentKey = getTransactionSigner(paymentKeyIn);\n  return paymentKey.getAddress().then(function (paymentAddress) {\n    return Promise.all([network.getUTXOs(paymentAddress), network.getFeeRate()]).then(function (_ref17) {\n      var _ref18 = _slicedToArray(_ref17, 2),\n          utxos = _ref18[0],\n          feeRate = _ref18[1];\n\n      var signingTxB = fundTransaction(txB, paymentAddress, utxos, feeRate, 0);\n      return utils_1.signInputs(signingTxB, paymentKey);\n    });\n  }).then(function (signingTxB) {\n    return returnTransactionHex(signingTxB, buildIncomplete);\n  });\n}\n/**\n * Generates a transfer transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to transfer\n * @param {String} destinationAddress - the address to receive the name.\n *    this address will receive a dust UTXO\n * @param {String | TransactionSigner} ownerKeyIn - a hex string of\n *    the current owner's private key (or a TransactionSigner object)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the transaction (or a\n *    TransactionSigner object)\n * @param {Boolean} keepZonefile - if true, then preserve the name's zone file\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *   indicating whether the function should attempt to return an unsigned (or not fully signed)\n *   transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\n\n\nfunction makeTransfer(fullyQualifiedName, destinationAddress, ownerKeyIn, paymentKeyIn) {\n  var keepZonefile = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var buildIncomplete = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var network = config_1.config.network;\n  var paymentKey = getTransactionSigner(paymentKeyIn);\n  var ownerKey = getTransactionSigner(ownerKeyIn);\n  return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()]).then(function (_ref19) {\n    var _ref20 = _slicedToArray(_ref19, 2),\n        ownerAddress = _ref20[0],\n        paymentAddress = _ref20[1];\n\n    var txPromise = network.getConsensusHash().then(function (consensusHash) {\n      return skeletons_1.makeTransferSkeleton(fullyQualifiedName, consensusHash, destinationAddress, keepZonefile);\n    }).then(function (transferTX) {\n      var txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(transferTX, network.layer1);\n      txB.setVersion(1);\n      return txB;\n    });\n    return Promise.all([txPromise, network.getUTXOs(paymentAddress), network.getUTXOs(ownerAddress), network.getFeeRate()]).then(function (_ref21) {\n      var _ref22 = _slicedToArray(_ref21, 4),\n          txB = _ref22[0],\n          payerUtxos = _ref22[1],\n          ownerUtxos = _ref22[2],\n          feeRate = _ref22[3];\n\n      var ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);\n      var signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);\n      return utils_1.signInputs(signingTxB, paymentKey, [{\n        index: ownerInput.index,\n        signer: ownerKey\n      }]);\n    });\n  }).then(function (signingTxB) {\n    return returnTransactionHex(signingTxB, buildIncomplete);\n  });\n}\n/**\n * Generates a revoke transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to revoke\n * @param {String | TransactionSigner} ownerKeyIn - a hex string of\n *    the current owner's private key (or a TransactionSigner object)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the transaction (or a\n *    TransactionSigner object)\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\n\n\nfunction makeRevoke(fullyQualifiedName, ownerKeyIn, paymentKeyIn) {\n  var buildIncomplete = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var network = config_1.config.network;\n  var paymentKey = getTransactionSigner(paymentKeyIn);\n  var ownerKey = getTransactionSigner(ownerKeyIn);\n  return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()]).then(function (_ref23) {\n    var _ref24 = _slicedToArray(_ref23, 2),\n        ownerAddress = _ref24[0],\n        paymentAddress = _ref24[1];\n\n    var revokeTX = skeletons_1.makeRevokeSkeleton(fullyQualifiedName);\n    var txPromise = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(revokeTX, network.layer1);\n    txPromise.setVersion(1);\n    return Promise.all([txPromise, network.getUTXOs(paymentAddress), network.getUTXOs(ownerAddress), network.getFeeRate()]).then(function (_ref25) {\n      var _ref26 = _slicedToArray(_ref25, 4),\n          txB = _ref26[0],\n          payerUtxos = _ref26[1],\n          ownerUtxos = _ref26[2],\n          feeRate = _ref26[3];\n\n      var ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);\n      var signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);\n      return utils_1.signInputs(signingTxB, paymentKey, [{\n        index: ownerInput.index,\n        signer: ownerKey\n      }]);\n    });\n  }).then(function (signingTxB) {\n    return returnTransactionHex(signingTxB, buildIncomplete);\n  });\n}\n/**\n * Generates a renewal transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to transfer\n * @param {String} destinationAddress - the address to receive the name after renewal\n *    this address will receive a dust UTXO\n * @param {String | TransactionSigner} ownerKeyIn - a hex string of\n *    the current owner's private key (or a TransactionSigner object)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the renewal (or a TransactionSigner\n *    object)\n * @param {String} zonefile - the zonefile data to include, if given (this will be hashed\n *    to include in the transaction), the zonefile itself must be published\n *    after the RENEWAL propagates.\n * @param {String} valueHash - the raw zone file hash to include (this will be used\n *    instead of zonefile, if given).\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\n\n\nfunction makeRenewal(fullyQualifiedName, destinationAddress, ownerKeyIn, paymentKeyIn) {\n  var zonefile = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var valueHash = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var buildIncomplete = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  var network = config_1.config.network;\n\n  if (!valueHash && !!zonefile) {\n    valueHash = utils_1.hash160(Buffer.from(zonefile)).toString('hex');\n  }\n\n  var namespace = fullyQualifiedName.split('.').pop();\n  var paymentKey = getTransactionSigner(paymentKeyIn);\n  var ownerKey = getTransactionSigner(ownerKeyIn);\n  return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()]).then(function (_ref27) {\n    var _ref28 = _slicedToArray(_ref27, 2),\n        ownerAddress = _ref28[0],\n        paymentAddress = _ref28[1];\n\n    var txPromise = Promise.all([network.getNamePrice(fullyQualifiedName), network.getNamespaceBurnAddress(namespace)]).then(function (_ref29) {\n      var _ref30 = _slicedToArray(_ref29, 2),\n          namePrice = _ref30[0],\n          burnAddress = _ref30[1];\n\n      return skeletons_1.makeRenewalSkeleton(fullyQualifiedName, destinationAddress, ownerAddress, burnAddress, namePrice, valueHash);\n    }).then(function (tx) {\n      var txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(tx, network.layer1);\n      txB.setVersion(1);\n      return txB;\n    });\n    return Promise.all([txPromise, network.getUTXOs(paymentAddress), network.getUTXOs(ownerAddress), network.getFeeRate()]).then(function (_ref31) {\n      var _ref32 = _slicedToArray(_ref31, 4),\n          txB = _ref32[0],\n          payerUtxos = _ref32[1],\n          ownerUtxos = _ref32[2],\n          feeRate = _ref32[3];\n\n      var ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB, false);\n      var txInner = utils_1.getTransactionInsideBuilder(txB);\n      var ownerOutput = txInner.outs[2];\n      var ownerOutputAddr = bitcoinjs_lib_1.address.fromOutputScript(ownerOutput.script, network.layer1);\n\n      if (ownerOutputAddr !== ownerAddress) {\n        return Promise.reject(new Error(\"Original owner \".concat(ownerAddress, \" should have an output at \") + \"index 2 in transaction was \".concat(ownerOutputAddr)));\n      }\n\n      ownerOutput.value = ownerInput.value;\n      var signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);\n      return utils_1.signInputs(signingTxB, paymentKey, [{\n        index: ownerInput.index,\n        signer: ownerKey\n      }]);\n    });\n  }).then(function (signingTxB) {\n    return returnTransactionHex(signingTxB, buildIncomplete);\n  });\n}\n/**\n * Generates a namespace preorder transaction for a namespace\n * @param {String} namespaceID - the namespace to pre-order\n * @param {String} revealAddress - the address to receive the namespace (this\n *    must be passed as the 'revealAddress' in the namespace-reveal transaction)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the transaction (or a\n *    TransactionSigner object)\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n *\n * @ignore\n */\n\n\nfunction makeNamespacePreorder(namespaceID, revealAddress, paymentKeyIn) {\n  var buildIncomplete = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var network = config_1.config.network;\n  var paymentKey = getTransactionSigner(paymentKeyIn);\n  return paymentKey.getAddress().then(function (preorderAddress) {\n    var preorderPromise = Promise.all([network.getConsensusHash(), network.getNamespacePrice(namespaceID)]).then(function (_ref33) {\n      var _ref34 = _slicedToArray(_ref33, 2),\n          consensusHash = _ref34[0],\n          namespacePrice = _ref34[1];\n\n      return skeletons_1.makeNamespacePreorderSkeleton(namespaceID, consensusHash, preorderAddress, revealAddress, namespacePrice);\n    });\n    return Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate(), preorderPromise]).then(function (_ref35) {\n      var _ref36 = _slicedToArray(_ref35, 3),\n          utxos = _ref36[0],\n          feeRate = _ref36[1],\n          preorderSkeleton = _ref36[2];\n\n      var txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(preorderSkeleton, network.layer1);\n      txB.setVersion(1);\n      var changeIndex = 1; // preorder skeleton always creates a change output at index = 1\n\n      var signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0, changeIndex);\n      return utils_1.signInputs(signingTxB, paymentKey);\n    }).then(function (signingTxB) {\n      return returnTransactionHex(signingTxB, buildIncomplete);\n    });\n  });\n}\n/**\n * Generates a namespace reveal transaction for a namespace\n * @param {BlockstackNamespace} namespace - the namespace to reveal\n * @param {String} revealAddress - the address to receive the namespace (this\n *   must be passed as the 'revealAddress' in the namespace-reveal transaction)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string (or\n *   a TransactionSigner object) of the private key used to fund the\n *   transaction\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *   indicating whether the function should attempt to return an unsigned (or not fully signed)\n *   transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *   this function *does not* perform the requisite safety checks -- please see\n *   the safety module for those.\n * @private\n */\n\n\nfunction makeNamespaceReveal(namespace, revealAddress, paymentKeyIn) {\n  var buildIncomplete = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var network = config_1.config.network;\n\n  if (!namespace.check()) {\n    return Promise.reject(new Error('Invalid namespace'));\n  }\n\n  var namespaceRevealTX = skeletons_1.makeNamespaceRevealSkeleton(namespace, revealAddress);\n  var paymentKey = getTransactionSigner(paymentKeyIn);\n  return paymentKey.getAddress().then(function (preorderAddress) {\n    return Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate()]).then(function (_ref37) {\n      var _ref38 = _slicedToArray(_ref37, 2),\n          utxos = _ref38[0],\n          feeRate = _ref38[1];\n\n      var txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(namespaceRevealTX, network.layer1);\n      txB.setVersion(1);\n      var signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0);\n      return utils_1.signInputs(signingTxB, paymentKey);\n    });\n  }).then(function (signingTxB) {\n    return returnTransactionHex(signingTxB, buildIncomplete);\n  });\n}\n/**\n * Generates a namespace ready transaction for a namespace\n * @param {String} namespaceID - the namespace to launch\n * @param {String | TransactionSigner} revealKeyIn - the private key\n *  of the 'revealAddress' used to reveal the namespace\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *  indicating whether the function should attempt to return an unsigned (or not fully signed)\n *  transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *  this function *does not* perform the requisite safety checks -- please see\n *  the safety module for those.\n * @private\n */\n\n\nfunction makeNamespaceReady(namespaceID, revealKeyIn) {\n  var buildIncomplete = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var network = config_1.config.network;\n  var namespaceReadyTX = skeletons_1.makeNamespaceReadySkeleton(namespaceID);\n  var revealKey = getTransactionSigner(revealKeyIn);\n  return revealKey.getAddress().then(function (revealAddress) {\n    return Promise.all([network.getUTXOs(revealAddress), network.getFeeRate()]).then(function (_ref39) {\n      var _ref40 = _slicedToArray(_ref39, 2),\n          utxos = _ref40[0],\n          feeRate = _ref40[1];\n\n      var txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(namespaceReadyTX, network.layer1);\n      txB.setVersion(1);\n      var signingTxB = fundTransaction(txB, revealAddress, utxos, feeRate, 0);\n      return utils_1.signInputs(signingTxB, revealKey);\n    });\n  }).then(function (signingTxB) {\n    return returnTransactionHex(signingTxB, buildIncomplete);\n  });\n}\n/**\n * Generates a name import transaction for a namespace\n * @param {String} name - the name to import\n * @param {String} recipientAddr - the address to receive the name\n * @param {String} zonefileHash - the hash of the zonefile to give this name\n * @param {String | TransactionSigner} importerKeyIn - the private key\n * that pays for the import\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n * indicating whether the function should attempt to return an unsigned (or not fully signed)\n * transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n * this function does not perform the requisite safety checks -- please see\n * the safety module for those.\n * @private\n */\n\n\nfunction makeNameImport(name, recipientAddr, zonefileHash, importerKeyIn) {\n  var buildIncomplete = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var network = config_1.config.network;\n  var nameImportTX = skeletons_1.makeNameImportSkeleton(name, recipientAddr, zonefileHash);\n  var importerKey = getTransactionSigner(importerKeyIn);\n  return importerKey.getAddress().then(function (importerAddress) {\n    return Promise.all([network.getUTXOs(importerAddress), network.getFeeRate()]).then(function (_ref41) {\n      var _ref42 = _slicedToArray(_ref41, 2),\n          utxos = _ref42[0],\n          feeRate = _ref42[1];\n\n      var txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(nameImportTX, network.layer1);\n      var signingTxB = fundTransaction(txB, importerAddress, utxos, feeRate, 0);\n      return utils_1.signInputs(signingTxB, importerKey);\n    });\n  }).then(function (signingTxB) {\n    return returnTransactionHex(signingTxB, buildIncomplete);\n  });\n}\n/**\n * Generates an announce transaction\n * @param {String} messageHash - the hash of the message to send.  Should be\n *  an already-announced zone file hash\n * @param {String | TransactionSigner} senderKeyIn - the private key\n *  that pays for the transaction.  Should be the key that owns the\n *  name that the message recipients subscribe to\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n * indicating whether the function should attempt to return an unsigned (or not fully signed)\n * transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n * this function does not perform the requisite safety checks -- please see the\n * safety module for those.\n * @private\n */\n\n\nfunction makeAnnounce(messageHash, senderKeyIn) {\n  var buildIncomplete = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var network = config_1.config.network;\n  var announceTX = skeletons_1.makeAnnounceSkeleton(messageHash);\n  var senderKey = getTransactionSigner(senderKeyIn);\n  return senderKey.getAddress().then(function (senderAddress) {\n    return Promise.all([network.getUTXOs(senderAddress), network.getFeeRate()]).then(function (_ref43) {\n      var _ref44 = _slicedToArray(_ref43, 2),\n          utxos = _ref44[0],\n          feeRate = _ref44[1];\n\n      var txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(announceTX, network.layer1);\n      var signingTxB = fundTransaction(txB, senderAddress, utxos, feeRate, 0);\n      return utils_1.signInputs(signingTxB, senderKey);\n    });\n  }).then(function (signingTxB) {\n    return returnTransactionHex(signingTxB, buildIncomplete);\n  });\n}\n/**\n * Generates a token-transfer transaction\n * @param {String} recipientAddress - the address to receive the tokens\n * @param {String} tokenType - the type of tokens to send\n * @param {Object} tokenAmount - the BigInteger encoding of an unsigned 64-bit number of\n *  tokens to send\n * @param {String} scratchArea - an arbitrary string to include with the transaction\n * @param {String | TransactionSigner} senderKeyIn - the hex-encoded private key to send\n *   the tokens\n * @param {String | TransactionSigner} btcFunderKeyIn - the hex-encoded private key to fund\n *   the bitcoin fees for the transaction. Optional -- if not passed, will attempt to\n *   fund with sender key.\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *   indicating whether the function should attempt to return an unsigned (or not fully signed)\n *   transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n * This function does not perform the requisite safety checks -- please see the\n * safety module for those.\n * @private\n */\n\n\nfunction makeTokenTransfer(recipientAddress, tokenType, tokenAmount, scratchArea, senderKeyIn, btcFunderKeyIn) {\n  var buildIncomplete = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  var network = config_1.config.network;\n  var separateFunder = !!btcFunderKeyIn;\n  var senderKey = getTransactionSigner(senderKeyIn);\n  var btcKey = btcFunderKeyIn ? getTransactionSigner(btcFunderKeyIn) : senderKey;\n  var txPromise = network.getConsensusHash().then(function (consensusHash) {\n    return skeletons_1.makeTokenTransferSkeleton(recipientAddress, consensusHash, tokenType, tokenAmount, scratchArea);\n  });\n  return Promise.all([senderKey.getAddress(), btcKey.getAddress()]).then(function (_ref45) {\n    var _ref46 = _slicedToArray(_ref45, 2),\n        senderAddress = _ref46[0],\n        btcAddress = _ref46[1];\n\n    var btcUTXOsPromise = separateFunder ? network.getUTXOs(btcAddress) : Promise.resolve([]);\n    return Promise.all([network.getUTXOs(senderAddress), btcUTXOsPromise, network.getFeeRate(), txPromise]).then(function (_ref47) {\n      var _ref48 = _slicedToArray(_ref47, 4),\n          senderUTXOs = _ref48[0],\n          btcUTXOs = _ref48[1],\n          feeRate = _ref48[2],\n          tokenTransferTX = _ref48[3];\n\n      var txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(tokenTransferTX, network.layer1);\n\n      if (separateFunder) {\n        var payerInput = addOwnerInput(senderUTXOs, senderAddress, txB);\n        var signingTxB = fundTransaction(txB, btcAddress, btcUTXOs, feeRate, payerInput.value);\n        return utils_1.signInputs(signingTxB, btcKey, [{\n          index: payerInput.index,\n          signer: senderKey\n        }]);\n      } else {\n        var _signingTxB = fundTransaction(txB, senderAddress, senderUTXOs, feeRate, 0);\n\n        return utils_1.signInputs(_signingTxB, senderKey);\n      }\n    });\n  }).then(function (signingTxB) {\n    return returnTransactionHex(signingTxB, buildIncomplete);\n  });\n}\n/**\n * Generates a bitcoin spend to a specified address. This will fund up to `amount`\n *   of satoshis from the payer's UTXOs. It will generate a change output if and only\n *   if the amount of leftover change is *greater* than the additional fees associated\n *   with the extra output. If the requested amount is not enough to fund the transaction's\n *   associated fees, then this will reject with a InvalidAmountError\n *\n * UTXOs are selected largest to smallest, and UTXOs which cannot fund the fees associated\n *   with their own input will not be included.\n *\n * If you specify an amount > the total balance of the payer address, then this will\n *   generate a maximum spend transaction\n *\n * @param {String} destinationAddress - the address to receive the bitcoin payment\n * @param {String | TransactionSigner} paymentKeyIn - the private key\n *    used to fund the bitcoin spend\n * @param {number} amount - the amount in satoshis for the payment address to\n *    spend in this transaction\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n * indicating whether the function should attempt to return an unsigned (or not fully signed)\n * transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n * @private\n */\n\n\nfunction makeBitcoinSpend(destinationAddress, paymentKeyIn, amount) {\n  var buildIncomplete = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (amount <= 0) {\n    return Promise.reject(new errors_1.InvalidParameterError('amount', 'amount must be greater than zero'));\n  }\n\n  var network = config_1.config.network;\n  var paymentKey = getTransactionSigner(paymentKeyIn);\n  return paymentKey.getAddress().then(function (paymentAddress) {\n    return Promise.all([network.getUTXOs(paymentAddress), network.getFeeRate()]).then(function (_ref49) {\n      var _ref50 = _slicedToArray(_ref49, 2),\n          utxos = _ref50[0],\n          feeRate = _ref50[1];\n\n      var txB = new bitcoinjs_lib_1.TransactionBuilder(network.layer1);\n      txB.setVersion(1);\n      var destinationIndex = txB.addOutput(destinationAddress, 0); // will add utxos up to _amount_ and return the amount of leftover _change_\n\n      var change;\n\n      try {\n        change = utils_1.addUTXOsToFund(txB, utxos, amount, feeRate, false);\n      } catch (err) {\n        if (err.name === 'NotEnoughFundsError') {\n          // actual amount funded = amount requested - remainder\n          amount -= err.leftToFund;\n          change = 0;\n        } else {\n          throw err;\n        }\n      }\n\n      var feesToPay = feeRate * utils_1.estimateTXBytes(txB, 0, 0);\n      var feeForChange = feeRate * utils_1.estimateTXBytes(txB, 0, 1) - feesToPay; // it's worthwhile to add a change output\n\n      if (change > feeForChange) {\n        feesToPay += feeForChange;\n        txB.addOutput(paymentAddress, change);\n      } // now let's compute how much output is leftover once we pay the fees.\n\n\n      var outputAmount = amount - feesToPay;\n\n      if (outputAmount < utils_1.DUST_MINIMUM) {\n        throw new errors_1.InvalidAmountError(feesToPay, amount);\n      } // we need to manually set the output values now\n\n\n      var txInner = utils_1.getTransactionInsideBuilder(txB);\n      var txOut = txInner.outs[destinationIndex];\n      txOut.value = outputAmount; // ready to sign.\n\n      return utils_1.signInputs(txB, paymentKey);\n    });\n  }).then(function (signingTxB) {\n    return returnTransactionHex(signingTxB, buildIncomplete);\n  });\n}\n\nexports.transactions = {\n  makeRenewal: makeRenewal,\n  makeUpdate: makeUpdate,\n  makePreorder: makePreorder,\n  makeRegister: makeRegister,\n  makeTransfer: makeTransfer,\n  makeRevoke: makeRevoke,\n  makeNamespacePreorder: makeNamespacePreorder,\n  makeNamespaceReveal: makeNamespaceReveal,\n  makeNamespaceReady: makeNamespaceReady,\n  makeBitcoinSpend: makeBitcoinSpend,\n  makeNameImport: makeNameImport,\n  makeAnnounce: makeAnnounce,\n  makeTokenTransfer: makeTokenTransfer,\n  BlockstackNamespace: skeletons_1.BlockstackNamespace,\n  estimatePreorder: estimatePreorder,\n  estimateRegister: estimateRegister,\n  estimateTransfer: estimateTransfer,\n  estimateUpdate: estimateUpdate,\n  estimateRenewal: estimateRenewal,\n  estimateRevoke: estimateRevoke,\n  estimateNamespacePreorder: estimateNamespacePreorder,\n  estimateNamespaceReveal: estimateNamespaceReveal,\n  estimateNamespaceReady: estimateNamespaceReady,\n  estimateNameImport: estimateNameImport,\n  estimateAnnounce: estimateAnnounce,\n  estimateTokenTransfer: estimateTokenTransfer\n};","map":{"version":3,"sources":["../../src/operations/txbuild.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\nconst utils_1 = require(\"./utils\");\nconst skeletons_1 = require(\"./skeletons\");\nconst config_1 = require(\"../config\");\nconst errors_1 = require(\"../errors\");\nconst signers_1 = require(\"./signers\");\nconst dummyConsensusHash = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';\nconst dummyZonefileHash = 'ffffffffffffffffffffffffffffffffffffffff';\n/**\n* @ignore\n*/\nfunction addOwnerInput(utxos, ownerAddress, txB, addChangeOut = true) {\n    // add an owner UTXO and a change out.\n    if (utxos.length <= 0) {\n        throw new Error('Owner has no UTXOs for UPDATE.');\n    }\n    utxos.sort((a, b) => a.value - b.value);\n    const ownerUTXO = utxos[0];\n    const ownerInput = txB.addInput(ownerUTXO.tx_hash, ownerUTXO.tx_output_n);\n    if (addChangeOut) {\n        txB.addOutput(ownerAddress, ownerUTXO.value);\n    }\n    return { index: ownerInput, value: ownerUTXO.value };\n}\n/**\n* @ignore\n*/\nfunction fundTransaction(txB, paymentAddress, utxos, feeRate, inAmounts, changeIndex = null) {\n    // change index for the payer.\n    if (changeIndex === null) {\n        changeIndex = txB.addOutput(paymentAddress, utils_1.DUST_MINIMUM);\n    }\n    // fund the transaction fee.\n    const txFee = utils_1.estimateTXBytes(txB, 0, 0) * feeRate;\n    const outAmounts = utils_1.sumOutputValues(txB);\n    const change = utils_1.addUTXOsToFund(txB, utxos, txFee + outAmounts - inAmounts, feeRate);\n    const txInner = utils_1.getTransactionInsideBuilder(txB);\n    const txOut = txInner.outs[changeIndex];\n    txOut.value += change;\n    return txB;\n}\n/**\n* @ignore\n*/\nfunction returnTransactionHex(txB, buildIncomplete = false) {\n    if (buildIncomplete) {\n        return txB.buildIncomplete().toHex();\n    }\n    else {\n        return txB.build().toHex();\n    }\n}\n/**\n* @ignore\n*/\nfunction getTransactionSigner(input) {\n    if (typeof input === 'string') {\n        return signers_1.PubkeyHashSigner.fromHexString(input);\n    }\n    else {\n        return input;\n    }\n}\n/**\n * Estimates cost of a preorder transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to preorder\n * @param {String} destinationAddress - the address to receive the name (this\n *    must be passed as the 'registrationAddress' in the register transaction)\n * @param {String} paymentAddress - the address funding the preorder\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the preorder. This includes a 5500 satoshi dust output for the preorder.\n *    Even though this is a change output, the payer must supply enough funds\n *    to generate this output, so we include it in the cost.\n * @private\n */\nfunction estimatePreorder(fullyQualifiedName, destinationAddress, paymentAddress, paymentUtxos = 1) {\n    const network = config_1.config.network;\n    const preorderPromise = network.getNamePrice(fullyQualifiedName)\n        .then(namePrice => skeletons_1.makePreorderSkeleton(fullyQualifiedName, dummyConsensusHash, paymentAddress, network.getDefaultBurnAddress(), namePrice, destinationAddress));\n    return Promise.all([network.getFeeRate(), preorderPromise])\n        .then(([feeRate, preorderTX]) => {\n        const outputsValue = utils_1.sumOutputValues(preorderTX);\n        const txFee = feeRate * utils_1.estimateTXBytes(preorderTX, paymentUtxos, 0);\n        return txFee + outputsValue;\n    });\n}\n/**\n * Estimates cost of a register transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to register\n * @param {String} registerAddress - the address to receive the name\n * @param {String} paymentAddress - the address funding the register\n * @param {Boolean} includingZonefile - whether or not we will broadcast\n *    a zonefile hash as part  of the register\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the register.\n * @private\n */\nfunction estimateRegister(fullyQualifiedName, registerAddress, paymentAddress, includingZonefile = false, paymentUtxos = 1) {\n    const network = config_1.config.network;\n    let valueHash;\n    if (includingZonefile) {\n        valueHash = dummyZonefileHash;\n    }\n    const registerTX = skeletons_1.makeRegisterSkeleton(fullyQualifiedName, registerAddress, valueHash);\n    return network.getFeeRate()\n        .then((feeRate) => {\n        const outputsValue = utils_1.sumOutputValues(registerTX);\n        // 1 additional output for payer change\n        const txFee = feeRate * utils_1.estimateTXBytes(registerTX, paymentUtxos, 1);\n        return txFee + outputsValue;\n    });\n}\n/**\n * Estimates cost of an update transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to update\n * @param {String} ownerAddress - the owner of the name\n * @param {String} paymentAddress - the address funding the update\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the update.\n * @private\n */\nfunction estimateUpdate(fullyQualifiedName, ownerAddress, paymentAddress, paymentUtxos = 1) {\n    const network = config_1.config.network;\n    const updateTX = skeletons_1.makeUpdateSkeleton(fullyQualifiedName, dummyConsensusHash, dummyZonefileHash);\n    return network.getFeeRate()\n        .then((feeRate) => {\n        const outputsValue = utils_1.sumOutputValues(updateTX);\n        // 1 additional input for the owner\n        // 2 additional outputs for owner / payer change\n        const txFee = feeRate * utils_1.estimateTXBytes(updateTX, 1 + paymentUtxos, 2);\n        return txFee + outputsValue;\n    });\n}\n/**\n * Estimates cost of an transfer transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to transfer\n * @param {String} destinationAddress - the next owner of the name\n * @param {String} ownerAddress - the current owner of the name\n * @param {String} paymentAddress - the address funding the transfer\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the transfer.\n * @private\n */\nfunction estimateTransfer(fullyQualifiedName, destinationAddress, ownerAddress, paymentAddress, paymentUtxos = 1) {\n    const network = config_1.config.network;\n    const transferTX = skeletons_1.makeTransferSkeleton(fullyQualifiedName, dummyConsensusHash, destinationAddress);\n    return network.getFeeRate()\n        .then((feeRate) => {\n        const outputsValue = utils_1.sumOutputValues(transferTX);\n        // 1 additional input for the owner\n        // 2 additional outputs for owner / payer change\n        const txFee = feeRate * utils_1.estimateTXBytes(transferTX, 1 + paymentUtxos, 2);\n        return txFee + outputsValue;\n    });\n}\n/**\n * Estimates cost of an transfer transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to renew\n * @param {String} destinationAddress - the next owner of the name\n * @param {String} ownerAddress - the current owner of the name\n * @param {String} paymentAddress - the address funding the transfer\n * @param {Boolean} includingZonefile - whether or not we will broadcast a zonefile hash\n      in the renewal operation\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the transfer.\n * @private\n */\nfunction estimateRenewal(fullyQualifiedName, destinationAddress, ownerAddress, paymentAddress, includingZonefile = false, paymentUtxos = 1) {\n    const network = config_1.config.network;\n    let valueHash;\n    if (includingZonefile) {\n        valueHash = dummyZonefileHash;\n    }\n    const renewalPromise = network.getNamePrice(fullyQualifiedName)\n        .then(namePrice => skeletons_1.makeRenewalSkeleton(fullyQualifiedName, destinationAddress, ownerAddress, network.getDefaultBurnAddress(), namePrice, valueHash));\n    return Promise.all([network.getFeeRate(), renewalPromise])\n        .then(([feeRate, renewalTX]) => {\n        const outputsValue = utils_1.sumOutputValues(renewalTX);\n        // 1 additional input for the owner\n        // and renewal skeleton includes all outputs for owner change, but not for payer change.\n        const txFee = feeRate * utils_1.estimateTXBytes(renewalTX, 1 + paymentUtxos, 1);\n        return txFee + outputsValue - 5500; // don't count the dust change for old owner.\n    });\n}\n/**\n * Estimates cost of a revoke transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to revoke\n * @param {String} ownerAddress - the current owner of the name\n * @param {String} paymentAddress  the address funding the revoke\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund the\n *    revoke.\n * @private\n */\nfunction estimateRevoke(fullyQualifiedName, ownerAddress, paymentAddress, paymentUtxos = 1) {\n    const network = config_1.config.network;\n    const revokeTX = skeletons_1.makeRevokeSkeleton(fullyQualifiedName);\n    return Promise.all([network.getFeeRate()])\n        .then(([feeRate]) => {\n        const outputsValue = utils_1.sumOutputValues(revokeTX);\n        // 1 additional input for owner\n        // 1 additional output for payer change\n        const txFee = feeRate * utils_1.estimateTXBytes(revokeTX, 1 + paymentUtxos, 2);\n        return txFee + outputsValue;\n    });\n}\n/**\n * Estimates cost of a namespace preorder transaction for a namespace\n * @param {String} namespaceID - the namespace to preorder\n * @param {String} revealAddress - the address to receive the namespace (this\n *    must be passed as the 'revealAddress' in the namespace-reveal transaction)\n * @param {String} paymentAddress - the address funding the preorder\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the preorder. This includes a 5500 satoshi dust output for the preorder.\n *    Even though this is a change output, the payer must supply enough funds\n *    to generate this output, so we include it in the cost.\n * @private\n */\nfunction estimateNamespacePreorder(namespaceID, revealAddress, paymentAddress, paymentUtxos = 1) {\n    const network = config_1.config.network;\n    const preorderPromise = network.getNamespacePrice(namespaceID)\n        .then(namespacePrice => skeletons_1.makeNamespacePreorderSkeleton(namespaceID, dummyConsensusHash, paymentAddress, revealAddress, namespacePrice));\n    return Promise.all([network.getFeeRate(), preorderPromise])\n        .then(([feeRate, preorderTX]) => {\n        const outputsValue = utils_1.sumOutputValues(preorderTX);\n        const txFee = feeRate * utils_1.estimateTXBytes(preorderTX, paymentUtxos, 0);\n        return txFee + outputsValue;\n    });\n}\n/**\n * Estimates cost of a namesapce reveal transaction for a namespace\n * @param {BlockstackNamespace} namespace - the namespace to reveal\n * @param {String} revealAddress - the address to receive the namespace\n *    (this must have been passed as 'revealAddress' to a prior namespace\n *    preorder)\n * @param {String} paymentAddress - the address that pays for this transaction\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address\n * @returns {Promise} - a promise which resolves to the satoshi cost to\n *    fund the reveal.  This includes a 5500 satoshi dust output for the\n *    preorder.  Even though this is a change output, the payer must have\n *    enough funds to generate this output, so we include it in the cost.\n * @private\n */\nfunction estimateNamespaceReveal(namespace, revealAddress, paymentAddress, paymentUtxos = 1) {\n    const network = config_1.config.network;\n    const revealTX = skeletons_1.makeNamespaceRevealSkeleton(namespace, revealAddress);\n    return network.getFeeRate()\n        .then((feeRate) => {\n        const outputsValue = utils_1.sumOutputValues(revealTX);\n        // 1 additional output for payer change\n        const txFee = feeRate * utils_1.estimateTXBytes(revealTX, paymentUtxos, 1);\n        return txFee + outputsValue;\n    });\n}\n/**\n * Estimates the cost of a namespace-ready transaction for a namespace\n * @param {String} namespaceID - the namespace to ready\n * @param {Number} revealUtxos - the number of UTXOs we expect will\n *  be required from the reveal address\n * @returns {Promise} - a promise which resolves to the satoshi cost to\n *  fund this namespacey-ready transaction.\n * @private\n */\nfunction estimateNamespaceReady(namespaceID, revealUtxos = 1) {\n    const network = config_1.config.network;\n    const readyTX = skeletons_1.makeNamespaceReadySkeleton(namespaceID);\n    return network.getFeeRate()\n        .then((feeRate) => {\n        const outputsValue = utils_1.sumOutputValues(readyTX);\n        const txFee = feeRate * utils_1.estimateTXBytes(readyTX, revealUtxos, 1);\n        return txFee + outputsValue;\n    });\n}\n/**\n * Estimates the cost of a name-import transaction\n * @param {String} name - the fully-qualified name\n * @param {String} recipientAddr - the recipient\n * @param {String} zonefileHash - the zone file hash\n * @param {Number} importUtxos - the number of UTXOs we expect will\n *  be required from the importer address\n * @returns {Promise} - a promise which resolves to the satoshi cost\n *  to fund this name-import transaction\n * @private\n */\nfunction estimateNameImport(name, recipientAddr, zonefileHash, importUtxos = 1) {\n    const network = config_1.config.network;\n    const importTX = skeletons_1.makeNameImportSkeleton(name, recipientAddr, zonefileHash);\n    return network.getFeeRate()\n        .then((feeRate) => {\n        const outputsValue = utils_1.sumOutputValues(importTX);\n        const txFee = feeRate * utils_1.estimateTXBytes(importTX, importUtxos, 1);\n        return txFee + outputsValue;\n    });\n}\n/**\n * Estimates the cost of an announce transaction\n * @param {String} messageHash - the hash of the message\n * @param {Number} senderUtxos - the number of utxos we expect will\n *  be required from the importer address\n * @returns {Promise} - a promise which resolves to the satoshi cost\n *  to fund this announce transaction\n * @private\n */\nfunction estimateAnnounce(messageHash, senderUtxos = 1) {\n    const network = config_1.config.network;\n    const announceTX = skeletons_1.makeAnnounceSkeleton(messageHash);\n    return network.getFeeRate()\n        .then((feeRate) => {\n        const outputsValue = utils_1.sumOutputValues(announceTX);\n        const txFee = feeRate * utils_1.estimateTXBytes(announceTX, senderUtxos, 1);\n        return txFee + outputsValue;\n    });\n}\n/**\n * Estimates the cost of a token-transfer transaction\n * @param {String} recipientAddress - the recipient of the tokens\n * @param {String} tokenType - the type of token to spend\n * @param {Object} tokenAmount - a 64-bit unsigned BigInteger encoding the number of tokens\n *   to spend\n * @param {String} scratchArea - an arbitrary string to store with the transaction\n * @param {Number} senderUtxos - the number of utxos we expect will\n *  be required from the importer address\n * @param {Number} additionalOutputs - the number of outputs we expect to add beyond\n *  just the recipient output (default = 1, if the token owner is also the bitcoin funder)\n * @returns {Promise} - a promise which resolves to the satoshi cost to\n *  fund this token-transfer transaction\n * @private\n */\nfunction estimateTokenTransfer(recipientAddress, tokenType, tokenAmount, scratchArea, senderUtxos = 1, additionalOutputs = 1) {\n    const network = config_1.config.network;\n    const tokenTransferTX = skeletons_1.makeTokenTransferSkeleton(recipientAddress, dummyConsensusHash, tokenType, tokenAmount, scratchArea);\n    return network.getFeeRate()\n        .then((feeRate) => {\n        const outputsValue = utils_1.sumOutputValues(tokenTransferTX);\n        const txFee = feeRate * utils_1.estimateTXBytes(tokenTransferTX, senderUtxos, additionalOutputs);\n        return txFee + outputsValue;\n    });\n}\n/**\n * Generates a preorder transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to pre-order\n * @param {String} destinationAddress - the address to receive the name (this\n *    must be passed as the 'registrationAddress' in the register transaction)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the transaction or a transaction signer object\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n * indicating whether the function should attempt to return an unsigned (or not fully signed)\n * transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\nfunction makePreorder(fullyQualifiedName, destinationAddress, paymentKeyIn, buildIncomplete = false) {\n    const network = config_1.config.network;\n    const namespace = fullyQualifiedName.split('.').pop();\n    const paymentKey = getTransactionSigner(paymentKeyIn);\n    return paymentKey.getAddress().then((preorderAddress) => {\n        const preorderPromise = Promise.all([network.getConsensusHash(),\n            network.getNamePrice(fullyQualifiedName),\n            network.getNamespaceBurnAddress(namespace)])\n            .then(([consensusHash, namePrice, burnAddress]) => skeletons_1.makePreorderSkeleton(fullyQualifiedName, consensusHash, preorderAddress, burnAddress, namePrice, destinationAddress));\n        return Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate(), preorderPromise])\n            .then(([utxos, feeRate, preorderSkeleton]) => {\n            const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(preorderSkeleton, network.layer1);\n            txB.setVersion(1);\n            const changeIndex = 1; // preorder skeleton always creates a change output at index = 1\n            const signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0, changeIndex);\n            return utils_1.signInputs(signingTxB, paymentKey);\n        })\n            .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n    });\n}\n/**\n * Generates an update transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to update\n * @param {String | TransactionSigner} ownerKeyIn - a hex string of the\n *    owner key, or a transaction signer object. This will provide one\n *    UTXO input, and also recieve a dust output.\n * @param {String | TransactionSigner} paymentKeyIn - a hex string, or a\n *    transaction signer object, of the private key used to fund the\n *    transaction's txfees\n * @param {String} zonefile - the zonefile data to update (this will be hashed\n *    to include in the transaction), the zonefile itself must be published\n *    after the UPDATE propagates.\n * @param {String} valueHash - if given, this is the hash to store (instead of\n *    zonefile).  zonefile will be ignored if this is given.\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\nfunction makeUpdate(fullyQualifiedName, ownerKeyIn, paymentKeyIn, zonefile, valueHash = '', buildIncomplete = false) {\n    const network = config_1.config.network;\n    if (!valueHash && !zonefile) {\n        return Promise.reject(new Error('Need zonefile or valueHash arguments'));\n    }\n    if (valueHash.length === 0) {\n        if (!zonefile) {\n            return Promise.reject(new Error('Need zonefile or valueHash arguments'));\n        }\n        valueHash = utils_1.hash160(Buffer.from(zonefile)).toString('hex');\n    }\n    else if (valueHash.length !== 40) {\n        return Promise.reject(new Error(`Invalid valueHash ${valueHash}`));\n    }\n    const paymentKey = getTransactionSigner(paymentKeyIn);\n    const ownerKey = getTransactionSigner(ownerKeyIn);\n    return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()])\n        .then(([ownerAddress, paymentAddress]) => {\n        const txPromise = network.getConsensusHash()\n            .then(consensusHash => skeletons_1.makeUpdateSkeleton(fullyQualifiedName, consensusHash, valueHash))\n            .then((updateTX) => {\n            const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(updateTX, network.layer1);\n            txB.setVersion(1);\n            return txB;\n        });\n        return Promise.all([txPromise, network.getUTXOs(paymentAddress),\n            network.getUTXOs(ownerAddress), network.getFeeRate()])\n            .then(([txB, payerUtxos, ownerUtxos, feeRate]) => {\n            const ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);\n            const signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);\n            return utils_1.signInputs(signingTxB, paymentKey, [{ index: ownerInput.index, signer: ownerKey }]);\n        });\n    })\n        .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a register transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to register\n * @param {String} registerAddress - the address to receive the name (this\n *    must have been passed as the 'destinationAddress' in the preorder transaction)\n *    this address will receive a dust UTXO\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key (or a TransactionSigner object) used to fund the\n *    transaction (this *must* be the same as the payment address used\n *    to fund the preorder)\n * @param {String} zonefile - the zonefile data to include (this will be hashed\n *    to include in the transaction), the zonefile itself must be published\n *    after the UPDATE propagates.\n * @param {String} valueHash - the hash of the zone file data to include.\n *    It will be used instead of zonefile, if given\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\nfunction makeRegister(fullyQualifiedName, registerAddress, paymentKeyIn, zonefile = null, valueHash = null, buildIncomplete = false) {\n    const network = config_1.config.network;\n    if (!valueHash && !!zonefile) {\n        valueHash = utils_1.hash160(Buffer.from(zonefile)).toString('hex');\n    }\n    else if (!!valueHash && valueHash.length !== 40) {\n        return Promise.reject(new Error(`Invalid zonefile hash ${valueHash}`));\n    }\n    const registerSkeleton = skeletons_1.makeRegisterSkeleton(fullyQualifiedName, registerAddress, valueHash);\n    const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(registerSkeleton, network.layer1);\n    txB.setVersion(1);\n    const paymentKey = getTransactionSigner(paymentKeyIn);\n    return paymentKey.getAddress().then(paymentAddress => Promise.all([network.getUTXOs(paymentAddress), network.getFeeRate()])\n        .then(([utxos, feeRate]) => {\n        const signingTxB = fundTransaction(txB, paymentAddress, utxos, feeRate, 0);\n        return utils_1.signInputs(signingTxB, paymentKey);\n    }))\n        .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a transfer transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to transfer\n * @param {String} destinationAddress - the address to receive the name.\n *    this address will receive a dust UTXO\n * @param {String | TransactionSigner} ownerKeyIn - a hex string of\n *    the current owner's private key (or a TransactionSigner object)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the transaction (or a\n *    TransactionSigner object)\n * @param {Boolean} keepZonefile - if true, then preserve the name's zone file\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *   indicating whether the function should attempt to return an unsigned (or not fully signed)\n *   transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\nfunction makeTransfer(fullyQualifiedName, destinationAddress, ownerKeyIn, paymentKeyIn, keepZonefile = false, buildIncomplete = false) {\n    const network = config_1.config.network;\n    const paymentKey = getTransactionSigner(paymentKeyIn);\n    const ownerKey = getTransactionSigner(ownerKeyIn);\n    return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()])\n        .then(([ownerAddress, paymentAddress]) => {\n        const txPromise = network.getConsensusHash()\n            .then(consensusHash => skeletons_1.makeTransferSkeleton(fullyQualifiedName, consensusHash, destinationAddress, keepZonefile))\n            .then((transferTX) => {\n            const txB = bitcoinjs_lib_1.TransactionBuilder\n                .fromTransaction(transferTX, network.layer1);\n            txB.setVersion(1);\n            return txB;\n        });\n        return Promise.all([txPromise, network.getUTXOs(paymentAddress),\n            network.getUTXOs(ownerAddress), network.getFeeRate()])\n            .then(([txB, payerUtxos, ownerUtxos, feeRate]) => {\n            const ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);\n            const signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);\n            return utils_1.signInputs(signingTxB, paymentKey, [{ index: ownerInput.index, signer: ownerKey }]);\n        });\n    })\n        .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a revoke transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to revoke\n * @param {String | TransactionSigner} ownerKeyIn - a hex string of\n *    the current owner's private key (or a TransactionSigner object)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the transaction (or a\n *    TransactionSigner object)\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\nfunction makeRevoke(fullyQualifiedName, ownerKeyIn, paymentKeyIn, buildIncomplete = false) {\n    const network = config_1.config.network;\n    const paymentKey = getTransactionSigner(paymentKeyIn);\n    const ownerKey = getTransactionSigner(ownerKeyIn);\n    return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()])\n        .then(([ownerAddress, paymentAddress]) => {\n        const revokeTX = skeletons_1.makeRevokeSkeleton(fullyQualifiedName);\n        const txPromise = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(revokeTX, network.layer1);\n        txPromise.setVersion(1);\n        return Promise.all([txPromise, network.getUTXOs(paymentAddress),\n            network.getUTXOs(ownerAddress), network.getFeeRate()])\n            .then(([txB, payerUtxos, ownerUtxos, feeRate]) => {\n            const ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);\n            const signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);\n            return utils_1.signInputs(signingTxB, paymentKey, [{ index: ownerInput.index, signer: ownerKey }]);\n        });\n    })\n        .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a renewal transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to transfer\n * @param {String} destinationAddress - the address to receive the name after renewal\n *    this address will receive a dust UTXO\n * @param {String | TransactionSigner} ownerKeyIn - a hex string of\n *    the current owner's private key (or a TransactionSigner object)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the renewal (or a TransactionSigner\n *    object)\n * @param {String} zonefile - the zonefile data to include, if given (this will be hashed\n *    to include in the transaction), the zonefile itself must be published\n *    after the RENEWAL propagates.\n * @param {String} valueHash - the raw zone file hash to include (this will be used\n *    instead of zonefile, if given).\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\nfunction makeRenewal(fullyQualifiedName, destinationAddress, ownerKeyIn, paymentKeyIn, zonefile = null, valueHash = null, buildIncomplete = false) {\n    const network = config_1.config.network;\n    if (!valueHash && !!zonefile) {\n        valueHash = utils_1.hash160(Buffer.from(zonefile)).toString('hex');\n    }\n    const namespace = fullyQualifiedName.split('.').pop();\n    const paymentKey = getTransactionSigner(paymentKeyIn);\n    const ownerKey = getTransactionSigner(ownerKeyIn);\n    return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()])\n        .then(([ownerAddress, paymentAddress]) => {\n        const txPromise = Promise.all([network.getNamePrice(fullyQualifiedName),\n            network.getNamespaceBurnAddress(namespace)])\n            .then(([namePrice, burnAddress]) => skeletons_1.makeRenewalSkeleton(fullyQualifiedName, destinationAddress, ownerAddress, burnAddress, namePrice, valueHash))\n            .then((tx) => {\n            const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(tx, network.layer1);\n            txB.setVersion(1);\n            return txB;\n        });\n        return Promise.all([txPromise, network.getUTXOs(paymentAddress),\n            network.getUTXOs(ownerAddress), network.getFeeRate()])\n            .then(([txB, payerUtxos, ownerUtxos, feeRate]) => {\n            const ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB, false);\n            const txInner = utils_1.getTransactionInsideBuilder(txB);\n            const ownerOutput = txInner.outs[2];\n            const ownerOutputAddr = bitcoinjs_lib_1.address.fromOutputScript(ownerOutput.script, network.layer1);\n            if (ownerOutputAddr !== ownerAddress) {\n                return Promise.reject(new Error(`Original owner ${ownerAddress} should have an output at `\n                    + `index 2 in transaction was ${ownerOutputAddr}`));\n            }\n            ownerOutput.value = ownerInput.value;\n            const signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);\n            return utils_1.signInputs(signingTxB, paymentKey, [{ index: ownerInput.index, signer: ownerKey }]);\n        });\n    })\n        .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a namespace preorder transaction for a namespace\n * @param {String} namespaceID - the namespace to pre-order\n * @param {String} revealAddress - the address to receive the namespace (this\n *    must be passed as the 'revealAddress' in the namespace-reveal transaction)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the transaction (or a\n *    TransactionSigner object)\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n *\n * @ignore\n */\nfunction makeNamespacePreorder(namespaceID, revealAddress, paymentKeyIn, buildIncomplete = false) {\n    const network = config_1.config.network;\n    const paymentKey = getTransactionSigner(paymentKeyIn);\n    return paymentKey.getAddress().then((preorderAddress) => {\n        const preorderPromise = Promise.all([network.getConsensusHash(),\n            network.getNamespacePrice(namespaceID)])\n            .then(([consensusHash, namespacePrice]) => skeletons_1.makeNamespacePreorderSkeleton(namespaceID, consensusHash, preorderAddress, revealAddress, namespacePrice));\n        return Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate(), preorderPromise])\n            .then(([utxos, feeRate, preorderSkeleton]) => {\n            const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(preorderSkeleton, network.layer1);\n            txB.setVersion(1);\n            const changeIndex = 1; // preorder skeleton always creates a change output at index = 1\n            const signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0, changeIndex);\n            return utils_1.signInputs(signingTxB, paymentKey);\n        })\n            .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n    });\n}\n/**\n * Generates a namespace reveal transaction for a namespace\n * @param {BlockstackNamespace} namespace - the namespace to reveal\n * @param {String} revealAddress - the address to receive the namespace (this\n *   must be passed as the 'revealAddress' in the namespace-reveal transaction)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string (or\n *   a TransactionSigner object) of the private key used to fund the\n *   transaction\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *   indicating whether the function should attempt to return an unsigned (or not fully signed)\n *   transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *   this function *does not* perform the requisite safety checks -- please see\n *   the safety module for those.\n * @private\n */\nfunction makeNamespaceReveal(namespace, revealAddress, paymentKeyIn, buildIncomplete = false) {\n    const network = config_1.config.network;\n    if (!namespace.check()) {\n        return Promise.reject(new Error('Invalid namespace'));\n    }\n    const namespaceRevealTX = skeletons_1.makeNamespaceRevealSkeleton(namespace, revealAddress);\n    const paymentKey = getTransactionSigner(paymentKeyIn);\n    return paymentKey.getAddress().then(preorderAddress => Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate()])\n        .then(([utxos, feeRate]) => {\n        const txB = bitcoinjs_lib_1.TransactionBuilder\n            .fromTransaction(namespaceRevealTX, network.layer1);\n        txB.setVersion(1);\n        const signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0);\n        return utils_1.signInputs(signingTxB, paymentKey);\n    }))\n        .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a namespace ready transaction for a namespace\n * @param {String} namespaceID - the namespace to launch\n * @param {String | TransactionSigner} revealKeyIn - the private key\n *  of the 'revealAddress' used to reveal the namespace\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *  indicating whether the function should attempt to return an unsigned (or not fully signed)\n *  transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *  this function *does not* perform the requisite safety checks -- please see\n *  the safety module for those.\n * @private\n */\nfunction makeNamespaceReady(namespaceID, revealKeyIn, buildIncomplete = false) {\n    const network = config_1.config.network;\n    const namespaceReadyTX = skeletons_1.makeNamespaceReadySkeleton(namespaceID);\n    const revealKey = getTransactionSigner(revealKeyIn);\n    return revealKey.getAddress().then(revealAddress => Promise.all([network.getUTXOs(revealAddress), network.getFeeRate()])\n        .then(([utxos, feeRate]) => {\n        const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(namespaceReadyTX, network.layer1);\n        txB.setVersion(1);\n        const signingTxB = fundTransaction(txB, revealAddress, utxos, feeRate, 0);\n        return utils_1.signInputs(signingTxB, revealKey);\n    }))\n        .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a name import transaction for a namespace\n * @param {String} name - the name to import\n * @param {String} recipientAddr - the address to receive the name\n * @param {String} zonefileHash - the hash of the zonefile to give this name\n * @param {String | TransactionSigner} importerKeyIn - the private key\n * that pays for the import\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n * indicating whether the function should attempt to return an unsigned (or not fully signed)\n * transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n * this function does not perform the requisite safety checks -- please see\n * the safety module for those.\n * @private\n */\nfunction makeNameImport(name, recipientAddr, zonefileHash, importerKeyIn, buildIncomplete = false) {\n    const network = config_1.config.network;\n    const nameImportTX = skeletons_1.makeNameImportSkeleton(name, recipientAddr, zonefileHash);\n    const importerKey = getTransactionSigner(importerKeyIn);\n    return importerKey.getAddress().then(importerAddress => Promise.all([network.getUTXOs(importerAddress), network.getFeeRate()])\n        .then(([utxos, feeRate]) => {\n        const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(nameImportTX, network.layer1);\n        const signingTxB = fundTransaction(txB, importerAddress, utxos, feeRate, 0);\n        return utils_1.signInputs(signingTxB, importerKey);\n    }))\n        .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates an announce transaction\n * @param {String} messageHash - the hash of the message to send.  Should be\n *  an already-announced zone file hash\n * @param {String | TransactionSigner} senderKeyIn - the private key\n *  that pays for the transaction.  Should be the key that owns the\n *  name that the message recipients subscribe to\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n * indicating whether the function should attempt to return an unsigned (or not fully signed)\n * transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n * this function does not perform the requisite safety checks -- please see the\n * safety module for those.\n * @private\n */\nfunction makeAnnounce(messageHash, senderKeyIn, buildIncomplete = false) {\n    const network = config_1.config.network;\n    const announceTX = skeletons_1.makeAnnounceSkeleton(messageHash);\n    const senderKey = getTransactionSigner(senderKeyIn);\n    return senderKey.getAddress().then(senderAddress => Promise.all([network.getUTXOs(senderAddress), network.getFeeRate()])\n        .then(([utxos, feeRate]) => {\n        const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(announceTX, network.layer1);\n        const signingTxB = fundTransaction(txB, senderAddress, utxos, feeRate, 0);\n        return utils_1.signInputs(signingTxB, senderKey);\n    }))\n        .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a token-transfer transaction\n * @param {String} recipientAddress - the address to receive the tokens\n * @param {String} tokenType - the type of tokens to send\n * @param {Object} tokenAmount - the BigInteger encoding of an unsigned 64-bit number of\n *  tokens to send\n * @param {String} scratchArea - an arbitrary string to include with the transaction\n * @param {String | TransactionSigner} senderKeyIn - the hex-encoded private key to send\n *   the tokens\n * @param {String | TransactionSigner} btcFunderKeyIn - the hex-encoded private key to fund\n *   the bitcoin fees for the transaction. Optional -- if not passed, will attempt to\n *   fund with sender key.\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *   indicating whether the function should attempt to return an unsigned (or not fully signed)\n *   transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n * This function does not perform the requisite safety checks -- please see the\n * safety module for those.\n * @private\n */\nfunction makeTokenTransfer(recipientAddress, tokenType, tokenAmount, scratchArea, senderKeyIn, btcFunderKeyIn, buildIncomplete = false) {\n    const network = config_1.config.network;\n    const separateFunder = !!btcFunderKeyIn;\n    const senderKey = getTransactionSigner(senderKeyIn);\n    const btcKey = btcFunderKeyIn ? getTransactionSigner(btcFunderKeyIn) : senderKey;\n    const txPromise = network.getConsensusHash()\n        .then(consensusHash => skeletons_1.makeTokenTransferSkeleton(recipientAddress, consensusHash, tokenType, tokenAmount, scratchArea));\n    return Promise.all([senderKey.getAddress(), btcKey.getAddress()])\n        .then(([senderAddress, btcAddress]) => {\n        const btcUTXOsPromise = separateFunder\n            ? network.getUTXOs(btcAddress) : Promise.resolve([]);\n        return Promise.all([\n            network.getUTXOs(senderAddress),\n            btcUTXOsPromise,\n            network.getFeeRate(),\n            txPromise\n        ]).then(([senderUTXOs, btcUTXOs, feeRate, tokenTransferTX]) => {\n            const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(tokenTransferTX, network.layer1);\n            if (separateFunder) {\n                const payerInput = addOwnerInput(senderUTXOs, senderAddress, txB);\n                const signingTxB = fundTransaction(txB, btcAddress, btcUTXOs, feeRate, payerInput.value);\n                return utils_1.signInputs(signingTxB, btcKey, [{ index: payerInput.index, signer: senderKey }]);\n            }\n            else {\n                const signingTxB = fundTransaction(txB, senderAddress, senderUTXOs, feeRate, 0);\n                return utils_1.signInputs(signingTxB, senderKey);\n            }\n        });\n    })\n        .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a bitcoin spend to a specified address. This will fund up to `amount`\n *   of satoshis from the payer's UTXOs. It will generate a change output if and only\n *   if the amount of leftover change is *greater* than the additional fees associated\n *   with the extra output. If the requested amount is not enough to fund the transaction's\n *   associated fees, then this will reject with a InvalidAmountError\n *\n * UTXOs are selected largest to smallest, and UTXOs which cannot fund the fees associated\n *   with their own input will not be included.\n *\n * If you specify an amount > the total balance of the payer address, then this will\n *   generate a maximum spend transaction\n *\n * @param {String} destinationAddress - the address to receive the bitcoin payment\n * @param {String | TransactionSigner} paymentKeyIn - the private key\n *    used to fund the bitcoin spend\n * @param {number} amount - the amount in satoshis for the payment address to\n *    spend in this transaction\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n * indicating whether the function should attempt to return an unsigned (or not fully signed)\n * transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n * @private\n */\nfunction makeBitcoinSpend(destinationAddress, paymentKeyIn, amount, buildIncomplete = false) {\n    if (amount <= 0) {\n        return Promise.reject(new errors_1.InvalidParameterError('amount', 'amount must be greater than zero'));\n    }\n    const network = config_1.config.network;\n    const paymentKey = getTransactionSigner(paymentKeyIn);\n    return paymentKey.getAddress().then(paymentAddress => Promise.all([network.getUTXOs(paymentAddress), network.getFeeRate()])\n        .then(([utxos, feeRate]) => {\n        const txB = new bitcoinjs_lib_1.TransactionBuilder(network.layer1);\n        txB.setVersion(1);\n        const destinationIndex = txB.addOutput(destinationAddress, 0);\n        // will add utxos up to _amount_ and return the amount of leftover _change_\n        let change;\n        try {\n            change = utils_1.addUTXOsToFund(txB, utxos, amount, feeRate, false);\n        }\n        catch (err) {\n            if (err.name === 'NotEnoughFundsError') {\n                // actual amount funded = amount requested - remainder\n                amount -= err.leftToFund;\n                change = 0;\n            }\n            else {\n                throw err;\n            }\n        }\n        let feesToPay = feeRate * utils_1.estimateTXBytes(txB, 0, 0);\n        const feeForChange = feeRate * (utils_1.estimateTXBytes(txB, 0, 1)) - feesToPay;\n        // it's worthwhile to add a change output\n        if (change > feeForChange) {\n            feesToPay += feeForChange;\n            txB.addOutput(paymentAddress, change);\n        }\n        // now let's compute how much output is leftover once we pay the fees.\n        const outputAmount = amount - feesToPay;\n        if (outputAmount < utils_1.DUST_MINIMUM) {\n            throw new errors_1.InvalidAmountError(feesToPay, amount);\n        }\n        // we need to manually set the output values now\n        const txInner = utils_1.getTransactionInsideBuilder(txB);\n        const txOut = txInner.outs[destinationIndex];\n        txOut.value = outputAmount;\n        // ready to sign.\n        return utils_1.signInputs(txB, paymentKey);\n    }))\n        .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\nexports.transactions = {\n    makeRenewal,\n    makeUpdate,\n    makePreorder,\n    makeRegister,\n    makeTransfer,\n    makeRevoke,\n    makeNamespacePreorder,\n    makeNamespaceReveal,\n    makeNamespaceReady,\n    makeBitcoinSpend,\n    makeNameImport,\n    makeAnnounce,\n    makeTokenTransfer,\n    BlockstackNamespace: skeletons_1.BlockstackNamespace,\n    estimatePreorder,\n    estimateRegister,\n    estimateTransfer,\n    estimateUpdate,\n    estimateRenewal,\n    estimateRevoke,\n    estimateNamespacePreorder,\n    estimateNamespaceReveal,\n    estimateNamespaceReady,\n    estimateNameImport,\n    estimateAnnounce,\n    estimateTokenTransfer\n};\n//# sourceMappingURL=txbuild.js.map"]},"metadata":{},"sourceType":"script"}