{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/home/aashan/2048/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"/home/aashan/2048/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/home/aashan/2048/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/aashan/2048/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar bip174_1 = require('bip174');\n\nvar varuint = require('bip174/src/lib/converter/varint');\n\nvar utils_1 = require('bip174/src/lib/utils');\n\nvar address_1 = require('./address');\n\nvar bufferutils_1 = require('./bufferutils');\n\nvar crypto_1 = require('./crypto');\n\nvar ecpair_1 = require('./ecpair');\n\nvar networks_1 = require('./networks');\n\nvar payments = require('./payments');\n\nvar bscript = require('./script');\n\nvar transaction_1 = require('./transaction');\n/**\n * These are the default arguments for a Psbt instance.\n */\n\n\nvar DEFAULT_OPTS = {\n  /**\n   * A bitcoinjs Network object. This is only used if you pass an `address`\n   * parameter to addOutput. Otherwise it is not needed and can be left default.\n   */\n  network: networks_1.bitcoin,\n\n  /**\n   * When extractTransaction is called, the fee rate is checked.\n   * THIS IS NOT TO BE RELIED ON.\n   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.\n   */\n  maximumFeeRate: 5000\n};\n/**\n * Psbt class can parse and generate a PSBT binary based off of the BIP174.\n * There are 6 roles that this class fulfills. (Explained in BIP174)\n *\n * Creator: This can be done with `new Psbt()`\n * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,\n *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to\n *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,\n *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`\n *   addInput requires hash: Buffer | string; and index: number; as attributes\n *   and can also include any attributes that are used in updateInput method.\n *   addOutput requires script: Buffer; and value: number; and likewise can include\n *   data for updateOutput.\n *   For a list of what attributes should be what types. Check the bip174 library.\n *   Also, check the integration tests for some examples of usage.\n * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input\n *   information for your pubkey or pubkeyhash, and only sign inputs where it finds\n *   your info. Or you can explicitly sign a specific input with signInput and\n *   signInputAsync. For the async methods you can create a SignerAsync object\n *   and use something like a hardware wallet to sign with. (You must implement this)\n * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`\n *   the psbt calling combine will always have precedence when a conflict occurs.\n *   Combine checks if the internal bitcoin transaction is the same, so be sure that\n *   all sequences, version, locktime, etc. are the same before combining.\n * Input Finalizer: This role is fairly important. Not only does it need to construct\n *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.\n *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`\n *   Running any finalize method will delete any data in the input(s) that are no longer\n *   needed due to the finalized scripts containing the information.\n * Transaction Extractor: This role will perform some checks before returning a\n *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.\n */\n\nvar Psbt =\n/*#__PURE__*/\nfunction () {\n  function Psbt() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new bip174_1.Psbt(new PsbtTransaction());\n\n    _classCallCheck(this, Psbt);\n\n    this.data = data; // set defaults\n\n    this.opts = Object.assign({}, DEFAULT_OPTS, opts);\n    this.__CACHE = {\n      __NON_WITNESS_UTXO_TX_CACHE: [],\n      __NON_WITNESS_UTXO_BUF_CACHE: [],\n      __TX_IN_CACHE: {},\n      __TX: this.data.globalMap.unsignedTx.tx\n    };\n    if (this.data.inputs.length === 0) this.setVersion(2); // Make data hidden when enumerating\n\n    var dpew = function dpew(obj, attr, enumerable, writable) {\n      return Object.defineProperty(obj, attr, {\n        enumerable: enumerable,\n        writable: writable\n      });\n    };\n\n    dpew(this, '__CACHE', false, true);\n    dpew(this, 'opts', false, true);\n  }\n\n  _createClass(Psbt, [{\n    key: \"combine\",\n    value: function combine() {\n      var _this$data;\n\n      for (var _len = arguments.length, those = new Array(_len), _key = 0; _key < _len; _key++) {\n        those[_key] = arguments[_key];\n      }\n\n      (_this$data = this.data).combine.apply(_this$data, _toConsumableArray(those.map(function (o) {\n        return o.data;\n      })));\n\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      // TODO: more efficient cloning\n      var res = Psbt.fromBuffer(this.data.toBuffer());\n      res.opts = JSON.parse(JSON.stringify(this.opts));\n      return res;\n    }\n  }, {\n    key: \"setMaximumFeeRate\",\n    value: function setMaximumFeeRate(satoshiPerByte) {\n      check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw\n\n      this.opts.maximumFeeRate = satoshiPerByte;\n    }\n  }, {\n    key: \"setVersion\",\n    value: function setVersion(version) {\n      check32Bit(version);\n      checkInputsForPartialSig(this.data.inputs, 'setVersion');\n      var c = this.__CACHE;\n      c.__TX.version = version;\n      c.__EXTRACTED_TX = undefined;\n      return this;\n    }\n  }, {\n    key: \"setLocktime\",\n    value: function setLocktime(locktime) {\n      check32Bit(locktime);\n      checkInputsForPartialSig(this.data.inputs, 'setLocktime');\n      var c = this.__CACHE;\n      c.__TX.locktime = locktime;\n      c.__EXTRACTED_TX = undefined;\n      return this;\n    }\n  }, {\n    key: \"setInputSequence\",\n    value: function setInputSequence(inputIndex, sequence) {\n      check32Bit(sequence);\n      checkInputsForPartialSig(this.data.inputs, 'setInputSequence');\n      var c = this.__CACHE;\n\n      if (c.__TX.ins.length <= inputIndex) {\n        throw new Error('Input index too high');\n      }\n\n      c.__TX.ins[inputIndex].sequence = sequence;\n      c.__EXTRACTED_TX = undefined;\n      return this;\n    }\n  }, {\n    key: \"addInputs\",\n    value: function addInputs(inputDatas) {\n      var _this = this;\n\n      inputDatas.forEach(function (inputData) {\n        return _this.addInput(inputData);\n      });\n      return this;\n    }\n  }, {\n    key: \"addInput\",\n    value: function addInput(inputData) {\n      if (arguments.length > 1 || !inputData || inputData.hash === undefined || inputData.index === undefined) {\n        throw new Error(\"Invalid arguments for Psbt.addInput. \" + \"Requires single object with at least [hash] and [index]\");\n      }\n\n      checkInputsForPartialSig(this.data.inputs, 'addInput');\n      var c = this.__CACHE;\n      this.data.addInput(inputData);\n      var txIn = c.__TX.ins[c.__TX.ins.length - 1];\n      checkTxInputCache(c, txIn);\n      var inputIndex = this.data.inputs.length - 1;\n      var input = this.data.inputs[inputIndex];\n\n      if (input.nonWitnessUtxo) {\n        addNonWitnessTxCache(this.__CACHE, input, inputIndex);\n      }\n\n      c.__FEE = undefined;\n      c.__FEE_RATE = undefined;\n      c.__EXTRACTED_TX = undefined;\n      return this;\n    }\n  }, {\n    key: \"addOutputs\",\n    value: function addOutputs(outputDatas) {\n      var _this2 = this;\n\n      outputDatas.forEach(function (outputData) {\n        return _this2.addOutput(outputData);\n      });\n      return this;\n    }\n  }, {\n    key: \"addOutput\",\n    value: function addOutput(outputData) {\n      if (arguments.length > 1 || !outputData || outputData.value === undefined || outputData.address === undefined && outputData.script === undefined) {\n        throw new Error(\"Invalid arguments for Psbt.addOutput. \" + \"Requires single object with at least [script or address] and [value]\");\n      }\n\n      checkInputsForPartialSig(this.data.inputs, 'addOutput');\n      var _outputData = outputData,\n          address = _outputData.address;\n\n      if (typeof address === 'string') {\n        var network = this.opts.network;\n        var script = address_1.toOutputScript(address, network);\n        outputData = Object.assign(outputData, {\n          script: script\n        });\n      }\n\n      var c = this.__CACHE;\n      this.data.addOutput(outputData);\n      c.__FEE = undefined;\n      c.__FEE_RATE = undefined;\n      c.__EXTRACTED_TX = undefined;\n      return this;\n    }\n  }, {\n    key: \"extractTransaction\",\n    value: function extractTransaction(disableFeeCheck) {\n      if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');\n      var c = this.__CACHE;\n\n      if (!disableFeeCheck) {\n        checkFees(this, c, this.opts);\n      }\n\n      if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;\n\n      var tx = c.__TX.clone();\n\n      inputFinalizeGetAmts(this.data.inputs, tx, c, true);\n      return tx;\n    }\n  }, {\n    key: \"getFeeRate\",\n    value: function getFeeRate() {\n      return getTxCacheValue('__FEE_RATE', 'fee rate', this.data.inputs, this.__CACHE);\n    }\n  }, {\n    key: \"getFee\",\n    value: function getFee() {\n      return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);\n    }\n  }, {\n    key: \"finalizeAllInputs\",\n    value: function finalizeAllInputs() {\n      var _this3 = this;\n\n      utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one\n\n      range(this.data.inputs.length).forEach(function (idx) {\n        return _this3.finalizeInput(idx);\n      });\n      return this;\n    }\n  }, {\n    key: \"finalizeInput\",\n    value: function finalizeInput(inputIndex) {\n      var finalScriptsFunc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getFinalScripts;\n      var input = utils_1.checkForInput(this.data.inputs, inputIndex);\n\n      var _getScriptFromInput = getScriptFromInput(inputIndex, input, this.__CACHE),\n          script = _getScriptFromInput.script,\n          isP2SH = _getScriptFromInput.isP2SH,\n          isP2WSH = _getScriptFromInput.isP2WSH,\n          isSegwit = _getScriptFromInput.isSegwit;\n\n      if (!script) throw new Error(\"No script found for input #\".concat(inputIndex));\n      checkPartialSigSighashes(input);\n\n      var _finalScriptsFunc = finalScriptsFunc(inputIndex, input, script, isSegwit, isP2SH, isP2WSH),\n          finalScriptSig = _finalScriptsFunc.finalScriptSig,\n          finalScriptWitness = _finalScriptsFunc.finalScriptWitness;\n\n      if (finalScriptSig) this.data.updateInput(inputIndex, {\n        finalScriptSig: finalScriptSig\n      });\n      if (finalScriptWitness) this.data.updateInput(inputIndex, {\n        finalScriptWitness: finalScriptWitness\n      });\n      if (!finalScriptSig && !finalScriptWitness) throw new Error(\"Unknown error finalizing input #\".concat(inputIndex));\n      this.data.clearFinalizedInput(inputIndex);\n      return this;\n    }\n  }, {\n    key: \"validateSignaturesOfAllInputs\",\n    value: function validateSignaturesOfAllInputs() {\n      var _this4 = this;\n\n      utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one\n\n      var results = range(this.data.inputs.length).map(function (idx) {\n        return _this4.validateSignaturesOfInput(idx);\n      });\n      return results.reduce(function (final, res) {\n        return res === true && final;\n      }, true);\n    }\n  }, {\n    key: \"validateSignaturesOfInput\",\n    value: function validateSignaturesOfInput(inputIndex, pubkey) {\n      var input = this.data.inputs[inputIndex];\n      var partialSig = (input || {}).partialSig;\n      if (!input || !partialSig || partialSig.length < 1) throw new Error('No signatures to validate');\n      var mySigs = pubkey ? partialSig.filter(function (sig) {\n        return sig.pubkey.equals(pubkey);\n      }) : partialSig;\n      if (mySigs.length < 1) throw new Error('No signatures for this pubkey');\n      var results = [];\n      var hashCache;\n      var scriptCache;\n      var sighashCache;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = mySigs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var pSig = _step.value;\n          var sig = bscript.signature.decode(pSig.signature);\n\n          var _ref = sighashCache !== sig.hashType ? getHashForSig(inputIndex, Object.assign({}, input, {\n            sighashType: sig.hashType\n          }), this.__CACHE) : {\n            hash: hashCache,\n            script: scriptCache\n          },\n              hash = _ref.hash,\n              script = _ref.script;\n\n          sighashCache = sig.hashType;\n          hashCache = hash;\n          scriptCache = script;\n          checkScriptForPubkey(pSig.pubkey, script, 'verify');\n          var keypair = ecpair_1.fromPublicKey(pSig.pubkey);\n          results.push(keypair.verify(hash, sig.signature));\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return results.every(function (res) {\n        return res === true;\n      });\n    }\n  }, {\n    key: \"signAllInputsHD\",\n    value: function signAllInputsHD(hdKeyPair) {\n      var sighashTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [transaction_1.Transaction.SIGHASH_ALL];\n\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        throw new Error('Need HDSigner to sign input');\n      }\n\n      var results = [];\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = range(this.data.inputs.length)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var i = _step2.value;\n\n          try {\n            this.signInputHD(i, hdKeyPair, sighashTypes);\n            results.push(true);\n          } catch (err) {\n            results.push(false);\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      if (results.every(function (v) {\n        return v === false;\n      })) {\n        throw new Error('No inputs were signed');\n      }\n\n      return this;\n    }\n  }, {\n    key: \"signAllInputsHDAsync\",\n    value: function signAllInputsHDAsync(hdKeyPair) {\n      var _this5 = this;\n\n      var sighashTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [transaction_1.Transaction.SIGHASH_ALL];\n      return new Promise(function (resolve, reject) {\n        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n          return reject(new Error('Need HDSigner to sign input'));\n        }\n\n        var results = [];\n        var promises = [];\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = range(_this5.data.inputs.length)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var i = _step3.value;\n            promises.push(_this5.signInputHDAsync(i, hdKeyPair, sighashTypes).then(function () {\n              results.push(true);\n            }, function () {\n              results.push(false);\n            }));\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        return Promise.all(promises).then(function () {\n          if (results.every(function (v) {\n            return v === false;\n          })) {\n            return reject(new Error('No inputs were signed'));\n          }\n\n          resolve();\n        });\n      });\n    }\n  }, {\n    key: \"signInputHD\",\n    value: function signInputHD(inputIndex, hdKeyPair) {\n      var _this6 = this;\n\n      var sighashTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [transaction_1.Transaction.SIGHASH_ALL];\n\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        throw new Error('Need HDSigner to sign input');\n      }\n\n      var signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n      signers.forEach(function (signer) {\n        return _this6.signInput(inputIndex, signer, sighashTypes);\n      });\n      return this;\n    }\n  }, {\n    key: \"signInputHDAsync\",\n    value: function signInputHDAsync(inputIndex, hdKeyPair) {\n      var _this7 = this;\n\n      var sighashTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [transaction_1.Transaction.SIGHASH_ALL];\n      return new Promise(function (resolve, reject) {\n        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n          return reject(new Error('Need HDSigner to sign input'));\n        }\n\n        var signers = getSignersFromHD(inputIndex, _this7.data.inputs, hdKeyPair);\n        var promises = signers.map(function (signer) {\n          return _this7.signInputAsync(inputIndex, signer, sighashTypes);\n        });\n        return Promise.all(promises).then(function () {\n          resolve();\n        }).catch(reject);\n      });\n    }\n  }, {\n    key: \"signAllInputs\",\n    value: function signAllInputs(keyPair) {\n      var sighashTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [transaction_1.Transaction.SIGHASH_ALL];\n      if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input'); // TODO: Add a pubkey/pubkeyhash cache to each input\n      // as input information is added, then eventually\n      // optimize this method.\n\n      var results = [];\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = range(this.data.inputs.length)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var i = _step4.value;\n\n          try {\n            this.signInput(i, keyPair, sighashTypes);\n            results.push(true);\n          } catch (err) {\n            results.push(false);\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      if (results.every(function (v) {\n        return v === false;\n      })) {\n        throw new Error('No inputs were signed');\n      }\n\n      return this;\n    }\n  }, {\n    key: \"signAllInputsAsync\",\n    value: function signAllInputsAsync(keyPair) {\n      var _this8 = this;\n\n      var sighashTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [transaction_1.Transaction.SIGHASH_ALL];\n      return new Promise(function (resolve, reject) {\n        if (!keyPair || !keyPair.publicKey) return reject(new Error('Need Signer to sign input')); // TODO: Add a pubkey/pubkeyhash cache to each input\n        // as input information is added, then eventually\n        // optimize this method.\n\n        var results = [];\n        var promises = [];\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = _this8.data.inputs.entries()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var _ref4 = _step5.value;\n\n            var _ref3 = _slicedToArray(_ref4, 1);\n\n            var i = _ref3[0];\n            promises.push(_this8.signInputAsync(i, keyPair, sighashTypes).then(function () {\n              results.push(true);\n            }, function () {\n              results.push(false);\n            }));\n          }\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n\n        return Promise.all(promises).then(function () {\n          if (results.every(function (v) {\n            return v === false;\n          })) {\n            return reject(new Error('No inputs were signed'));\n          }\n\n          resolve();\n        });\n      });\n    }\n  }, {\n    key: \"signInput\",\n    value: function signInput(inputIndex, keyPair) {\n      var sighashTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [transaction_1.Transaction.SIGHASH_ALL];\n      if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input');\n\n      var _getHashAndSighashTyp = getHashAndSighashType(this.data.inputs, inputIndex, keyPair.publicKey, this.__CACHE, sighashTypes),\n          hash = _getHashAndSighashTyp.hash,\n          sighashType = _getHashAndSighashTyp.sighashType;\n\n      var partialSig = [{\n        pubkey: keyPair.publicKey,\n        signature: bscript.signature.encode(keyPair.sign(hash), sighashType)\n      }];\n      this.data.updateInput(inputIndex, {\n        partialSig: partialSig\n      });\n      return this;\n    }\n  }, {\n    key: \"signInputAsync\",\n    value: function signInputAsync(inputIndex, keyPair) {\n      var _this9 = this;\n\n      var sighashTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [transaction_1.Transaction.SIGHASH_ALL];\n      return new Promise(function (resolve, reject) {\n        if (!keyPair || !keyPair.publicKey) return reject(new Error('Need Signer to sign input'));\n\n        var _getHashAndSighashTyp2 = getHashAndSighashType(_this9.data.inputs, inputIndex, keyPair.publicKey, _this9.__CACHE, sighashTypes),\n            hash = _getHashAndSighashTyp2.hash,\n            sighashType = _getHashAndSighashTyp2.sighashType;\n\n        Promise.resolve(keyPair.sign(hash)).then(function (signature) {\n          var partialSig = [{\n            pubkey: keyPair.publicKey,\n            signature: bscript.signature.encode(signature, sighashType)\n          }];\n\n          _this9.data.updateInput(inputIndex, {\n            partialSig: partialSig\n          });\n\n          resolve();\n        });\n      });\n    }\n  }, {\n    key: \"toBuffer\",\n    value: function toBuffer() {\n      return this.data.toBuffer();\n    }\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      return this.data.toHex();\n    }\n  }, {\n    key: \"toBase64\",\n    value: function toBase64() {\n      return this.data.toBase64();\n    }\n  }, {\n    key: \"updateGlobal\",\n    value: function updateGlobal(updateData) {\n      this.data.updateGlobal(updateData);\n      return this;\n    }\n  }, {\n    key: \"updateInput\",\n    value: function updateInput(inputIndex, updateData) {\n      this.data.updateInput(inputIndex, updateData);\n\n      if (updateData.nonWitnessUtxo) {\n        addNonWitnessTxCache(this.__CACHE, this.data.inputs[inputIndex], inputIndex);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"updateOutput\",\n    value: function updateOutput(outputIndex, updateData) {\n      this.data.updateOutput(outputIndex, updateData);\n      return this;\n    }\n  }, {\n    key: \"addUnknownKeyValToGlobal\",\n    value: function addUnknownKeyValToGlobal(keyVal) {\n      this.data.addUnknownKeyValToGlobal(keyVal);\n      return this;\n    }\n  }, {\n    key: \"addUnknownKeyValToInput\",\n    value: function addUnknownKeyValToInput(inputIndex, keyVal) {\n      this.data.addUnknownKeyValToInput(inputIndex, keyVal);\n      return this;\n    }\n  }, {\n    key: \"addUnknownKeyValToOutput\",\n    value: function addUnknownKeyValToOutput(outputIndex, keyVal) {\n      this.data.addUnknownKeyValToOutput(outputIndex, keyVal);\n      return this;\n    }\n  }, {\n    key: \"clearFinalizedInput\",\n    value: function clearFinalizedInput(inputIndex) {\n      this.data.clearFinalizedInput(inputIndex);\n      return this;\n    }\n  }, {\n    key: \"inputCount\",\n    get: function get() {\n      return this.data.inputs.length;\n    }\n  }], [{\n    key: \"fromBase64\",\n    value: function fromBase64(data) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var buffer = Buffer.from(data, 'base64');\n      return this.fromBuffer(buffer, opts);\n    }\n  }, {\n    key: \"fromHex\",\n    value: function fromHex(data) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var buffer = Buffer.from(data, 'hex');\n      return this.fromBuffer(buffer, opts);\n    }\n  }, {\n    key: \"fromBuffer\",\n    value: function fromBuffer(buffer) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);\n      var psbt = new Psbt(opts, psbtBase);\n      checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);\n      return psbt;\n    }\n  }]);\n\n  return Psbt;\n}();\n\nexports.Psbt = Psbt;\n/**\n * This function is needed to pass to the bip174 base class's fromBuffer.\n * It takes the \"transaction buffer\" portion of the psbt buffer and returns a\n * Transaction (From the bip174 library) interface.\n */\n\nvar transactionFromBuffer = function transactionFromBuffer(buffer) {\n  return new PsbtTransaction(buffer);\n};\n/**\n * This class implements the Transaction interface from bip174 library.\n * It contains a bitcoinjs-lib Transaction object.\n */\n\n\nvar PsbtTransaction =\n/*#__PURE__*/\nfunction () {\n  function PsbtTransaction() {\n    var buffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n\n    _classCallCheck(this, PsbtTransaction);\n\n    this.tx = transaction_1.Transaction.fromBuffer(buffer);\n    checkTxEmpty(this.tx);\n    Object.defineProperty(this, 'tx', {\n      enumerable: false,\n      writable: true\n    });\n  }\n\n  _createClass(PsbtTransaction, [{\n    key: \"getInputOutputCounts\",\n    value: function getInputOutputCounts() {\n      return {\n        inputCount: this.tx.ins.length,\n        outputCount: this.tx.outs.length\n      };\n    }\n  }, {\n    key: \"addInput\",\n    value: function addInput(input) {\n      if (input.hash === undefined || input.index === undefined || !Buffer.isBuffer(input.hash) && typeof input.hash !== 'string' || typeof input.index !== 'number') {\n        throw new Error('Error adding input.');\n      }\n\n      var hash = typeof input.hash === 'string' ? bufferutils_1.reverseBuffer(Buffer.from(input.hash, 'hex')) : input.hash;\n      this.tx.addInput(hash, input.index, input.sequence);\n    }\n  }, {\n    key: \"addOutput\",\n    value: function addOutput(output) {\n      if (output.script === undefined || output.value === undefined || !Buffer.isBuffer(output.script) || typeof output.value !== 'number') {\n        throw new Error('Error adding output.');\n      }\n\n      this.tx.addOutput(output.script, output.value);\n    }\n  }, {\n    key: \"toBuffer\",\n    value: function toBuffer() {\n      return this.tx.toBuffer();\n    }\n  }]);\n\n  return PsbtTransaction;\n}();\n\nfunction canFinalize(input, script, scriptType) {\n  switch (scriptType) {\n    case 'pubkey':\n    case 'pubkeyhash':\n    case 'witnesspubkeyhash':\n      return hasSigs(1, input.partialSig);\n\n    case 'multisig':\n      var p2ms = payments.p2ms({\n        output: script\n      });\n      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);\n\n    default:\n      return false;\n  }\n}\n\nfunction hasSigs(neededSigs, partialSig, pubkeys) {\n  if (!partialSig) return false;\n  var sigs;\n\n  if (pubkeys) {\n    sigs = pubkeys.map(function (pkey) {\n      var pubkey = ecpair_1.fromPublicKey(pkey, {\n        compressed: true\n      }).publicKey;\n      return partialSig.find(function (pSig) {\n        return pSig.pubkey.equals(pubkey);\n      });\n    }).filter(function (v) {\n      return !!v;\n    });\n  } else {\n    sigs = partialSig;\n  }\n\n  if (sigs.length > neededSigs) throw new Error('Too many signatures');\n  return sigs.length === neededSigs;\n}\n\nfunction isFinalized(input) {\n  return !!input.finalScriptSig || !!input.finalScriptWitness;\n}\n\nfunction isPaymentFactory(payment) {\n  return function (script) {\n    try {\n      payment({\n        output: script\n      });\n      return true;\n    } catch (err) {\n      return false;\n    }\n  };\n}\n\nvar isP2MS = isPaymentFactory(payments.p2ms);\nvar isP2PK = isPaymentFactory(payments.p2pk);\nvar isP2PKH = isPaymentFactory(payments.p2pkh);\nvar isP2WPKH = isPaymentFactory(payments.p2wpkh);\nvar isP2WSHScript = isPaymentFactory(payments.p2wsh);\n\nfunction check32Bit(num) {\n  if (typeof num !== 'number' || num !== Math.floor(num) || num > 0xffffffff || num < 0) {\n    throw new Error('Invalid 32 bit integer');\n  }\n}\n\nfunction checkFees(psbt, cache, opts) {\n  var feeRate = cache.__FEE_RATE || psbt.getFeeRate();\n\n  var vsize = cache.__EXTRACTED_TX.virtualSize();\n\n  var satoshis = feeRate * vsize;\n\n  if (feeRate >= opts.maximumFeeRate) {\n    throw new Error(\"Warning: You are paying around \".concat((satoshis / 1e8).toFixed(8), \" in \") + \"fees, which is \".concat(feeRate, \" satoshi per byte for a transaction \") + \"with a VSize of \".concat(vsize, \" bytes (segwit counted as 0.25 byte per \") + \"byte). Use setMaximumFeeRate method to raise your threshold, or \" + \"pass true to the first arg of extractTransaction.\");\n  }\n}\n\nfunction checkInputsForPartialSig(inputs, action) {\n  inputs.forEach(function (input) {\n    var throws = false;\n    var pSigs = [];\n\n    if ((input.partialSig || []).length === 0) {\n      if (!input.finalScriptSig && !input.finalScriptWitness) return;\n      pSigs = getPsigsFromInputFinalScripts(input);\n    } else {\n      pSigs = input.partialSig;\n    }\n\n    pSigs.forEach(function (pSig) {\n      var _bscript$signature$de = bscript.signature.decode(pSig.signature),\n          hashType = _bscript$signature$de.hashType;\n\n      var whitelist = [];\n      var isAnyoneCanPay = hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;\n      if (isAnyoneCanPay) whitelist.push('addInput');\n      var hashMod = hashType & 0x1f;\n\n      switch (hashMod) {\n        case transaction_1.Transaction.SIGHASH_ALL:\n          break;\n\n        case transaction_1.Transaction.SIGHASH_SINGLE:\n        case transaction_1.Transaction.SIGHASH_NONE:\n          whitelist.push('addOutput');\n          whitelist.push('setInputSequence');\n          break;\n      }\n\n      if (whitelist.indexOf(action) === -1) {\n        throws = true;\n      }\n    });\n\n    if (throws) {\n      throw new Error('Can not modify transaction, signatures exist.');\n    }\n  });\n}\n\nfunction checkPartialSigSighashes(input) {\n  if (!input.sighashType || !input.partialSig) return;\n  var partialSig = input.partialSig,\n      sighashType = input.sighashType;\n  partialSig.forEach(function (pSig) {\n    var _bscript$signature$de2 = bscript.signature.decode(pSig.signature),\n        hashType = _bscript$signature$de2.hashType;\n\n    if (sighashType !== hashType) {\n      throw new Error('Signature sighash does not match input sighash type');\n    }\n  });\n}\n\nfunction checkScriptForPubkey(pubkey, script, action) {\n  var pubkeyHash = crypto_1.hash160(pubkey);\n  var decompiled = bscript.decompile(script);\n  if (decompiled === null) throw new Error('Unknown script error');\n  var hasKey = decompiled.some(function (element) {\n    if (typeof element === 'number') return false;\n    return element.equals(pubkey) || element.equals(pubkeyHash);\n  });\n\n  if (!hasKey) {\n    throw new Error(\"Can not \".concat(action, \" for this input with the key \").concat(pubkey.toString('hex')));\n  }\n}\n\nfunction checkTxEmpty(tx) {\n  var isEmpty = tx.ins.every(function (input) {\n    return input.script && input.script.length === 0 && input.witness && input.witness.length === 0;\n  });\n\n  if (!isEmpty) {\n    throw new Error('Format Error: Transaction ScriptSigs are not empty');\n  }\n}\n\nfunction checkTxForDupeIns(tx, cache) {\n  tx.ins.forEach(function (input) {\n    checkTxInputCache(cache, input);\n  });\n}\n\nfunction checkTxInputCache(cache, input) {\n  var key = bufferutils_1.reverseBuffer(Buffer.from(input.hash)).toString('hex') + ':' + input.index;\n  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');\n  cache.__TX_IN_CACHE[key] = 1;\n}\n\nfunction scriptCheckerFactory(payment, paymentScriptName) {\n  return function (inputIndex, scriptPubKey, redeemScript) {\n    var redeemScriptOutput = payment({\n      redeem: {\n        output: redeemScript\n      }\n    }).output;\n\n    if (!scriptPubKey.equals(redeemScriptOutput)) {\n      throw new Error(\"\".concat(paymentScriptName, \" for input #\").concat(inputIndex, \" doesn't match the scriptPubKey in the prevout\"));\n    }\n  };\n}\n\nvar checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');\nvar checkWitnessScript = scriptCheckerFactory(payments.p2wsh, 'Witness script');\n\nfunction getTxCacheValue(key, name, inputs, c) {\n  if (!inputs.every(isFinalized)) throw new Error(\"PSBT must be finalized to calculate \".concat(name));\n  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;\n  if (key === '__FEE' && c.__FEE) return c.__FEE;\n  var tx;\n  var mustFinalize = true;\n\n  if (c.__EXTRACTED_TX) {\n    tx = c.__EXTRACTED_TX;\n    mustFinalize = false;\n  } else {\n    tx = c.__TX.clone();\n  }\n\n  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);\n  if (key === '__FEE_RATE') return c.__FEE_RATE;else if (key === '__FEE') return c.__FEE;\n}\n\nfunction getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {\n  var scriptType = classifyScript(script);\n  if (!canFinalize(input, script, scriptType)) throw new Error(\"Can not finalize input #\".concat(inputIndex));\n  return prepareFinalScripts(script, scriptType, input.partialSig, isSegwit, isP2SH, isP2WSH);\n}\n\nfunction prepareFinalScripts(script, scriptType, partialSig, isSegwit, isP2SH, isP2WSH) {\n  var finalScriptSig;\n  var finalScriptWitness; // Wow, the payments API is very handy\n\n  var payment = getPayment(script, scriptType, partialSig);\n  var p2wsh = !isP2WSH ? null : payments.p2wsh({\n    redeem: payment\n  });\n  var p2sh = !isP2SH ? null : payments.p2sh({\n    redeem: p2wsh || payment\n  });\n\n  if (isSegwit) {\n    if (p2wsh) {\n      finalScriptWitness = witnessStackToScriptWitness(p2wsh.witness);\n    } else {\n      finalScriptWitness = witnessStackToScriptWitness(payment.witness);\n    }\n\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    }\n  } else {\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    } else {\n      finalScriptSig = payment.input;\n    }\n  }\n\n  return {\n    finalScriptSig: finalScriptSig,\n    finalScriptWitness: finalScriptWitness\n  };\n}\n\nfunction getHashAndSighashType(inputs, inputIndex, pubkey, cache, sighashTypes) {\n  var input = utils_1.checkForInput(inputs, inputIndex);\n\n  var _getHashForSig = getHashForSig(inputIndex, input, cache, sighashTypes),\n      hash = _getHashForSig.hash,\n      sighashType = _getHashForSig.sighashType,\n      script = _getHashForSig.script;\n\n  checkScriptForPubkey(pubkey, script, 'sign');\n  return {\n    hash: hash,\n    sighashType: sighashType\n  };\n}\n\nfunction getHashForSig(inputIndex, input, cache, sighashTypes) {\n  var unsignedTx = cache.__TX;\n  var sighashType = input.sighashType || transaction_1.Transaction.SIGHASH_ALL;\n\n  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {\n    var str = sighashTypeToString(sighashType);\n    throw new Error(\"Sighash type is not allowed. Retry the sign method passing the \" + \"sighashTypes array of whitelisted types. Sighash type: \".concat(str));\n  }\n\n  var hash;\n  var script;\n\n  if (input.nonWitnessUtxo) {\n    var nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);\n    var prevoutHash = unsignedTx.ins[inputIndex].hash;\n    var utxoHash = nonWitnessUtxoTx.getHash(); // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout\n\n    if (!prevoutHash.equals(utxoHash)) {\n      throw new Error(\"Non-witness UTXO hash for input #\".concat(inputIndex, \" doesn't match the hash specified in the prevout\"));\n    }\n\n    var prevoutIndex = unsignedTx.ins[inputIndex].index;\n    var prevout = nonWitnessUtxoTx.outs[prevoutIndex];\n\n    if (input.redeemScript) {\n      // If a redeemScript is provided, the scriptPubKey must be for that redeemScript\n      checkRedeemScript(inputIndex, prevout.script, input.redeemScript);\n      script = input.redeemScript;\n    } else {\n      script = prevout.script;\n    }\n\n    if (isP2WSHScript(script)) {\n      if (!input.witnessScript) throw new Error('Segwit input needs witnessScript if not P2WPKH');\n      checkWitnessScript(inputIndex, script, input.witnessScript);\n      hash = unsignedTx.hashForWitnessV0(inputIndex, input.witnessScript, prevout.value, sighashType);\n      script = input.witnessScript;\n    } else if (isP2WPKH(script)) {\n      // P2WPKH uses the P2PKH template for prevoutScript when signing\n      var signingScript = payments.p2pkh({\n        hash: script.slice(2)\n      }).output;\n      hash = unsignedTx.hashForWitnessV0(inputIndex, signingScript, prevout.value, sighashType);\n    } else {\n      hash = unsignedTx.hashForSignature(inputIndex, script, sighashType);\n    }\n  } else if (input.witnessUtxo) {\n    var _script; // so we don't shadow the `let script` above\n\n\n    if (input.redeemScript) {\n      // If a redeemScript is provided, the scriptPubKey must be for that redeemScript\n      checkRedeemScript(inputIndex, input.witnessUtxo.script, input.redeemScript);\n      _script = input.redeemScript;\n    } else {\n      _script = input.witnessUtxo.script;\n    }\n\n    if (isP2WPKH(_script)) {\n      // P2WPKH uses the P2PKH template for prevoutScript when signing\n      var _signingScript = payments.p2pkh({\n        hash: _script.slice(2)\n      }).output;\n      hash = unsignedTx.hashForWitnessV0(inputIndex, _signingScript, input.witnessUtxo.value, sighashType);\n      script = _script;\n    } else if (isP2WSHScript(_script)) {\n      if (!input.witnessScript) throw new Error('Segwit input needs witnessScript if not P2WPKH');\n      checkWitnessScript(inputIndex, _script, input.witnessScript);\n      hash = unsignedTx.hashForWitnessV0(inputIndex, input.witnessScript, input.witnessUtxo.value, sighashType); // want to make sure the script we return is the actual meaningful script\n\n      script = input.witnessScript;\n    } else {\n      throw new Error(\"Input #\".concat(inputIndex, \" has witnessUtxo but non-segwit script: \") + \"\".concat(_script.toString('hex')));\n    }\n  } else {\n    throw new Error('Need a Utxo input item for signing');\n  }\n\n  return {\n    script: script,\n    sighashType: sighashType,\n    hash: hash\n  };\n}\n\nfunction getPayment(script, scriptType, partialSig) {\n  var payment;\n\n  switch (scriptType) {\n    case 'multisig':\n      var sigs = getSortedSigs(script, partialSig);\n      payment = payments.p2ms({\n        output: script,\n        signatures: sigs\n      });\n      break;\n\n    case 'pubkey':\n      payment = payments.p2pk({\n        output: script,\n        signature: partialSig[0].signature\n      });\n      break;\n\n    case 'pubkeyhash':\n      payment = payments.p2pkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature\n      });\n      break;\n\n    case 'witnesspubkeyhash':\n      payment = payments.p2wpkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature\n      });\n      break;\n  }\n\n  return payment;\n}\n\nfunction getPsigsFromInputFinalScripts(input) {\n  var scriptItems = !input.finalScriptSig ? [] : bscript.decompile(input.finalScriptSig) || [];\n  var witnessItems = !input.finalScriptWitness ? [] : bscript.decompile(input.finalScriptWitness) || [];\n  return scriptItems.concat(witnessItems).filter(function (item) {\n    return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);\n  }).map(function (sig) {\n    return {\n      signature: sig\n    };\n  });\n}\n\nfunction getScriptFromInput(inputIndex, input, cache) {\n  var unsignedTx = cache.__TX;\n  var res = {\n    script: null,\n    isSegwit: false,\n    isP2SH: false,\n    isP2WSH: false\n  };\n  res.isP2SH = !!input.redeemScript;\n  res.isP2WSH = !!input.witnessScript;\n\n  if (input.witnessScript) {\n    res.script = input.witnessScript;\n  } else if (input.redeemScript) {\n    res.script = input.redeemScript;\n  } else {\n    if (input.nonWitnessUtxo) {\n      var nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);\n      var prevoutIndex = unsignedTx.ins[inputIndex].index;\n      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;\n    } else if (input.witnessUtxo) {\n      res.script = input.witnessUtxo.script;\n    }\n  }\n\n  if (input.witnessScript || isP2WPKH(res.script)) {\n    res.isSegwit = true;\n  }\n\n  return res;\n}\n\nfunction getSignersFromHD(inputIndex, inputs, hdKeyPair) {\n  var input = utils_1.checkForInput(inputs, inputIndex);\n\n  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {\n    throw new Error('Need bip32Derivation to sign with HD');\n  }\n\n  var myDerivations = input.bip32Derivation.map(function (bipDv) {\n    if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {\n      return bipDv;\n    } else {\n      return;\n    }\n  }).filter(function (v) {\n    return !!v;\n  });\n\n  if (myDerivations.length === 0) {\n    throw new Error('Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint');\n  }\n\n  var signers = myDerivations.map(function (bipDv) {\n    var node = hdKeyPair.derivePath(bipDv.path);\n\n    if (!bipDv.pubkey.equals(node.publicKey)) {\n      throw new Error('pubkey did not match bip32Derivation');\n    }\n\n    return node;\n  });\n  return signers;\n}\n\nfunction getSortedSigs(script, partialSig) {\n  var p2ms = payments.p2ms({\n    output: script\n  }); // for each pubkey in order of p2ms script\n\n  return p2ms.pubkeys.map(function (pk) {\n    // filter partialSig array by pubkey being equal\n    return (partialSig.filter(function (ps) {\n      return ps.pubkey.equals(pk);\n    })[0] || {}).signature; // Any pubkey without a match will return undefined\n    // this last filter removes all the undefined items in the array.\n  }).filter(function (v) {\n    return !!v;\n  });\n}\n\nfunction scriptWitnessToWitnessStack(buffer) {\n  var offset = 0;\n\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n\n  function readVarInt() {\n    var vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n\n  function readVector() {\n    var count = readVarInt();\n    var vector = [];\n\n    for (var i = 0; i < count; i++) {\n      vector.push(readVarSlice());\n    }\n\n    return vector;\n  }\n\n  return readVector();\n}\n\nfunction sighashTypeToString(sighashType) {\n  var text = sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? 'SIGHASH_ANYONECANPAY | ' : '';\n  var sigMod = sighashType & 0x1f;\n\n  switch (sigMod) {\n    case transaction_1.Transaction.SIGHASH_ALL:\n      text += 'SIGHASH_ALL';\n      break;\n\n    case transaction_1.Transaction.SIGHASH_SINGLE:\n      text += 'SIGHASH_SINGLE';\n      break;\n\n    case transaction_1.Transaction.SIGHASH_NONE:\n      text += 'SIGHASH_NONE';\n      break;\n  }\n\n  return text;\n}\n\nfunction witnessStackToScriptWitness(witness) {\n  var buffer = Buffer.allocUnsafe(0);\n\n  function writeSlice(slice) {\n    buffer = Buffer.concat([buffer, Buffer.from(slice)]);\n  }\n\n  function writeVarInt(i) {\n    var currentLen = buffer.length;\n    var varintLen = varuint.encodingLength(i);\n    buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);\n    varuint.encode(i, buffer, currentLen);\n  }\n\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n\n  function writeVector(vector) {\n    writeVarInt(vector.length);\n    vector.forEach(writeVarSlice);\n  }\n\n  writeVector(witness);\n  return buffer;\n}\n\nfunction addNonWitnessTxCache(cache, input, inputIndex) {\n  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;\n  var tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);\n  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;\n  var self = cache;\n  var selfIndex = inputIndex;\n  delete input.nonWitnessUtxo;\n  Object.defineProperty(input, 'nonWitnessUtxo', {\n    enumerable: true,\n    get: function get() {\n      var buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];\n      var txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];\n\n      if (buf !== undefined) {\n        return buf;\n      } else {\n        var newBuf = txCache.toBuffer();\n        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;\n        return newBuf;\n      }\n    },\n    set: function set(data) {\n      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;\n    }\n  });\n}\n\nfunction inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {\n  var inputAmount = 0;\n  inputs.forEach(function (input, idx) {\n    if (mustFinalize && input.finalScriptSig) tx.ins[idx].script = input.finalScriptSig;\n\n    if (mustFinalize && input.finalScriptWitness) {\n      tx.ins[idx].witness = scriptWitnessToWitnessStack(input.finalScriptWitness);\n    }\n\n    if (input.witnessUtxo) {\n      inputAmount += input.witnessUtxo.value;\n    } else if (input.nonWitnessUtxo) {\n      var nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);\n      var vout = tx.ins[idx].index;\n      var out = nwTx.outs[vout];\n      inputAmount += out.value;\n    }\n  });\n  var outputAmount = tx.outs.reduce(function (total, o) {\n    return total + o.value;\n  }, 0);\n  var fee = inputAmount - outputAmount;\n\n  if (fee < 0) {\n    throw new Error('Outputs are spending more than Inputs');\n  }\n\n  var bytes = tx.virtualSize();\n  cache.__FEE = fee;\n  cache.__EXTRACTED_TX = tx;\n  cache.__FEE_RATE = Math.floor(fee / bytes);\n}\n\nfunction nonWitnessUtxoTxFromCache(cache, input, inputIndex) {\n  var c = cache.__NON_WITNESS_UTXO_TX_CACHE;\n\n  if (!c[inputIndex]) {\n    addNonWitnessTxCache(cache, input, inputIndex);\n  }\n\n  return c[inputIndex];\n}\n\nfunction classifyScript(script) {\n  if (isP2WPKH(script)) return 'witnesspubkeyhash';\n  if (isP2PKH(script)) return 'pubkeyhash';\n  if (isP2MS(script)) return 'multisig';\n  if (isP2PK(script)) return 'pubkey';\n  return 'nonstandard';\n}\n\nfunction range(n) {\n  return _toConsumableArray(Array(n).keys());\n}","map":{"version":3,"sources":["/home/aashan/2048/node_modules/bitcoinjs-lib/src/psbt.js"],"names":["Object","defineProperty","exports","value","bip174_1","require","varuint","utils_1","address_1","bufferutils_1","crypto_1","ecpair_1","networks_1","payments","bscript","transaction_1","DEFAULT_OPTS","network","bitcoin","maximumFeeRate","Psbt","opts","data","PsbtTransaction","assign","__CACHE","__NON_WITNESS_UTXO_TX_CACHE","__NON_WITNESS_UTXO_BUF_CACHE","__TX_IN_CACHE","__TX","globalMap","unsignedTx","tx","inputs","length","setVersion","dpew","obj","attr","enumerable","writable","those","combine","map","o","res","fromBuffer","toBuffer","JSON","parse","stringify","satoshiPerByte","check32Bit","version","checkInputsForPartialSig","c","__EXTRACTED_TX","undefined","locktime","inputIndex","sequence","ins","Error","inputDatas","forEach","inputData","addInput","arguments","hash","index","txIn","checkTxInputCache","input","nonWitnessUtxo","addNonWitnessTxCache","__FEE","__FEE_RATE","outputDatas","outputData","addOutput","address","script","toOutputScript","disableFeeCheck","every","isFinalized","checkFees","clone","inputFinalizeGetAmts","getTxCacheValue","checkForInput","range","idx","finalizeInput","finalScriptsFunc","getFinalScripts","getScriptFromInput","isP2SH","isP2WSH","isSegwit","checkPartialSigSighashes","finalScriptSig","finalScriptWitness","updateInput","clearFinalizedInput","results","validateSignaturesOfInput","reduce","final","pubkey","partialSig","mySigs","filter","sig","equals","hashCache","scriptCache","sighashCache","pSig","signature","decode","hashType","getHashForSig","sighashType","checkScriptForPubkey","keypair","fromPublicKey","push","verify","hdKeyPair","sighashTypes","Transaction","SIGHASH_ALL","publicKey","fingerprint","i","signInputHD","err","v","Promise","resolve","reject","promises","signInputHDAsync","then","all","signers","getSignersFromHD","signer","signInput","signInputAsync","catch","keyPair","entries","getHashAndSighashType","encode","sign","toHex","toBase64","updateData","updateGlobal","outputIndex","updateOutput","keyVal","addUnknownKeyValToGlobal","addUnknownKeyValToInput","addUnknownKeyValToOutput","buffer","Buffer","from","psbtBase","transactionFromBuffer","psbt","checkTxForDupeIns","checkTxEmpty","inputCount","outputCount","outs","isBuffer","reverseBuffer","output","canFinalize","scriptType","hasSigs","p2ms","m","pubkeys","neededSigs","sigs","pkey","compressed","find","isPaymentFactory","payment","isP2MS","isP2PK","p2pk","isP2PKH","p2pkh","isP2WPKH","p2wpkh","isP2WSHScript","p2wsh","num","Math","floor","cache","feeRate","getFeeRate","vsize","virtualSize","satoshis","toFixed","action","throws","pSigs","getPsigsFromInputFinalScripts","whitelist","isAnyoneCanPay","SIGHASH_ANYONECANPAY","hashMod","SIGHASH_SINGLE","SIGHASH_NONE","indexOf","pubkeyHash","hash160","decompiled","decompile","hasKey","some","element","toString","isEmpty","witness","key","scriptCheckerFactory","paymentScriptName","scriptPubKey","redeemScript","redeemScriptOutput","redeem","checkRedeemScript","p2sh","checkWitnessScript","name","mustFinalize","classifyScript","prepareFinalScripts","getPayment","witnessStackToScriptWitness","str","sighashTypeToString","nonWitnessUtxoTx","nonWitnessUtxoTxFromCache","prevoutHash","utxoHash","getHash","prevoutIndex","prevout","witnessScript","hashForWitnessV0","signingScript","slice","hashForSignature","witnessUtxo","_script","getSortedSigs","signatures","scriptItems","witnessItems","concat","item","isCanonicalScriptSignature","bip32Derivation","myDerivations","bipDv","masterFingerprint","node","derivePath","path","pk","ps","scriptWitnessToWitnessStack","offset","readSlice","n","readVarInt","vi","bytes","readVarSlice","readVector","count","vector","text","sigMod","allocUnsafe","writeSlice","writeVarInt","currentLen","varintLen","encodingLength","writeVarSlice","writeVector","self","selfIndex","get","buf","txCache","newBuf","set","inputAmount","nwTx","vout","out","outputAmount","total","fee","Array","keys"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bip174_1 = require('bip174');\nconst varuint = require('bip174/src/lib/converter/varint');\nconst utils_1 = require('bip174/src/lib/utils');\nconst address_1 = require('./address');\nconst bufferutils_1 = require('./bufferutils');\nconst crypto_1 = require('./crypto');\nconst ecpair_1 = require('./ecpair');\nconst networks_1 = require('./networks');\nconst payments = require('./payments');\nconst bscript = require('./script');\nconst transaction_1 = require('./transaction');\n/**\n * These are the default arguments for a Psbt instance.\n */\nconst DEFAULT_OPTS = {\n  /**\n   * A bitcoinjs Network object. This is only used if you pass an `address`\n   * parameter to addOutput. Otherwise it is not needed and can be left default.\n   */\n  network: networks_1.bitcoin,\n  /**\n   * When extractTransaction is called, the fee rate is checked.\n   * THIS IS NOT TO BE RELIED ON.\n   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.\n   */\n  maximumFeeRate: 5000,\n};\n/**\n * Psbt class can parse and generate a PSBT binary based off of the BIP174.\n * There are 6 roles that this class fulfills. (Explained in BIP174)\n *\n * Creator: This can be done with `new Psbt()`\n * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,\n *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to\n *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,\n *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`\n *   addInput requires hash: Buffer | string; and index: number; as attributes\n *   and can also include any attributes that are used in updateInput method.\n *   addOutput requires script: Buffer; and value: number; and likewise can include\n *   data for updateOutput.\n *   For a list of what attributes should be what types. Check the bip174 library.\n *   Also, check the integration tests for some examples of usage.\n * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input\n *   information for your pubkey or pubkeyhash, and only sign inputs where it finds\n *   your info. Or you can explicitly sign a specific input with signInput and\n *   signInputAsync. For the async methods you can create a SignerAsync object\n *   and use something like a hardware wallet to sign with. (You must implement this)\n * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`\n *   the psbt calling combine will always have precedence when a conflict occurs.\n *   Combine checks if the internal bitcoin transaction is the same, so be sure that\n *   all sequences, version, locktime, etc. are the same before combining.\n * Input Finalizer: This role is fairly important. Not only does it need to construct\n *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.\n *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`\n *   Running any finalize method will delete any data in the input(s) that are no longer\n *   needed due to the finalized scripts containing the information.\n * Transaction Extractor: This role will perform some checks before returning a\n *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.\n */\nclass Psbt {\n  constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {\n    this.data = data;\n    // set defaults\n    this.opts = Object.assign({}, DEFAULT_OPTS, opts);\n    this.__CACHE = {\n      __NON_WITNESS_UTXO_TX_CACHE: [],\n      __NON_WITNESS_UTXO_BUF_CACHE: [],\n      __TX_IN_CACHE: {},\n      __TX: this.data.globalMap.unsignedTx.tx,\n    };\n    if (this.data.inputs.length === 0) this.setVersion(2);\n    // Make data hidden when enumerating\n    const dpew = (obj, attr, enumerable, writable) =>\n      Object.defineProperty(obj, attr, {\n        enumerable,\n        writable,\n      });\n    dpew(this, '__CACHE', false, true);\n    dpew(this, 'opts', false, true);\n  }\n  static fromBase64(data, opts = {}) {\n    const buffer = Buffer.from(data, 'base64');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromHex(data, opts = {}) {\n    const buffer = Buffer.from(data, 'hex');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromBuffer(buffer, opts = {}) {\n    const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);\n    const psbt = new Psbt(opts, psbtBase);\n    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);\n    return psbt;\n  }\n  get inputCount() {\n    return this.data.inputs.length;\n  }\n  combine(...those) {\n    this.data.combine(...those.map(o => o.data));\n    return this;\n  }\n  clone() {\n    // TODO: more efficient cloning\n    const res = Psbt.fromBuffer(this.data.toBuffer());\n    res.opts = JSON.parse(JSON.stringify(this.opts));\n    return res;\n  }\n  setMaximumFeeRate(satoshiPerByte) {\n    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw\n    this.opts.maximumFeeRate = satoshiPerByte;\n  }\n  setVersion(version) {\n    check32Bit(version);\n    checkInputsForPartialSig(this.data.inputs, 'setVersion');\n    const c = this.__CACHE;\n    c.__TX.version = version;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setLocktime(locktime) {\n    check32Bit(locktime);\n    checkInputsForPartialSig(this.data.inputs, 'setLocktime');\n    const c = this.__CACHE;\n    c.__TX.locktime = locktime;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setInputSequence(inputIndex, sequence) {\n    check32Bit(sequence);\n    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');\n    const c = this.__CACHE;\n    if (c.__TX.ins.length <= inputIndex) {\n      throw new Error('Input index too high');\n    }\n    c.__TX.ins[inputIndex].sequence = sequence;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addInputs(inputDatas) {\n    inputDatas.forEach(inputData => this.addInput(inputData));\n    return this;\n  }\n  addInput(inputData) {\n    if (\n      arguments.length > 1 ||\n      !inputData ||\n      inputData.hash === undefined ||\n      inputData.index === undefined\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addInput. ` +\n          `Requires single object with at least [hash] and [index]`,\n      );\n    }\n    checkInputsForPartialSig(this.data.inputs, 'addInput');\n    const c = this.__CACHE;\n    this.data.addInput(inputData);\n    const txIn = c.__TX.ins[c.__TX.ins.length - 1];\n    checkTxInputCache(c, txIn);\n    const inputIndex = this.data.inputs.length - 1;\n    const input = this.data.inputs[inputIndex];\n    if (input.nonWitnessUtxo) {\n      addNonWitnessTxCache(this.__CACHE, input, inputIndex);\n    }\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addOutputs(outputDatas) {\n    outputDatas.forEach(outputData => this.addOutput(outputData));\n    return this;\n  }\n  addOutput(outputData) {\n    if (\n      arguments.length > 1 ||\n      !outputData ||\n      outputData.value === undefined ||\n      (outputData.address === undefined && outputData.script === undefined)\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addOutput. ` +\n          `Requires single object with at least [script or address] and [value]`,\n      );\n    }\n    checkInputsForPartialSig(this.data.inputs, 'addOutput');\n    const { address } = outputData;\n    if (typeof address === 'string') {\n      const { network } = this.opts;\n      const script = address_1.toOutputScript(address, network);\n      outputData = Object.assign(outputData, { script });\n    }\n    const c = this.__CACHE;\n    this.data.addOutput(outputData);\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  extractTransaction(disableFeeCheck) {\n    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');\n    const c = this.__CACHE;\n    if (!disableFeeCheck) {\n      checkFees(this, c, this.opts);\n    }\n    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;\n    const tx = c.__TX.clone();\n    inputFinalizeGetAmts(this.data.inputs, tx, c, true);\n    return tx;\n  }\n  getFeeRate() {\n    return getTxCacheValue(\n      '__FEE_RATE',\n      'fee rate',\n      this.data.inputs,\n      this.__CACHE,\n    );\n  }\n  getFee() {\n    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);\n  }\n  finalizeAllInputs() {\n    utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one\n    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));\n    return this;\n  }\n  finalizeInput(inputIndex, finalScriptsFunc = getFinalScripts) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(\n      inputIndex,\n      input,\n      this.__CACHE,\n    );\n    if (!script) throw new Error(`No script found for input #${inputIndex}`);\n    checkPartialSigSighashes(input);\n    const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(\n      inputIndex,\n      input,\n      script,\n      isSegwit,\n      isP2SH,\n      isP2WSH,\n    );\n    if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });\n    if (finalScriptWitness)\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    if (!finalScriptSig && !finalScriptWitness)\n      throw new Error(`Unknown error finalizing input #${inputIndex}`);\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  validateSignaturesOfAllInputs() {\n    utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one\n    const results = range(this.data.inputs.length).map(idx =>\n      this.validateSignaturesOfInput(idx),\n    );\n    return results.reduce((final, res) => res === true && final, true);\n  }\n  validateSignaturesOfInput(inputIndex, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const partialSig = (input || {}).partialSig;\n    if (!input || !partialSig || partialSig.length < 1)\n      throw new Error('No signatures to validate');\n    const mySigs = pubkey\n      ? partialSig.filter(sig => sig.pubkey.equals(pubkey))\n      : partialSig;\n    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');\n    const results = [];\n    let hashCache;\n    let scriptCache;\n    let sighashCache;\n    for (const pSig of mySigs) {\n      const sig = bscript.signature.decode(pSig.signature);\n      const { hash, script } =\n        sighashCache !== sig.hashType\n          ? getHashForSig(\n              inputIndex,\n              Object.assign({}, input, { sighashType: sig.hashType }),\n              this.__CACHE,\n            )\n          : { hash: hashCache, script: scriptCache };\n      sighashCache = sig.hashType;\n      hashCache = hash;\n      scriptCache = script;\n      checkScriptForPubkey(pSig.pubkey, script, 'verify');\n      const keypair = ecpair_1.fromPublicKey(pSig.pubkey);\n      results.push(keypair.verify(hash, sig.signature));\n    }\n    return results.every(res => res === true);\n  }\n  signAllInputsHD(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInputHD(i, hdKeyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsHDAsync(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const results = [];\n      const promises = [];\n      for (const i of range(this.data.inputs.length)) {\n        promises.push(\n          this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInputHD(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));\n    return this;\n  }\n  signInputHDAsync(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n      const promises = signers.map(signer =>\n        this.signInputAsync(inputIndex, signer, sighashTypes),\n      );\n      return Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n  signAllInputs(\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    // TODO: Add a pubkey/pubkeyhash cache to each input\n    // as input information is added, then eventually\n    // optimize this method.\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInput(i, keyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsAsync(\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!keyPair || !keyPair.publicKey)\n        return reject(new Error('Need Signer to sign input'));\n      // TODO: Add a pubkey/pubkeyhash cache to each input\n      // as input information is added, then eventually\n      // optimize this method.\n      const results = [];\n      const promises = [];\n      for (const [i] of this.data.inputs.entries()) {\n        promises.push(\n          this.signInputAsync(i, keyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInput(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n    );\n    const partialSig = [\n      {\n        pubkey: keyPair.publicKey,\n        signature: bscript.signature.encode(keyPair.sign(hash), sighashType),\n      },\n    ];\n    this.data.updateInput(inputIndex, { partialSig });\n    return this;\n  }\n  signInputAsync(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!keyPair || !keyPair.publicKey)\n        return reject(new Error('Need Signer to sign input'));\n      const { hash, sighashType } = getHashAndSighashType(\n        this.data.inputs,\n        inputIndex,\n        keyPair.publicKey,\n        this.__CACHE,\n        sighashTypes,\n      );\n      Promise.resolve(keyPair.sign(hash)).then(signature => {\n        const partialSig = [\n          {\n            pubkey: keyPair.publicKey,\n            signature: bscript.signature.encode(signature, sighashType),\n          },\n        ];\n        this.data.updateInput(inputIndex, { partialSig });\n        resolve();\n      });\n    });\n  }\n  toBuffer() {\n    return this.data.toBuffer();\n  }\n  toHex() {\n    return this.data.toHex();\n  }\n  toBase64() {\n    return this.data.toBase64();\n  }\n  updateGlobal(updateData) {\n    this.data.updateGlobal(updateData);\n    return this;\n  }\n  updateInput(inputIndex, updateData) {\n    this.data.updateInput(inputIndex, updateData);\n    if (updateData.nonWitnessUtxo) {\n      addNonWitnessTxCache(\n        this.__CACHE,\n        this.data.inputs[inputIndex],\n        inputIndex,\n      );\n    }\n    return this;\n  }\n  updateOutput(outputIndex, updateData) {\n    this.data.updateOutput(outputIndex, updateData);\n    return this;\n  }\n  addUnknownKeyValToGlobal(keyVal) {\n    this.data.addUnknownKeyValToGlobal(keyVal);\n    return this;\n  }\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    this.data.addUnknownKeyValToInput(inputIndex, keyVal);\n    return this;\n  }\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);\n    return this;\n  }\n  clearFinalizedInput(inputIndex) {\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n}\nexports.Psbt = Psbt;\n/**\n * This function is needed to pass to the bip174 base class's fromBuffer.\n * It takes the \"transaction buffer\" portion of the psbt buffer and returns a\n * Transaction (From the bip174 library) interface.\n */\nconst transactionFromBuffer = buffer => new PsbtTransaction(buffer);\n/**\n * This class implements the Transaction interface from bip174 library.\n * It contains a bitcoinjs-lib Transaction object.\n */\nclass PsbtTransaction {\n  constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {\n    this.tx = transaction_1.Transaction.fromBuffer(buffer);\n    checkTxEmpty(this.tx);\n    Object.defineProperty(this, 'tx', {\n      enumerable: false,\n      writable: true,\n    });\n  }\n  getInputOutputCounts() {\n    return {\n      inputCount: this.tx.ins.length,\n      outputCount: this.tx.outs.length,\n    };\n  }\n  addInput(input) {\n    if (\n      input.hash === undefined ||\n      input.index === undefined ||\n      (!Buffer.isBuffer(input.hash) && typeof input.hash !== 'string') ||\n      typeof input.index !== 'number'\n    ) {\n      throw new Error('Error adding input.');\n    }\n    const hash =\n      typeof input.hash === 'string'\n        ? bufferutils_1.reverseBuffer(Buffer.from(input.hash, 'hex'))\n        : input.hash;\n    this.tx.addInput(hash, input.index, input.sequence);\n  }\n  addOutput(output) {\n    if (\n      output.script === undefined ||\n      output.value === undefined ||\n      !Buffer.isBuffer(output.script) ||\n      typeof output.value !== 'number'\n    ) {\n      throw new Error('Error adding output.');\n    }\n    this.tx.addOutput(output.script, output.value);\n  }\n  toBuffer() {\n    return this.tx.toBuffer();\n  }\n}\nfunction canFinalize(input, script, scriptType) {\n  switch (scriptType) {\n    case 'pubkey':\n    case 'pubkeyhash':\n    case 'witnesspubkeyhash':\n      return hasSigs(1, input.partialSig);\n    case 'multisig':\n      const p2ms = payments.p2ms({ output: script });\n      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);\n    default:\n      return false;\n  }\n}\nfunction hasSigs(neededSigs, partialSig, pubkeys) {\n  if (!partialSig) return false;\n  let sigs;\n  if (pubkeys) {\n    sigs = pubkeys\n      .map(pkey => {\n        const pubkey = ecpair_1.fromPublicKey(pkey, { compressed: true })\n          .publicKey;\n        return partialSig.find(pSig => pSig.pubkey.equals(pubkey));\n      })\n      .filter(v => !!v);\n  } else {\n    sigs = partialSig;\n  }\n  if (sigs.length > neededSigs) throw new Error('Too many signatures');\n  return sigs.length === neededSigs;\n}\nfunction isFinalized(input) {\n  return !!input.finalScriptSig || !!input.finalScriptWitness;\n}\nfunction isPaymentFactory(payment) {\n  return script => {\n    try {\n      payment({ output: script });\n      return true;\n    } catch (err) {\n      return false;\n    }\n  };\n}\nconst isP2MS = isPaymentFactory(payments.p2ms);\nconst isP2PK = isPaymentFactory(payments.p2pk);\nconst isP2PKH = isPaymentFactory(payments.p2pkh);\nconst isP2WPKH = isPaymentFactory(payments.p2wpkh);\nconst isP2WSHScript = isPaymentFactory(payments.p2wsh);\nfunction check32Bit(num) {\n  if (\n    typeof num !== 'number' ||\n    num !== Math.floor(num) ||\n    num > 0xffffffff ||\n    num < 0\n  ) {\n    throw new Error('Invalid 32 bit integer');\n  }\n}\nfunction checkFees(psbt, cache, opts) {\n  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();\n  const vsize = cache.__EXTRACTED_TX.virtualSize();\n  const satoshis = feeRate * vsize;\n  if (feeRate >= opts.maximumFeeRate) {\n    throw new Error(\n      `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +\n        `fees, which is ${feeRate} satoshi per byte for a transaction ` +\n        `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +\n        `byte). Use setMaximumFeeRate method to raise your threshold, or ` +\n        `pass true to the first arg of extractTransaction.`,\n    );\n  }\n}\nfunction checkInputsForPartialSig(inputs, action) {\n  inputs.forEach(input => {\n    let throws = false;\n    let pSigs = [];\n    if ((input.partialSig || []).length === 0) {\n      if (!input.finalScriptSig && !input.finalScriptWitness) return;\n      pSigs = getPsigsFromInputFinalScripts(input);\n    } else {\n      pSigs = input.partialSig;\n    }\n    pSigs.forEach(pSig => {\n      const { hashType } = bscript.signature.decode(pSig.signature);\n      const whitelist = [];\n      const isAnyoneCanPay =\n        hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;\n      if (isAnyoneCanPay) whitelist.push('addInput');\n      const hashMod = hashType & 0x1f;\n      switch (hashMod) {\n        case transaction_1.Transaction.SIGHASH_ALL:\n          break;\n        case transaction_1.Transaction.SIGHASH_SINGLE:\n        case transaction_1.Transaction.SIGHASH_NONE:\n          whitelist.push('addOutput');\n          whitelist.push('setInputSequence');\n          break;\n      }\n      if (whitelist.indexOf(action) === -1) {\n        throws = true;\n      }\n    });\n    if (throws) {\n      throw new Error('Can not modify transaction, signatures exist.');\n    }\n  });\n}\nfunction checkPartialSigSighashes(input) {\n  if (!input.sighashType || !input.partialSig) return;\n  const { partialSig, sighashType } = input;\n  partialSig.forEach(pSig => {\n    const { hashType } = bscript.signature.decode(pSig.signature);\n    if (sighashType !== hashType) {\n      throw new Error('Signature sighash does not match input sighash type');\n    }\n  });\n}\nfunction checkScriptForPubkey(pubkey, script, action) {\n  const pubkeyHash = crypto_1.hash160(pubkey);\n  const decompiled = bscript.decompile(script);\n  if (decompiled === null) throw new Error('Unknown script error');\n  const hasKey = decompiled.some(element => {\n    if (typeof element === 'number') return false;\n    return element.equals(pubkey) || element.equals(pubkeyHash);\n  });\n  if (!hasKey) {\n    throw new Error(\n      `Can not ${action} for this input with the key ${pubkey.toString('hex')}`,\n    );\n  }\n}\nfunction checkTxEmpty(tx) {\n  const isEmpty = tx.ins.every(\n    input =>\n      input.script &&\n      input.script.length === 0 &&\n      input.witness &&\n      input.witness.length === 0,\n  );\n  if (!isEmpty) {\n    throw new Error('Format Error: Transaction ScriptSigs are not empty');\n  }\n}\nfunction checkTxForDupeIns(tx, cache) {\n  tx.ins.forEach(input => {\n    checkTxInputCache(cache, input);\n  });\n}\nfunction checkTxInputCache(cache, input) {\n  const key =\n    bufferutils_1.reverseBuffer(Buffer.from(input.hash)).toString('hex') +\n    ':' +\n    input.index;\n  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');\n  cache.__TX_IN_CACHE[key] = 1;\n}\nfunction scriptCheckerFactory(payment, paymentScriptName) {\n  return (inputIndex, scriptPubKey, redeemScript) => {\n    const redeemScriptOutput = payment({\n      redeem: { output: redeemScript },\n    }).output;\n    if (!scriptPubKey.equals(redeemScriptOutput)) {\n      throw new Error(\n        `${paymentScriptName} for input #${inputIndex} doesn't match the scriptPubKey in the prevout`,\n      );\n    }\n  };\n}\nconst checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');\nconst checkWitnessScript = scriptCheckerFactory(\n  payments.p2wsh,\n  'Witness script',\n);\nfunction getTxCacheValue(key, name, inputs, c) {\n  if (!inputs.every(isFinalized))\n    throw new Error(`PSBT must be finalized to calculate ${name}`);\n  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;\n  if (key === '__FEE' && c.__FEE) return c.__FEE;\n  let tx;\n  let mustFinalize = true;\n  if (c.__EXTRACTED_TX) {\n    tx = c.__EXTRACTED_TX;\n    mustFinalize = false;\n  } else {\n    tx = c.__TX.clone();\n  }\n  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);\n  if (key === '__FEE_RATE') return c.__FEE_RATE;\n  else if (key === '__FEE') return c.__FEE;\n}\nfunction getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {\n  const scriptType = classifyScript(script);\n  if (!canFinalize(input, script, scriptType))\n    throw new Error(`Can not finalize input #${inputIndex}`);\n  return prepareFinalScripts(\n    script,\n    scriptType,\n    input.partialSig,\n    isSegwit,\n    isP2SH,\n    isP2WSH,\n  );\n}\nfunction prepareFinalScripts(\n  script,\n  scriptType,\n  partialSig,\n  isSegwit,\n  isP2SH,\n  isP2WSH,\n) {\n  let finalScriptSig;\n  let finalScriptWitness;\n  // Wow, the payments API is very handy\n  const payment = getPayment(script, scriptType, partialSig);\n  const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });\n  const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });\n  if (isSegwit) {\n    if (p2wsh) {\n      finalScriptWitness = witnessStackToScriptWitness(p2wsh.witness);\n    } else {\n      finalScriptWitness = witnessStackToScriptWitness(payment.witness);\n    }\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    }\n  } else {\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    } else {\n      finalScriptSig = payment.input;\n    }\n  }\n  return {\n    finalScriptSig,\n    finalScriptWitness,\n  };\n}\nfunction getHashAndSighashType(\n  inputs,\n  inputIndex,\n  pubkey,\n  cache,\n  sighashTypes,\n) {\n  const input = utils_1.checkForInput(inputs, inputIndex);\n  const { hash, sighashType, script } = getHashForSig(\n    inputIndex,\n    input,\n    cache,\n    sighashTypes,\n  );\n  checkScriptForPubkey(pubkey, script, 'sign');\n  return {\n    hash,\n    sighashType,\n  };\n}\nfunction getHashForSig(inputIndex, input, cache, sighashTypes) {\n  const unsignedTx = cache.__TX;\n  const sighashType =\n    input.sighashType || transaction_1.Transaction.SIGHASH_ALL;\n  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {\n    const str = sighashTypeToString(sighashType);\n    throw new Error(\n      `Sighash type is not allowed. Retry the sign method passing the ` +\n        `sighashTypes array of whitelisted types. Sighash type: ${str}`,\n    );\n  }\n  let hash;\n  let script;\n  if (input.nonWitnessUtxo) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const prevoutHash = unsignedTx.ins[inputIndex].hash;\n    const utxoHash = nonWitnessUtxoTx.getHash();\n    // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout\n    if (!prevoutHash.equals(utxoHash)) {\n      throw new Error(\n        `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`,\n      );\n    }\n    const prevoutIndex = unsignedTx.ins[inputIndex].index;\n    const prevout = nonWitnessUtxoTx.outs[prevoutIndex];\n    if (input.redeemScript) {\n      // If a redeemScript is provided, the scriptPubKey must be for that redeemScript\n      checkRedeemScript(inputIndex, prevout.script, input.redeemScript);\n      script = input.redeemScript;\n    } else {\n      script = prevout.script;\n    }\n    if (isP2WSHScript(script)) {\n      if (!input.witnessScript)\n        throw new Error('Segwit input needs witnessScript if not P2WPKH');\n      checkWitnessScript(inputIndex, script, input.witnessScript);\n      hash = unsignedTx.hashForWitnessV0(\n        inputIndex,\n        input.witnessScript,\n        prevout.value,\n        sighashType,\n      );\n      script = input.witnessScript;\n    } else if (isP2WPKH(script)) {\n      // P2WPKH uses the P2PKH template for prevoutScript when signing\n      const signingScript = payments.p2pkh({ hash: script.slice(2) }).output;\n      hash = unsignedTx.hashForWitnessV0(\n        inputIndex,\n        signingScript,\n        prevout.value,\n        sighashType,\n      );\n    } else {\n      hash = unsignedTx.hashForSignature(inputIndex, script, sighashType);\n    }\n  } else if (input.witnessUtxo) {\n    let _script; // so we don't shadow the `let script` above\n    if (input.redeemScript) {\n      // If a redeemScript is provided, the scriptPubKey must be for that redeemScript\n      checkRedeemScript(\n        inputIndex,\n        input.witnessUtxo.script,\n        input.redeemScript,\n      );\n      _script = input.redeemScript;\n    } else {\n      _script = input.witnessUtxo.script;\n    }\n    if (isP2WPKH(_script)) {\n      // P2WPKH uses the P2PKH template for prevoutScript when signing\n      const signingScript = payments.p2pkh({ hash: _script.slice(2) }).output;\n      hash = unsignedTx.hashForWitnessV0(\n        inputIndex,\n        signingScript,\n        input.witnessUtxo.value,\n        sighashType,\n      );\n      script = _script;\n    } else if (isP2WSHScript(_script)) {\n      if (!input.witnessScript)\n        throw new Error('Segwit input needs witnessScript if not P2WPKH');\n      checkWitnessScript(inputIndex, _script, input.witnessScript);\n      hash = unsignedTx.hashForWitnessV0(\n        inputIndex,\n        input.witnessScript,\n        input.witnessUtxo.value,\n        sighashType,\n      );\n      // want to make sure the script we return is the actual meaningful script\n      script = input.witnessScript;\n    } else {\n      throw new Error(\n        `Input #${inputIndex} has witnessUtxo but non-segwit script: ` +\n          `${_script.toString('hex')}`,\n      );\n    }\n  } else {\n    throw new Error('Need a Utxo input item for signing');\n  }\n  return {\n    script,\n    sighashType,\n    hash,\n  };\n}\nfunction getPayment(script, scriptType, partialSig) {\n  let payment;\n  switch (scriptType) {\n    case 'multisig':\n      const sigs = getSortedSigs(script, partialSig);\n      payment = payments.p2ms({\n        output: script,\n        signatures: sigs,\n      });\n      break;\n    case 'pubkey':\n      payment = payments.p2pk({\n        output: script,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'pubkeyhash':\n      payment = payments.p2pkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'witnesspubkeyhash':\n      payment = payments.p2wpkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n  }\n  return payment;\n}\nfunction getPsigsFromInputFinalScripts(input) {\n  const scriptItems = !input.finalScriptSig\n    ? []\n    : bscript.decompile(input.finalScriptSig) || [];\n  const witnessItems = !input.finalScriptWitness\n    ? []\n    : bscript.decompile(input.finalScriptWitness) || [];\n  return scriptItems\n    .concat(witnessItems)\n    .filter(item => {\n      return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);\n    })\n    .map(sig => ({ signature: sig }));\n}\nfunction getScriptFromInput(inputIndex, input, cache) {\n  const unsignedTx = cache.__TX;\n  const res = {\n    script: null,\n    isSegwit: false,\n    isP2SH: false,\n    isP2WSH: false,\n  };\n  res.isP2SH = !!input.redeemScript;\n  res.isP2WSH = !!input.witnessScript;\n  if (input.witnessScript) {\n    res.script = input.witnessScript;\n  } else if (input.redeemScript) {\n    res.script = input.redeemScript;\n  } else {\n    if (input.nonWitnessUtxo) {\n      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n        cache,\n        input,\n        inputIndex,\n      );\n      const prevoutIndex = unsignedTx.ins[inputIndex].index;\n      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;\n    } else if (input.witnessUtxo) {\n      res.script = input.witnessUtxo.script;\n    }\n  }\n  if (input.witnessScript || isP2WPKH(res.script)) {\n    res.isSegwit = true;\n  }\n  return res;\n}\nfunction getSignersFromHD(inputIndex, inputs, hdKeyPair) {\n  const input = utils_1.checkForInput(inputs, inputIndex);\n  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {\n    throw new Error('Need bip32Derivation to sign with HD');\n  }\n  const myDerivations = input.bip32Derivation\n    .map(bipDv => {\n      if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {\n        return bipDv;\n      } else {\n        return;\n      }\n    })\n    .filter(v => !!v);\n  if (myDerivations.length === 0) {\n    throw new Error(\n      'Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint',\n    );\n  }\n  const signers = myDerivations.map(bipDv => {\n    const node = hdKeyPair.derivePath(bipDv.path);\n    if (!bipDv.pubkey.equals(node.publicKey)) {\n      throw new Error('pubkey did not match bip32Derivation');\n    }\n    return node;\n  });\n  return signers;\n}\nfunction getSortedSigs(script, partialSig) {\n  const p2ms = payments.p2ms({ output: script });\n  // for each pubkey in order of p2ms script\n  return p2ms.pubkeys\n    .map(pk => {\n      // filter partialSig array by pubkey being equal\n      return (\n        partialSig.filter(ps => {\n          return ps.pubkey.equals(pk);\n        })[0] || {}\n      ).signature;\n      // Any pubkey without a match will return undefined\n      // this last filter removes all the undefined items in the array.\n    })\n    .filter(v => !!v);\n}\nfunction scriptWitnessToWitnessStack(buffer) {\n  let offset = 0;\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n  function readVarInt() {\n    const vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n  function readVector() {\n    const count = readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(readVarSlice());\n    return vector;\n  }\n  return readVector();\n}\nfunction sighashTypeToString(sighashType) {\n  let text =\n    sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY\n      ? 'SIGHASH_ANYONECANPAY | '\n      : '';\n  const sigMod = sighashType & 0x1f;\n  switch (sigMod) {\n    case transaction_1.Transaction.SIGHASH_ALL:\n      text += 'SIGHASH_ALL';\n      break;\n    case transaction_1.Transaction.SIGHASH_SINGLE:\n      text += 'SIGHASH_SINGLE';\n      break;\n    case transaction_1.Transaction.SIGHASH_NONE:\n      text += 'SIGHASH_NONE';\n      break;\n  }\n  return text;\n}\nfunction witnessStackToScriptWitness(witness) {\n  let buffer = Buffer.allocUnsafe(0);\n  function writeSlice(slice) {\n    buffer = Buffer.concat([buffer, Buffer.from(slice)]);\n  }\n  function writeVarInt(i) {\n    const currentLen = buffer.length;\n    const varintLen = varuint.encodingLength(i);\n    buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);\n    varuint.encode(i, buffer, currentLen);\n  }\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n  function writeVector(vector) {\n    writeVarInt(vector.length);\n    vector.forEach(writeVarSlice);\n  }\n  writeVector(witness);\n  return buffer;\n}\nfunction addNonWitnessTxCache(cache, input, inputIndex) {\n  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;\n  const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);\n  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;\n  const self = cache;\n  const selfIndex = inputIndex;\n  delete input.nonWitnessUtxo;\n  Object.defineProperty(input, 'nonWitnessUtxo', {\n    enumerable: true,\n    get() {\n      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];\n      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];\n      if (buf !== undefined) {\n        return buf;\n      } else {\n        const newBuf = txCache.toBuffer();\n        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;\n        return newBuf;\n      }\n    },\n    set(data) {\n      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;\n    },\n  });\n}\nfunction inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {\n  let inputAmount = 0;\n  inputs.forEach((input, idx) => {\n    if (mustFinalize && input.finalScriptSig)\n      tx.ins[idx].script = input.finalScriptSig;\n    if (mustFinalize && input.finalScriptWitness) {\n      tx.ins[idx].witness = scriptWitnessToWitnessStack(\n        input.finalScriptWitness,\n      );\n    }\n    if (input.witnessUtxo) {\n      inputAmount += input.witnessUtxo.value;\n    } else if (input.nonWitnessUtxo) {\n      const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);\n      const vout = tx.ins[idx].index;\n      const out = nwTx.outs[vout];\n      inputAmount += out.value;\n    }\n  });\n  const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);\n  const fee = inputAmount - outputAmount;\n  if (fee < 0) {\n    throw new Error('Outputs are spending more than Inputs');\n  }\n  const bytes = tx.virtualSize();\n  cache.__FEE = fee;\n  cache.__EXTRACTED_TX = tx;\n  cache.__FEE_RATE = Math.floor(fee / bytes);\n}\nfunction nonWitnessUtxoTxFromCache(cache, input, inputIndex) {\n  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;\n  if (!c[inputIndex]) {\n    addNonWitnessTxCache(cache, input, inputIndex);\n  }\n  return c[inputIndex];\n}\nfunction classifyScript(script) {\n  if (isP2WPKH(script)) return 'witnesspubkeyhash';\n  if (isP2PKH(script)) return 'pubkeyhash';\n  if (isP2MS(script)) return 'multisig';\n  if (isP2PK(script)) return 'pubkey';\n  return 'nonstandard';\n}\nfunction range(n) {\n  return [...Array(n).keys()];\n}\n"]},"metadata":{},"sourceType":"script"}