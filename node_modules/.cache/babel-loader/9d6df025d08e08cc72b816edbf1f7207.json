{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/aashan/2048/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/home/aashan/2048/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/aashan/2048/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar crypto = require(\"crypto\");\n\nvar bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\n\nvar bip39 = require(\"bip39\");\n\nvar utils_1 = require(\"./utils\");\n\nvar wallet_1 = require(\"./encryption/wallet\");\n\nvar APPS_NODE_INDEX = 0;\nvar IDENTITY_KEYCHAIN = 888;\nvar BLOCKSTACK_ON_BITCOIN = 0;\nvar BITCOIN_BIP_44_PURPOSE = 44;\nvar BITCOIN_COIN_TYPE = 0;\nvar BITCOIN_ACCOUNT_INDEX = 0;\nvar EXTERNAL_ADDRESS = 'EXTERNAL_ADDRESS';\nvar CHANGE_ADDRESS = 'CHANGE_ADDRESS';\n/**\n *\n * @ignore\n */\n\nfunction hashCode(string) {\n  var hash = 0;\n  if (string.length === 0) return hash;\n\n  for (var i = 0; i < string.length; i++) {\n    var character = string.charCodeAt(i);\n    hash = (hash << 5) - hash + character;\n    hash &= hash;\n  }\n\n  return hash & 0x7fffffff;\n}\n/**\n *\n * @ignore\n */\n\n\nfunction getNodePrivateKey(node) {\n  return utils_1.ecPairToHexString(bitcoinjs_lib_1.ECPair.fromPrivateKey(node.privateKey));\n}\n/**\n *\n * @ignore\n */\n\n\nfunction getNodePublicKey(node) {\n  return node.publicKey.toString('hex');\n}\n/**\n * The `BlockstackWallet` class manages the hierarchical derivation\n * paths for a standard Blockstack client wallet. This includes paths\n * for Bitcoin payment address, Blockstack identity addresses, Blockstack\n * application specific addresses.\n *\n * @ignore\n */\n\n\nvar BlockstackWallet =\n/*#__PURE__*/\nfunction () {\n  function BlockstackWallet(rootNode) {\n    _classCallCheck(this, BlockstackWallet);\n\n    this.rootNode = rootNode;\n  }\n\n  _createClass(BlockstackWallet, [{\n    key: \"toBase58\",\n    value: function toBase58() {\n      return this.rootNode.toBase58();\n    }\n    /**\n     * Initialize a Blockstack wallet from a seed buffer\n     * @param {Buffer} seed - the input seed for initializing the root node\n     *  of the hierarchical wallet\n     * @return {BlockstackWallet} the constructed wallet\n     */\n\n  }, {\n    key: \"getIdentityPrivateKeychain\",\n    value: function getIdentityPrivateKeychain() {\n      return this.rootNode.deriveHardened(IDENTITY_KEYCHAIN).deriveHardened(BLOCKSTACK_ON_BITCOIN);\n    }\n  }, {\n    key: \"getBitcoinPrivateKeychain\",\n    value: function getBitcoinPrivateKeychain() {\n      return this.rootNode.deriveHardened(BITCOIN_BIP_44_PURPOSE).deriveHardened(BITCOIN_COIN_TYPE).deriveHardened(BITCOIN_ACCOUNT_INDEX);\n    }\n  }, {\n    key: \"getBitcoinNode\",\n    value: function getBitcoinNode(addressIndex) {\n      var chainType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EXTERNAL_ADDRESS;\n      return BlockstackWallet.getNodeFromBitcoinKeychain(this.getBitcoinPrivateKeychain().toBase58(), addressIndex, chainType);\n    }\n  }, {\n    key: \"getIdentityAddressNode\",\n    value: function getIdentityAddressNode(identityIndex) {\n      var identityPrivateKeychain = this.getIdentityPrivateKeychain();\n      return identityPrivateKeychain.deriveHardened(identityIndex);\n    }\n  }, {\n    key: \"getIdentitySalt\",\n\n    /**\n     * Get a salt for use with creating application specific addresses\n     * @return {String} the salt\n     */\n    value: function getIdentitySalt() {\n      var identityPrivateKeychain = this.getIdentityPrivateKeychain();\n      var publicKeyHex = getNodePublicKey(identityPrivateKeychain);\n      return crypto.createHash('sha256').update(publicKeyHex).digest('hex');\n    }\n    /**\n     * Get a bitcoin receive address at a given index\n     * @param {number} addressIndex - the index of the address\n     * @return {String} address\n     */\n\n  }, {\n    key: \"getBitcoinAddress\",\n    value: function getBitcoinAddress(addressIndex) {\n      return BlockstackWallet.getAddressFromBIP32Node(this.getBitcoinNode(addressIndex));\n    }\n    /**\n     * Get the private key hex-string for a given bitcoin receive address\n     * @param {number} addressIndex - the index of the address\n     * @return {String} the hex-string. this will be either 64\n     * characters long to denote an uncompressed bitcoin address, or 66\n     * characters long for a compressed bitcoin address.\n     */\n\n  }, {\n    key: \"getBitcoinPrivateKey\",\n    value: function getBitcoinPrivateKey(addressIndex) {\n      return getNodePrivateKey(this.getBitcoinNode(addressIndex));\n    }\n    /**\n     * Get the root node for the bitcoin public keychain\n     * @return {String} base58-encoding of the public node\n     */\n\n  }, {\n    key: \"getBitcoinPublicKeychain\",\n    value: function getBitcoinPublicKeychain() {\n      return this.getBitcoinPrivateKeychain().neutered();\n    }\n    /**\n     * Get the root node for the identity public keychain\n     * @return {String} base58-encoding of the public node\n     */\n\n  }, {\n    key: \"getIdentityPublicKeychain\",\n    value: function getIdentityPublicKeychain() {\n      return this.getIdentityPrivateKeychain().neutered();\n    }\n  }, {\n    key: \"getIdentityKeyPair\",\n\n    /**\n     * Get the keypair information for a given identity index. This\n     * information is used to obtain the private key for an identity address\n     * and derive application specific keys for that address.\n     * @param {number} addressIndex - the identity index\n     * @param {boolean} alwaysUncompressed - if true, always return a\n     *   private-key hex string corresponding to the uncompressed address\n     * @return {Object} an IdentityKeyPair type object with keys:\n     *   .key {String} - the private key hex-string\n     *   .keyID {String} - the public key hex-string\n     *   .address {String} - the identity address\n     *   .appsNodeKey {String} - the base-58 encoding of the applications node\n     *   .salt {String} - the salt used for creating app-specific addresses\n     */\n    value: function getIdentityKeyPair(addressIndex) {\n      var alwaysUncompressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var identityNode = this.getIdentityAddressNode(addressIndex);\n      var address = BlockstackWallet.getAddressFromBIP32Node(identityNode);\n      var identityKey = getNodePrivateKey(identityNode);\n\n      if (alwaysUncompressed && identityKey.length === 66) {\n        identityKey = identityKey.slice(0, 64);\n      }\n\n      var identityKeyID = getNodePublicKey(identityNode);\n      var appsNodeKey = BlockstackWallet.getAppsNode(identityNode).toBase58();\n      var salt = this.getIdentitySalt();\n      var keyPair = {\n        key: identityKey,\n        keyID: identityKeyID,\n        address: address,\n        appsNodeKey: appsNodeKey,\n        salt: salt\n      };\n      return keyPair;\n    }\n  }], [{\n    key: \"fromSeedBuffer\",\n    value: function fromSeedBuffer(seed) {\n      return new BlockstackWallet(bitcoinjs_lib_1.bip32.fromSeed(seed));\n    }\n    /**\n     * Initialize a Blockstack wallet from a base58 string\n     * @param {string} keychain - the Base58 string used to initialize\n     *  the root node of the hierarchical wallet\n     * @return {BlockstackWallet} the constructed wallet\n     */\n\n  }, {\n    key: \"fromBase58\",\n    value: function fromBase58(keychain) {\n      return new BlockstackWallet(bitcoinjs_lib_1.bip32.fromBase58(keychain));\n    }\n    /**\n     * Initialize a blockstack wallet from an encrypted phrase & password. Throws\n     * if the password is incorrect. Supports all formats of Blockstack phrases.\n     * @param {string} data - The encrypted phrase as a hex-encoded string\n     * @param {string} password - The plain password\n     * @return {Promise<BlockstackWallet>} the constructed wallet\n     *\n     * @ignore\n     */\n\n  }, {\n    key: \"fromEncryptedMnemonic\",\n    value: function fromEncryptedMnemonic(data, password) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var mnemonic, seed;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return wallet_1.decryptMnemonic(data, password);\n\n              case 3:\n                mnemonic = _context.sent;\n                _context.next = 6;\n                return bip39.mnemonicToSeed(mnemonic);\n\n              case 6:\n                seed = _context.sent;\n                return _context.abrupt(\"return\", new BlockstackWallet(bitcoinjs_lib_1.bip32.fromSeed(seed)));\n\n              case 10:\n                _context.prev = 10;\n                _context.t0 = _context[\"catch\"](0);\n\n                if (!(_context.t0.message && _context.t0.message.startsWith('bad header;'))) {\n                  _context.next = 16;\n                  break;\n                }\n\n                throw new Error('Incorrect password');\n\n              case 16:\n                throw _context.t0;\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[0, 10]]);\n      }));\n    }\n    /**\n     * Generate a BIP-39 12 word mnemonic\n     * @return {Promise<string>} space-separated 12 word phrase\n     */\n\n  }, {\n    key: \"generateMnemonic\",\n    value: function generateMnemonic() {\n      return bip39.generateMnemonic(128, crypto.randomBytes);\n    }\n    /**\n     * Encrypt a mnemonic phrase with a password\n     * @param {string} mnemonic - Raw mnemonic phrase\n     * @param {string} password - Password to encrypt mnemonic with\n     * @return {Promise<string>} Hex-encoded encrypted mnemonic\n     *\n     */\n\n  }, {\n    key: \"encryptMnemonic\",\n    value: function encryptMnemonic(mnemonic, password) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2() {\n        var encryptedBuffer;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return wallet_1.encryptMnemonic(mnemonic, password);\n\n              case 2:\n                encryptedBuffer = _context2.sent;\n                return _context2.abrupt(\"return\", encryptedBuffer.toString('hex'));\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n    }\n  }, {\n    key: \"getAppsNode\",\n    value: function getAppsNode(identityNode) {\n      return identityNode.deriveHardened(APPS_NODE_INDEX);\n    }\n  }, {\n    key: \"getNodeFromBitcoinKeychain\",\n    value: function getNodeFromBitcoinKeychain(keychainBase58, addressIndex) {\n      var chainType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EXTERNAL_ADDRESS;\n      var chain;\n\n      if (chainType === EXTERNAL_ADDRESS) {\n        chain = 0;\n      } else if (chainType === CHANGE_ADDRESS) {\n        chain = 1;\n      } else {\n        throw new Error('Invalid chain type');\n      }\n\n      var keychain = bitcoinjs_lib_1.bip32.fromBase58(keychainBase58);\n      return keychain.derive(chain).derive(addressIndex);\n    }\n    /**\n     * Get a bitcoin address given a base-58 encoded bitcoin node\n     * (usually called the account node)\n     * @param {String} keychainBase58 - base58-encoding of the node\n     * @param {number} addressIndex - index of the address to get\n     * @param {String} chainType - either 'EXTERNAL_ADDRESS' (for a\n     * \"receive\" address) or 'CHANGE_ADDRESS'\n     * @return {String} the address\n     */\n\n  }, {\n    key: \"getAddressFromBitcoinKeychain\",\n    value: function getAddressFromBitcoinKeychain(keychainBase58, addressIndex) {\n      var chainType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EXTERNAL_ADDRESS;\n      return BlockstackWallet.getAddressFromBIP32Node(BlockstackWallet.getNodeFromBitcoinKeychain(keychainBase58, addressIndex, chainType));\n    }\n    /**\n     * Get a ECDSA private key hex-string for an application-specific\n     *  address.\n     * @param {String} appsNodeKey - the base58-encoded private key for\n     * applications node (the `appsNodeKey` return in getIdentityKeyPair())\n     * @param {String} salt - a string, used to salt the\n     * application-specific addresses\n     * @param {String} appDomain - the appDomain to generate a key for\n     * @return {String} the private key hex-string. this will be a 64\n     * character string\n     */\n\n  }, {\n    key: \"getLegacyAppPrivateKey\",\n    value: function getLegacyAppPrivateKey(appsNodeKey, salt, appDomain) {\n      var hash = crypto.createHash('sha256').update(\"\".concat(appDomain).concat(salt)).digest('hex');\n      var appIndex = hashCode(hash);\n      var appNode = bitcoinjs_lib_1.bip32.fromBase58(appsNodeKey).deriveHardened(appIndex);\n      return getNodePrivateKey(appNode).slice(0, 64);\n    }\n  }, {\n    key: \"getAddressFromBIP32Node\",\n    value: function getAddressFromBIP32Node(node) {\n      return bitcoinjs_lib_1.payments.p2pkh({\n        pubkey: node.publicKey\n      }).address;\n    }\n    /**\n     * Get a ECDSA private key hex-string for an application-specific\n     *  address.\n     * @param {String} appsNodeKey - the base58-encoded private key for\n     * applications node (the `appsNodeKey` return in getIdentityKeyPair())\n     * @param {String} salt - a string, used to salt the\n     * application-specific addresses\n     * @param {String} appDomain - the appDomain to generate a key for\n     * @return {String} the private key hex-string. this will be a 64\n     * character string\n     */\n\n  }, {\n    key: \"getAppPrivateKey\",\n    value: function getAppPrivateKey(appsNodeKey, salt, appDomain) {\n      var hash = crypto.createHash('sha256').update(\"\".concat(appDomain).concat(salt)).digest('hex');\n      var appIndexHexes = []; // note: there's hardcoded numbers here, precisely because I want this\n      //   code to be very specific to the derivation paths we expect.\n\n      if (hash.length !== 64) {\n        throw new Error(\"Unexpected app-domain hash length of \".concat(hash.length));\n      }\n\n      for (var i = 0; i < 11; i++) {\n        // split the hash into 3-byte chunks\n        // because child nodes can only be up to 2^31,\n        // and we shouldn't deal in partial bytes.\n        appIndexHexes.push(hash.slice(i * 6, i * 6 + 6));\n      }\n\n      var appNode = bitcoinjs_lib_1.bip32.fromBase58(appsNodeKey);\n      appIndexHexes.forEach(function (hex) {\n        if (hex.length > 6) {\n          throw new Error('Invalid hex string length');\n        }\n\n        appNode = appNode.deriveHardened(parseInt(hex, 16));\n      });\n      return getNodePrivateKey(appNode).slice(0, 64);\n    }\n  }]);\n\n  return BlockstackWallet;\n}();\n\nexports.BlockstackWallet = BlockstackWallet;","map":{"version":3,"sources":["../src/wallet.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,MAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,IAAA,eAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,IAAA,KAAA,GAAA,OAAA,CAAA,OAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;AAEA,IAAM,eAAe,GAAG,CAAxB;AACA,IAAM,iBAAiB,GAAG,GAA1B;AACA,IAAM,qBAAqB,GAAG,CAA9B;AAEA,IAAM,sBAAsB,GAAG,EAA/B;AACA,IAAM,iBAAiB,GAAG,CAA1B;AACA,IAAM,qBAAqB,GAAG,CAA9B;AAEA,IAAM,gBAAgB,GAAG,kBAAzB;AACA,IAAM,cAAc,GAAG,gBAAvB;AAcA;;;;;AAIA,SAAS,QAAT,CAAkB,MAAlB,EAAgC;AAC9B,MAAI,IAAI,GAAG,CAAX;AACA,MAAI,MAAM,CAAC,MAAP,KAAkB,CAAtB,EAAyB,OAAO,IAAP;;AACzB,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,CAAC,EAApC,EAAwC;AACtC,QAAM,SAAS,GAAG,MAAM,CAAC,UAAP,CAAkB,CAAlB,CAAlB;AACA,IAAA,IAAI,GAAG,CAAC,IAAI,IAAI,CAAT,IAAc,IAAd,GAAqB,SAA5B;AACA,IAAA,IAAI,IAAI,IAAR;AACD;;AACD,SAAO,IAAI,GAAG,UAAd;AACD;AAED;;;;;;AAIA,SAAS,iBAAT,CAA2B,IAA3B,EAA+C;AAC7C,SAAO,OAAA,CAAA,iBAAA,CAAkB,eAAA,CAAA,MAAA,CAAO,cAAP,CAAsB,IAAI,CAAC,UAA3B,CAAlB,CAAP;AACD;AAED;;;;;;AAIA,SAAS,gBAAT,CAA0B,IAA1B,EAA8C;AAC5C,SAAO,IAAI,CAAC,SAAL,CAAe,QAAf,CAAwB,KAAxB,CAAP;AACD;AAED;;;;;;;;;;IAQa,gB;;;AAGX,4BAAY,QAAZ,EAAoC;AAAA;;AAClC,SAAK,QAAL,GAAgB,QAAhB;AACD;;;;+BAEO;AACN,aAAO,KAAK,QAAL,CAAc,QAAd,EAAP;AACD;AAED;;;;;;;;;iDA+D0B;AACxB,aAAO,KAAK,QAAL,CACJ,cADI,CACW,iBADX,EAEJ,cAFI,CAEW,qBAFX,CAAP;AAGD;;;gDAEwB;AACvB,aAAO,KAAK,QAAL,CACJ,cADI,CACW,sBADX,EAEJ,cAFI,CAEW,iBAFX,EAGJ,cAHI,CAGW,qBAHX,CAAP;AAID;;;mCAEc,Y,EAA0D;AAAA,UAApC,SAAoC,uEAAhB,gBAAgB;AACvE,aAAO,gBAAgB,CAAC,0BAAjB,CACL,KAAK,yBAAL,GAAiC,QAAjC,EADK,EAEL,YAFK,EAGL,SAHK,CAAP;AAKD;;;2CAEsB,a,EAAqB;AAC1C,UAAM,uBAAuB,GAAG,KAAK,0BAAL,EAAhC;AACA,aAAO,uBAAuB,CAAC,cAAxB,CAAuC,aAAvC,CAAP;AACD;;;;AAMD;;;;sCAIe;AACb,UAAM,uBAAuB,GAAG,KAAK,0BAAL,EAAhC;AACA,UAAM,YAAY,GAAG,gBAAgB,CAAC,uBAAD,CAArC;AACA,aAAO,MAAM,CAAC,UAAP,CAAkB,QAAlB,EAA4B,MAA5B,CAAmC,YAAnC,EAAiD,MAAjD,CAAwD,KAAxD,CAAP;AACD;AAED;;;;;;;;sCAKkB,Y,EAAoB;AACpC,aAAO,gBAAgB,CAAC,uBAAjB,CAAyC,KAAK,cAAL,CAAoB,YAApB,CAAzC,CAAP;AACD;AAED;;;;;;;;;;yCAOqB,Y,EAAoB;AACvC,aAAO,iBAAiB,CAAC,KAAK,cAAL,CAAoB,YAApB,CAAD,CAAxB;AACD;AAED;;;;;;;+CAIwB;AACtB,aAAO,KAAK,yBAAL,GAAiC,QAAjC,EAAP;AACD;AAED;;;;;;;gDAIyB;AACvB,aAAO,KAAK,0BAAL,GAAkC,QAAlC,EAAP;AACD;;;;AAkGD;;;;;;;;;;;;;;uCAcmB,Y,EACmC;AAAA,UAAnC,kBAAmC,uEAAL,KAAK;AACpD,UAAM,YAAY,GAAG,KAAK,sBAAL,CAA4B,YAA5B,CAArB;AAEA,UAAM,OAAO,GAAG,gBAAgB,CAAC,uBAAjB,CAAyC,YAAzC,CAAhB;AACA,UAAI,WAAW,GAAG,iBAAiB,CAAC,YAAD,CAAnC;;AACA,UAAI,kBAAkB,IAAI,WAAW,CAAC,MAAZ,KAAuB,EAAjD,EAAqD;AACnD,QAAA,WAAW,GAAG,WAAW,CAAC,KAAZ,CAAkB,CAAlB,EAAqB,EAArB,CAAd;AACD;;AAED,UAAM,aAAa,GAAG,gBAAgB,CAAC,YAAD,CAAtC;AACA,UAAM,WAAW,GAAG,gBAAgB,CAAC,WAAjB,CAA6B,YAA7B,EAA2C,QAA3C,EAApB;AACA,UAAM,IAAI,GAAG,KAAK,eAAL,EAAb;AACA,UAAM,OAAO,GAAG;AACd,QAAA,GAAG,EAAE,WADS;AAEd,QAAA,KAAK,EAAE,aAFO;AAGd,QAAA,OAAO,EAAP,OAHc;AAId,QAAA,WAAW,EAAX,WAJc;AAKd,QAAA,IAAI,EAAJ;AALc,OAAhB;AAOA,aAAO,OAAP;AACD;;;mCAxQqB,I,EAAY;AAChC,aAAO,IAAI,gBAAJ,CAAqB,eAAA,CAAA,KAAA,CAAM,QAAN,CAAe,IAAf,CAArB,CAAP;AACD;AAED;;;;;;;;;+BAMkB,Q,EAAgB;AAChC,aAAO,IAAI,gBAAJ,CAAqB,eAAA,CAAA,KAAA,CAAM,UAAN,CAAiB,QAAjB,CAArB,CAAP;AACD;AAED;;;;;;;;;;;;0CASmC,I,EAAc,Q,EAAgB;;;;;;;;;;;AAE5C,uBAAM,QAAA,CAAA,eAAA,CAAgB,IAAhB,EAAsB,QAAtB,CAAN;;;AAAX,gBAAA,Q;;AACO,uBAAM,KAAK,CAAC,cAAN,CAAqB,QAArB,CAAN;;;AAAP,gBAAA,I;iDACC,IAAI,gBAAJ,CAAqB,eAAA,CAAA,KAAA,CAAM,QAAN,CAAe,IAAf,CAArB,C;;;;;;sBAEH,YAAI,OAAJ,IAAe,YAAI,OAAJ,CAAY,UAAZ,CAAuB,aAAvB,C;;;;;sBACX,IAAI,KAAJ,CAAU,oBAAV,C;;;;;;;;;;;;AAKX;AAED;;;;;;;uCAIuB;AACrB,aAAO,KAAK,CAAC,gBAAN,CAAuB,GAAvB,EAA4B,MAAM,CAAC,WAAnC,CAAP;AACD;AAED;;;;;;;;;;oCAO6B,Q,EAAkB,Q,EAAgB;;;;;;;;;;AACrC,uBAAM,QAAA,CAAA,eAAA,CAAgB,QAAhB,EAA0B,QAA1B,CAAN;;;AAAlB,gBAAA,e;kDACC,eAAe,CAAC,QAAhB,CAAyB,KAAzB,C;;;;;;;;;AACR;;;gCA4BkB,Y,EAA4B;AAC7C,aAAO,YAAY,CAAC,cAAb,CAA4B,eAA5B,CAAP;AACD;;;+CAiDC,c,EACA,Y,EACoC;AAAA,UAApC,SAAoC,uEAAhB,gBAAgB;AAEpC,UAAI,KAAJ;;AACA,UAAI,SAAS,KAAK,gBAAlB,EAAoC;AAClC,QAAA,KAAK,GAAG,CAAR;AACD,OAFD,MAEO,IAAI,SAAS,KAAK,cAAlB,EAAkC;AACvC,QAAA,KAAK,GAAG,CAAR;AACD,OAFM,MAEA;AACL,cAAM,IAAI,KAAJ,CAAU,oBAAV,CAAN;AACD;;AACD,UAAM,QAAQ,GAAG,eAAA,CAAA,KAAA,CAAM,UAAN,CAAiB,cAAjB,CAAjB;AAEA,aAAO,QAAQ,CAAC,MAAT,CAAgB,KAAhB,EAAuB,MAAvB,CAA8B,YAA9B,CAAP;AACD;AAED;;;;;;;;;;;;kDASqC,c,EAAwB,Y,EACY;AAAA,UAApC,SAAoC,uEAAhB,gBAAgB;AACvE,aAAO,gBAAgB,CAAC,uBAAjB,CAAyC,gBAAgB,CAC7D,0BAD6C,CAClB,cADkB,EACF,YADE,EACY,SADZ,CAAzC,CAAP;AAED;AAED;;;;;;;;;;;;;;2CAW8B,W,EACA,I,EAAc,S,EAAiB;AAC3D,UAAM,IAAI,GAAG,MAAM,CAChB,UADU,CACC,QADD,EAEV,MAFU,WAEA,SAFA,SAEY,IAFZ,GAGV,MAHU,CAGH,KAHG,CAAb;AAIA,UAAM,QAAQ,GAAG,QAAQ,CAAC,IAAD,CAAzB;AACA,UAAM,OAAO,GAAG,eAAA,CAAA,KAAA,CAAM,UAAN,CAAiB,WAAjB,EAA8B,cAA9B,CAA6C,QAA7C,CAAhB;AACA,aAAO,iBAAiB,CAAC,OAAD,CAAjB,CAA2B,KAA3B,CAAiC,CAAjC,EAAoC,EAApC,CAAP;AACD;;;4CAE8B,I,EAAoB;AACjD,aAAO,eAAA,CAAA,QAAA,CAAS,KAAT,CAAe;AAAE,QAAA,MAAM,EAAE,IAAI,CAAC;AAAf,OAAf,EAA2C,OAAlD;AACD;AAED;;;;;;;;;;;;;;qCAWwB,W,EAAqB,I,EAAc,S,EAAiB;AAC1E,UAAM,IAAI,GAAG,MAAM,CAChB,UADU,CACC,QADD,EAEV,MAFU,WAEA,SAFA,SAEY,IAFZ,GAGV,MAHU,CAGH,KAHG,CAAb;AAIA,UAAM,aAAa,GAAa,EAAhC,CAL0E,CAM1E;AACA;;AACA,UAAI,IAAI,CAAC,MAAL,KAAgB,EAApB,EAAwB;AACtB,cAAM,IAAI,KAAJ,gDAAkD,IAAI,CAAC,MAAvD,EAAN;AACD;;AACD,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,EAApB,EAAwB,CAAC,EAAzB,EAA6B;AAAE;AAC7B;AACA;AACA,QAAA,aAAa,CAAC,IAAd,CAAmB,IAAI,CAAC,KAAL,CAAW,CAAC,GAAG,CAAf,EAAkB,CAAC,GAAG,CAAJ,GAAQ,CAA1B,CAAnB;AACD;;AACD,UAAI,OAAO,GAAG,eAAA,CAAA,KAAA,CAAM,UAAN,CAAiB,WAAjB,CAAd;AACA,MAAA,aAAa,CAAC,OAAd,CAAsB,UAAC,GAAD,EAAQ;AAC5B,YAAI,GAAG,CAAC,MAAJ,GAAa,CAAjB,EAAoB;AAClB,gBAAM,IAAI,KAAJ,CAAU,2BAAV,CAAN;AACD;;AACD,QAAA,OAAO,GAAG,OAAO,CAAC,cAAR,CAAuB,QAAQ,CAAC,GAAD,EAAM,EAAN,CAA/B,CAAV;AACD,OALD;AAMA,aAAO,iBAAiB,CAAC,OAAD,CAAjB,CAA2B,KAA3B,CAAiC,CAAjC,EAAoC,EAApC,CAAP;AACD;;;;;;AApPH,OAAA,CAAA,gBAAA,GAAA,gBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto = require(\"crypto\");\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\nconst bip39 = require(\"bip39\");\nconst utils_1 = require(\"./utils\");\nconst wallet_1 = require(\"./encryption/wallet\");\nconst APPS_NODE_INDEX = 0;\nconst IDENTITY_KEYCHAIN = 888;\nconst BLOCKSTACK_ON_BITCOIN = 0;\nconst BITCOIN_BIP_44_PURPOSE = 44;\nconst BITCOIN_COIN_TYPE = 0;\nconst BITCOIN_ACCOUNT_INDEX = 0;\nconst EXTERNAL_ADDRESS = 'EXTERNAL_ADDRESS';\nconst CHANGE_ADDRESS = 'CHANGE_ADDRESS';\n/**\n *\n * @ignore\n */\nfunction hashCode(string) {\n    let hash = 0;\n    if (string.length === 0)\n        return hash;\n    for (let i = 0; i < string.length; i++) {\n        const character = string.charCodeAt(i);\n        hash = (hash << 5) - hash + character;\n        hash &= hash;\n    }\n    return hash & 0x7fffffff;\n}\n/**\n *\n * @ignore\n */\nfunction getNodePrivateKey(node) {\n    return utils_1.ecPairToHexString(bitcoinjs_lib_1.ECPair.fromPrivateKey(node.privateKey));\n}\n/**\n *\n * @ignore\n */\nfunction getNodePublicKey(node) {\n    return node.publicKey.toString('hex');\n}\n/**\n * The `BlockstackWallet` class manages the hierarchical derivation\n * paths for a standard Blockstack client wallet. This includes paths\n * for Bitcoin payment address, Blockstack identity addresses, Blockstack\n * application specific addresses.\n *\n * @ignore\n */\nclass BlockstackWallet {\n    constructor(rootNode) {\n        this.rootNode = rootNode;\n    }\n    toBase58() {\n        return this.rootNode.toBase58();\n    }\n    /**\n     * Initialize a Blockstack wallet from a seed buffer\n     * @param {Buffer} seed - the input seed for initializing the root node\n     *  of the hierarchical wallet\n     * @return {BlockstackWallet} the constructed wallet\n     */\n    static fromSeedBuffer(seed) {\n        return new BlockstackWallet(bitcoinjs_lib_1.bip32.fromSeed(seed));\n    }\n    /**\n     * Initialize a Blockstack wallet from a base58 string\n     * @param {string} keychain - the Base58 string used to initialize\n     *  the root node of the hierarchical wallet\n     * @return {BlockstackWallet} the constructed wallet\n     */\n    static fromBase58(keychain) {\n        return new BlockstackWallet(bitcoinjs_lib_1.bip32.fromBase58(keychain));\n    }\n    /**\n     * Initialize a blockstack wallet from an encrypted phrase & password. Throws\n     * if the password is incorrect. Supports all formats of Blockstack phrases.\n     * @param {string} data - The encrypted phrase as a hex-encoded string\n     * @param {string} password - The plain password\n     * @return {Promise<BlockstackWallet>} the constructed wallet\n     *\n     * @ignore\n     */\n    static fromEncryptedMnemonic(data, password) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const mnemonic = yield wallet_1.decryptMnemonic(data, password);\n                const seed = yield bip39.mnemonicToSeed(mnemonic);\n                return new BlockstackWallet(bitcoinjs_lib_1.bip32.fromSeed(seed));\n            }\n            catch (err) {\n                if (err.message && err.message.startsWith('bad header;')) {\n                    throw new Error('Incorrect password');\n                }\n                else {\n                    throw err;\n                }\n            }\n        });\n    }\n    /**\n     * Generate a BIP-39 12 word mnemonic\n     * @return {Promise<string>} space-separated 12 word phrase\n     */\n    static generateMnemonic() {\n        return bip39.generateMnemonic(128, crypto.randomBytes);\n    }\n    /**\n     * Encrypt a mnemonic phrase with a password\n     * @param {string} mnemonic - Raw mnemonic phrase\n     * @param {string} password - Password to encrypt mnemonic with\n     * @return {Promise<string>} Hex-encoded encrypted mnemonic\n     *\n     */\n    static encryptMnemonic(mnemonic, password) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const encryptedBuffer = yield wallet_1.encryptMnemonic(mnemonic, password);\n            return encryptedBuffer.toString('hex');\n        });\n    }\n    getIdentityPrivateKeychain() {\n        return this.rootNode\n            .deriveHardened(IDENTITY_KEYCHAIN)\n            .deriveHardened(BLOCKSTACK_ON_BITCOIN);\n    }\n    getBitcoinPrivateKeychain() {\n        return this.rootNode\n            .deriveHardened(BITCOIN_BIP_44_PURPOSE)\n            .deriveHardened(BITCOIN_COIN_TYPE)\n            .deriveHardened(BITCOIN_ACCOUNT_INDEX);\n    }\n    getBitcoinNode(addressIndex, chainType = EXTERNAL_ADDRESS) {\n        return BlockstackWallet.getNodeFromBitcoinKeychain(this.getBitcoinPrivateKeychain().toBase58(), addressIndex, chainType);\n    }\n    getIdentityAddressNode(identityIndex) {\n        const identityPrivateKeychain = this.getIdentityPrivateKeychain();\n        return identityPrivateKeychain.deriveHardened(identityIndex);\n    }\n    static getAppsNode(identityNode) {\n        return identityNode.deriveHardened(APPS_NODE_INDEX);\n    }\n    /**\n     * Get a salt for use with creating application specific addresses\n     * @return {String} the salt\n     */\n    getIdentitySalt() {\n        const identityPrivateKeychain = this.getIdentityPrivateKeychain();\n        const publicKeyHex = getNodePublicKey(identityPrivateKeychain);\n        return crypto.createHash('sha256').update(publicKeyHex).digest('hex');\n    }\n    /**\n     * Get a bitcoin receive address at a given index\n     * @param {number} addressIndex - the index of the address\n     * @return {String} address\n     */\n    getBitcoinAddress(addressIndex) {\n        return BlockstackWallet.getAddressFromBIP32Node(this.getBitcoinNode(addressIndex));\n    }\n    /**\n     * Get the private key hex-string for a given bitcoin receive address\n     * @param {number} addressIndex - the index of the address\n     * @return {String} the hex-string. this will be either 64\n     * characters long to denote an uncompressed bitcoin address, or 66\n     * characters long for a compressed bitcoin address.\n     */\n    getBitcoinPrivateKey(addressIndex) {\n        return getNodePrivateKey(this.getBitcoinNode(addressIndex));\n    }\n    /**\n     * Get the root node for the bitcoin public keychain\n     * @return {String} base58-encoding of the public node\n     */\n    getBitcoinPublicKeychain() {\n        return this.getBitcoinPrivateKeychain().neutered();\n    }\n    /**\n     * Get the root node for the identity public keychain\n     * @return {String} base58-encoding of the public node\n     */\n    getIdentityPublicKeychain() {\n        return this.getIdentityPrivateKeychain().neutered();\n    }\n    static getNodeFromBitcoinKeychain(keychainBase58, addressIndex, chainType = EXTERNAL_ADDRESS) {\n        let chain;\n        if (chainType === EXTERNAL_ADDRESS) {\n            chain = 0;\n        }\n        else if (chainType === CHANGE_ADDRESS) {\n            chain = 1;\n        }\n        else {\n            throw new Error('Invalid chain type');\n        }\n        const keychain = bitcoinjs_lib_1.bip32.fromBase58(keychainBase58);\n        return keychain.derive(chain).derive(addressIndex);\n    }\n    /**\n     * Get a bitcoin address given a base-58 encoded bitcoin node\n     * (usually called the account node)\n     * @param {String} keychainBase58 - base58-encoding of the node\n     * @param {number} addressIndex - index of the address to get\n     * @param {String} chainType - either 'EXTERNAL_ADDRESS' (for a\n     * \"receive\" address) or 'CHANGE_ADDRESS'\n     * @return {String} the address\n     */\n    static getAddressFromBitcoinKeychain(keychainBase58, addressIndex, chainType = EXTERNAL_ADDRESS) {\n        return BlockstackWallet.getAddressFromBIP32Node(BlockstackWallet\n            .getNodeFromBitcoinKeychain(keychainBase58, addressIndex, chainType));\n    }\n    /**\n     * Get a ECDSA private key hex-string for an application-specific\n     *  address.\n     * @param {String} appsNodeKey - the base58-encoded private key for\n     * applications node (the `appsNodeKey` return in getIdentityKeyPair())\n     * @param {String} salt - a string, used to salt the\n     * application-specific addresses\n     * @param {String} appDomain - the appDomain to generate a key for\n     * @return {String} the private key hex-string. this will be a 64\n     * character string\n     */\n    static getLegacyAppPrivateKey(appsNodeKey, salt, appDomain) {\n        const hash = crypto\n            .createHash('sha256')\n            .update(`${appDomain}${salt}`)\n            .digest('hex');\n        const appIndex = hashCode(hash);\n        const appNode = bitcoinjs_lib_1.bip32.fromBase58(appsNodeKey).deriveHardened(appIndex);\n        return getNodePrivateKey(appNode).slice(0, 64);\n    }\n    static getAddressFromBIP32Node(node) {\n        return bitcoinjs_lib_1.payments.p2pkh({ pubkey: node.publicKey }).address;\n    }\n    /**\n     * Get a ECDSA private key hex-string for an application-specific\n     *  address.\n     * @param {String} appsNodeKey - the base58-encoded private key for\n     * applications node (the `appsNodeKey` return in getIdentityKeyPair())\n     * @param {String} salt - a string, used to salt the\n     * application-specific addresses\n     * @param {String} appDomain - the appDomain to generate a key for\n     * @return {String} the private key hex-string. this will be a 64\n     * character string\n     */\n    static getAppPrivateKey(appsNodeKey, salt, appDomain) {\n        const hash = crypto\n            .createHash('sha256')\n            .update(`${appDomain}${salt}`)\n            .digest('hex');\n        const appIndexHexes = [];\n        // note: there's hardcoded numbers here, precisely because I want this\n        //   code to be very specific to the derivation paths we expect.\n        if (hash.length !== 64) {\n            throw new Error(`Unexpected app-domain hash length of ${hash.length}`);\n        }\n        for (let i = 0; i < 11; i++) { // split the hash into 3-byte chunks\n            // because child nodes can only be up to 2^31,\n            // and we shouldn't deal in partial bytes.\n            appIndexHexes.push(hash.slice(i * 6, i * 6 + 6));\n        }\n        let appNode = bitcoinjs_lib_1.bip32.fromBase58(appsNodeKey);\n        appIndexHexes.forEach((hex) => {\n            if (hex.length > 6) {\n                throw new Error('Invalid hex string length');\n            }\n            appNode = appNode.deriveHardened(parseInt(hex, 16));\n        });\n        return getNodePrivateKey(appNode).slice(0, 64);\n    }\n    /**\n     * Get the keypair information for a given identity index. This\n     * information is used to obtain the private key for an identity address\n     * and derive application specific keys for that address.\n     * @param {number} addressIndex - the identity index\n     * @param {boolean} alwaysUncompressed - if true, always return a\n     *   private-key hex string corresponding to the uncompressed address\n     * @return {Object} an IdentityKeyPair type object with keys:\n     *   .key {String} - the private key hex-string\n     *   .keyID {String} - the public key hex-string\n     *   .address {String} - the identity address\n     *   .appsNodeKey {String} - the base-58 encoding of the applications node\n     *   .salt {String} - the salt used for creating app-specific addresses\n     */\n    getIdentityKeyPair(addressIndex, alwaysUncompressed = false) {\n        const identityNode = this.getIdentityAddressNode(addressIndex);\n        const address = BlockstackWallet.getAddressFromBIP32Node(identityNode);\n        let identityKey = getNodePrivateKey(identityNode);\n        if (alwaysUncompressed && identityKey.length === 66) {\n            identityKey = identityKey.slice(0, 64);\n        }\n        const identityKeyID = getNodePublicKey(identityNode);\n        const appsNodeKey = BlockstackWallet.getAppsNode(identityNode).toBase58();\n        const salt = this.getIdentitySalt();\n        const keyPair = {\n            key: identityKey,\n            keyID: identityKeyID,\n            address,\n            appsNodeKey,\n            salt\n        };\n        return keyPair;\n    }\n}\nexports.BlockstackWallet = BlockstackWallet;\n//# sourceMappingURL=wallet.js.map"]},"metadata":{},"sourceType":"script"}