{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\n\nvar RIPEMD160 = require(\"ripemd160\"); // @ts-ignore\n\n\nvar BN = require(\"bn.js\");\n\nvar errors_1 = require(\"../errors\");\n/**\n *\n * @ignore\n */\n\n\nexports.DUST_MINIMUM = 5500;\n/**\n *\n * @ignore\n */\n\nfunction hash160(buff) {\n  var sha256 = bitcoinjs_lib_1.crypto.sha256(buff);\n  return new RIPEMD160().update(sha256).digest();\n}\n\nexports.hash160 = hash160;\n/**\n *\n * @ignore\n */\n\nfunction hash128(buff) {\n  return Buffer.from(bitcoinjs_lib_1.crypto.sha256(buff).slice(0, 16));\n}\n\nexports.hash128 = hash128; // COPIED FROM coinselect, because 1 byte matters sometimes.\n// baseline estimates, used to improve performance\n\nvar TX_EMPTY_SIZE = 4 + 1 + 1 + 4;\nvar TX_INPUT_BASE = 32 + 4 + 1 + 4;\nvar TX_INPUT_PUBKEYHASH = 107;\nvar TX_OUTPUT_BASE = 8 + 1;\nvar TX_OUTPUT_PUBKEYHASH = 25;\n\nfunction inputBytes(input) {\n  if (input && input.script && input.script.length > 0) {\n    return TX_INPUT_BASE + input.script.length;\n  } else {\n    return TX_INPUT_BASE + TX_INPUT_PUBKEYHASH;\n  }\n}\n\nfunction outputBytes(output) {\n  if (output && output.script && output.script.length > 0) {\n    return TX_OUTPUT_BASE + output.script.length;\n  } else {\n    return TX_OUTPUT_BASE + TX_OUTPUT_PUBKEYHASH;\n  }\n}\n\nfunction transactionBytes(inputs, outputs) {\n  return TX_EMPTY_SIZE + inputs.reduce(function (a, x) {\n    return a + inputBytes(x);\n  }, 0) + outputs.reduce(function (a, x) {\n    return a + outputBytes(x);\n  }, 0);\n}\n/**\n *\n * @ignore\n */\n\n\nfunction getTransactionInsideBuilder(txBuilder) {\n  return txBuilder.__TX;\n}\n\nexports.getTransactionInsideBuilder = getTransactionInsideBuilder;\n\nfunction getTransaction(txIn) {\n  if (txIn instanceof bitcoinjs_lib_1.Transaction) {\n    return txIn;\n  }\n\n  return getTransactionInsideBuilder(txIn);\n} //\n\n/**\n *\n * @ignore\n */\n\n\nfunction estimateTXBytes(txIn, additionalInputs, additionalOutputs) {\n  var innerTx = getTransaction(txIn);\n  var dummyInputs = new Array(additionalInputs);\n  dummyInputs.fill(null);\n  var dummyOutputs = new Array(additionalOutputs);\n  dummyOutputs.fill(null);\n  var inputs = [].concat(innerTx.ins, dummyInputs);\n  var outputs = [].concat(innerTx.outs, dummyOutputs);\n  return transactionBytes(inputs, outputs);\n}\n\nexports.estimateTXBytes = estimateTXBytes;\n/**\n *\n * @ignore\n */\n\nfunction sumOutputValues(txIn) {\n  var innerTx = getTransaction(txIn);\n  return innerTx.outs.reduce(function (agg, x) {\n    return agg + x.value;\n  }, 0);\n}\n\nexports.sumOutputValues = sumOutputValues;\n/**\n *\n * @ignore\n */\n\nfunction decodeB40(input) {\n  // treat input as a base40 integer, and output a hex encoding\n  // of that integer.\n  //\n  //   for each digit of the string, find its location in `characters`\n  //    to get the value of the digit, then multiply by 40^(-index in input)\n  // e.g.,\n  // the 'right-most' character has value: (digit-value) * 40^0\n  //  the next character has value: (digit-value) * 40^1\n  //\n  // hence, we reverse the characters first, and use the index\n  //  to compute the value of each digit, then sum\n  var characters = '0123456789abcdefghijklmnopqrstuvwxyz-_.+';\n  var base = new BN(40);\n  var inputDigits = input.split('').reverse();\n  var digitValues = inputDigits.map(function (character, exponent) {\n    return new BN(characters.indexOf(character)).mul(base.pow(new BN(exponent)));\n  });\n  var sum = digitValues.reduce(function (agg, cur) {\n    return agg.add(cur);\n  }, new BN(0));\n  return sum.toString(16, 2);\n}\n\nexports.decodeB40 = decodeB40;\n/**\n * Adds UTXOs to fund a transaction\n * @param {TransactionBuilder} txBuilderIn - a transaction builder object to add the inputs to. this\n *    object is _always_ mutated. If not enough UTXOs exist to fund, the tx builder object\n *    will still contain as many inputs as could be found.\n * @param {Array<{value: number, tx_hash: string, tx_output_n}>} utxos - the utxo set for the\n *    payer's address.\n * @param {number} amountToFund - the amount of satoshis to fund in the transaction. the payer's\n *    utxos will be included to fund up to this amount of *output* and the corresponding *fees*\n *    for those additional inputs\n * @param {number} feeRate - the satoshis/byte fee rate to use for fee calculation\n * @param {boolean} fundNewFees - if true, this function will fund `amountToFund` and any new fees\n *    associated with including the new inputs.\n *    if false, this function will fund _at most_ `amountToFund`\n * @returns {number} - the amount of leftover change (in satoshis)\n * @private\n * @ignore\n */\n\nfunction addUTXOsToFund(txBuilderIn, utxos, amountToFund, feeRate) {\n  var fundNewFees = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n  if (utxos.length === 0) {\n    throw new errors_1.NotEnoughFundsError(amountToFund);\n  } // how much are we increasing fees by adding an input ?\n\n\n  var newFees = feeRate * (estimateTXBytes(txBuilderIn, 1, 0) - estimateTXBytes(txBuilderIn, 0, 0));\n  var utxoThreshhold = amountToFund;\n\n  if (fundNewFees) {\n    utxoThreshhold += newFees;\n  }\n\n  var goodUtxos = utxos.filter(function (utxo) {\n    return utxo.value >= utxoThreshhold;\n  });\n\n  if (goodUtxos.length > 0) {\n    goodUtxos.sort(function (a, b) {\n      return a.value - b.value;\n    });\n    var selected = goodUtxos[0];\n    var change = selected.value - amountToFund;\n\n    if (fundNewFees) {\n      change -= newFees;\n    }\n\n    txBuilderIn.addInput(selected.tx_hash, selected.tx_output_n);\n    return change;\n  } else {\n    utxos.sort(function (a, b) {\n      return b.value - a.value;\n    });\n    var largest = utxos[0];\n\n    if (newFees >= largest.value) {\n      throw new errors_1.NotEnoughFundsError(amountToFund);\n    }\n\n    txBuilderIn.addInput(largest.tx_hash, largest.tx_output_n);\n    var remainToFund = amountToFund - largest.value;\n\n    if (fundNewFees) {\n      remainToFund += newFees;\n    }\n\n    return addUTXOsToFund(txBuilderIn, utxos.slice(1), remainToFund, feeRate, fundNewFees);\n  }\n}\n\nexports.addUTXOsToFund = addUTXOsToFund;\n\nfunction signInputs(txB, defaultSigner, otherSigners) {\n  var txInner = getTransactionInsideBuilder(txB);\n  var signerArray = txInner.ins.map(function () {\n    return defaultSigner;\n  });\n\n  if (otherSigners) {\n    otherSigners.forEach(function (signerPair) {\n      signerArray[signerPair.index] = signerPair.signer;\n    });\n  }\n\n  var signingPromise = Promise.resolve();\n\n  var _loop = function _loop(i) {\n    signingPromise = signingPromise.then(function () {\n      return signerArray[i].signTransaction(txB, i);\n    });\n  };\n\n  for (var i = 0; i < txInner.ins.length; i++) {\n    _loop(i);\n  }\n\n  return signingPromise.then(function () {\n    return txB;\n  });\n}\n\nexports.signInputs = signInputs;","map":{"version":3,"sources":["../../src/operations/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\nconst RIPEMD160 = require(\"ripemd160\");\n// @ts-ignore\nconst BN = require(\"bn.js\");\nconst errors_1 = require(\"../errors\");\n/**\n *\n * @ignore\n */\nexports.DUST_MINIMUM = 5500;\n/**\n *\n * @ignore\n */\nfunction hash160(buff) {\n    const sha256 = bitcoinjs_lib_1.crypto.sha256(buff);\n    return (new RIPEMD160()).update(sha256).digest();\n}\nexports.hash160 = hash160;\n/**\n *\n * @ignore\n */\nfunction hash128(buff) {\n    return Buffer.from(bitcoinjs_lib_1.crypto.sha256(buff).slice(0, 16));\n}\nexports.hash128 = hash128;\n// COPIED FROM coinselect, because 1 byte matters sometimes.\n// baseline estimates, used to improve performance\nconst TX_EMPTY_SIZE = 4 + 1 + 1 + 4;\nconst TX_INPUT_BASE = 32 + 4 + 1 + 4;\nconst TX_INPUT_PUBKEYHASH = 107;\nconst TX_OUTPUT_BASE = 8 + 1;\nconst TX_OUTPUT_PUBKEYHASH = 25;\nfunction inputBytes(input) {\n    if (input && input.script && input.script.length > 0) {\n        return TX_INPUT_BASE + input.script.length;\n    }\n    else {\n        return TX_INPUT_BASE + TX_INPUT_PUBKEYHASH;\n    }\n}\nfunction outputBytes(output) {\n    if (output && output.script && output.script.length > 0) {\n        return TX_OUTPUT_BASE + output.script.length;\n    }\n    else {\n        return TX_OUTPUT_BASE + TX_OUTPUT_PUBKEYHASH;\n    }\n}\nfunction transactionBytes(inputs, outputs) {\n    return TX_EMPTY_SIZE\n        + inputs.reduce((a, x) => (a + inputBytes(x)), 0)\n        + outputs.reduce((a, x) => (a + outputBytes(x)), 0);\n}\n/**\n *\n * @ignore\n */\nfunction getTransactionInsideBuilder(txBuilder) {\n    return txBuilder.__TX;\n}\nexports.getTransactionInsideBuilder = getTransactionInsideBuilder;\nfunction getTransaction(txIn) {\n    if (txIn instanceof bitcoinjs_lib_1.Transaction) {\n        return txIn;\n    }\n    return getTransactionInsideBuilder(txIn);\n}\n//\n/**\n *\n * @ignore\n */\nfunction estimateTXBytes(txIn, additionalInputs, additionalOutputs) {\n    const innerTx = getTransaction(txIn);\n    const dummyInputs = new Array(additionalInputs);\n    dummyInputs.fill(null);\n    const dummyOutputs = new Array(additionalOutputs);\n    dummyOutputs.fill(null);\n    const inputs = [].concat(innerTx.ins, dummyInputs);\n    const outputs = [].concat(innerTx.outs, dummyOutputs);\n    return transactionBytes(inputs, outputs);\n}\nexports.estimateTXBytes = estimateTXBytes;\n/**\n *\n * @ignore\n */\nfunction sumOutputValues(txIn) {\n    const innerTx = getTransaction(txIn);\n    return innerTx.outs.reduce((agg, x) => agg + x.value, 0);\n}\nexports.sumOutputValues = sumOutputValues;\n/**\n *\n * @ignore\n */\nfunction decodeB40(input) {\n    // treat input as a base40 integer, and output a hex encoding\n    // of that integer.\n    //\n    //   for each digit of the string, find its location in `characters`\n    //    to get the value of the digit, then multiply by 40^(-index in input)\n    // e.g.,\n    // the 'right-most' character has value: (digit-value) * 40^0\n    //  the next character has value: (digit-value) * 40^1\n    //\n    // hence, we reverse the characters first, and use the index\n    //  to compute the value of each digit, then sum\n    const characters = '0123456789abcdefghijklmnopqrstuvwxyz-_.+';\n    const base = new BN(40);\n    const inputDigits = input.split('').reverse();\n    const digitValues = inputDigits.map(((character, exponent) => new BN(characters.indexOf(character))\n        .mul(base.pow(new BN(exponent)))));\n    const sum = digitValues.reduce((agg, cur) => agg.add(cur), new BN(0));\n    return sum.toString(16, 2);\n}\nexports.decodeB40 = decodeB40;\n/**\n * Adds UTXOs to fund a transaction\n * @param {TransactionBuilder} txBuilderIn - a transaction builder object to add the inputs to. this\n *    object is _always_ mutated. If not enough UTXOs exist to fund, the tx builder object\n *    will still contain as many inputs as could be found.\n * @param {Array<{value: number, tx_hash: string, tx_output_n}>} utxos - the utxo set for the\n *    payer's address.\n * @param {number} amountToFund - the amount of satoshis to fund in the transaction. the payer's\n *    utxos will be included to fund up to this amount of *output* and the corresponding *fees*\n *    for those additional inputs\n * @param {number} feeRate - the satoshis/byte fee rate to use for fee calculation\n * @param {boolean} fundNewFees - if true, this function will fund `amountToFund` and any new fees\n *    associated with including the new inputs.\n *    if false, this function will fund _at most_ `amountToFund`\n * @returns {number} - the amount of leftover change (in satoshis)\n * @private\n * @ignore\n */\nfunction addUTXOsToFund(txBuilderIn, utxos, amountToFund, feeRate, fundNewFees = true) {\n    if (utxos.length === 0) {\n        throw new errors_1.NotEnoughFundsError(amountToFund);\n    }\n    // how much are we increasing fees by adding an input ?\n    const newFees = feeRate * (estimateTXBytes(txBuilderIn, 1, 0)\n        - estimateTXBytes(txBuilderIn, 0, 0));\n    let utxoThreshhold = amountToFund;\n    if (fundNewFees) {\n        utxoThreshhold += newFees;\n    }\n    const goodUtxos = utxos.filter(utxo => utxo.value >= utxoThreshhold);\n    if (goodUtxos.length > 0) {\n        goodUtxos.sort((a, b) => a.value - b.value);\n        const selected = goodUtxos[0];\n        let change = selected.value - amountToFund;\n        if (fundNewFees) {\n            change -= newFees;\n        }\n        txBuilderIn.addInput(selected.tx_hash, selected.tx_output_n);\n        return change;\n    }\n    else {\n        utxos.sort((a, b) => b.value - a.value);\n        const largest = utxos[0];\n        if (newFees >= largest.value) {\n            throw new errors_1.NotEnoughFundsError(amountToFund);\n        }\n        txBuilderIn.addInput(largest.tx_hash, largest.tx_output_n);\n        let remainToFund = amountToFund - largest.value;\n        if (fundNewFees) {\n            remainToFund += newFees;\n        }\n        return addUTXOsToFund(txBuilderIn, utxos.slice(1), remainToFund, feeRate, fundNewFees);\n    }\n}\nexports.addUTXOsToFund = addUTXOsToFund;\nfunction signInputs(txB, defaultSigner, otherSigners) {\n    const txInner = getTransactionInsideBuilder(txB);\n    const signerArray = txInner.ins.map(() => defaultSigner);\n    if (otherSigners) {\n        otherSigners.forEach((signerPair) => {\n            signerArray[signerPair.index] = signerPair.signer;\n        });\n    }\n    let signingPromise = Promise.resolve();\n    for (let i = 0; i < txInner.ins.length; i++) {\n        signingPromise = signingPromise.then(() => signerArray[i].signTransaction(txB, i));\n    }\n    return signingPromise.then(() => txB);\n}\nexports.signInputs = signInputs;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}