{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // @ts-ignore: Could not find a declaration file for module\n\nvar jsontokens_1 = require(\"jsontokens\");\n\nrequire(\"cross-fetch/polyfill\");\n\nvar fetchUtil_1 = require(\"../fetchUtil\");\n/**\n * Create an authentication token to be sent to the Core API server\n * in order to generate a Core session JWT.\n *\n * @param {String} appDomain  The unique application identifier (e.g. foo.app, www.foo.com, etc).\n * @param {Array} appMethods  The list of API methods this application will need.\n * @param {String} appPrivateKey  The application-specific private key\n * @param {String|null} blockchainID  This is the blockchain ID of the requester\n * @param {String} thisDevice Identifier of the current device\n *\n * @return {String} a JWT signed by the app's private key\n * @deprecated\n * @private\n * @ignore\n */\n\n\nfunction makeCoreSessionRequest(appDomain, appMethods, appPrivateKey) {\n  var blockchainID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var thisDevice = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n  if (thisDevice === null) {\n    thisDevice = '.default';\n  }\n\n  var appPublicKey = jsontokens_1.SECP256K1Client.derivePublicKey(appPrivateKey);\n  var appPublicKeys = [{\n    public_key: appPublicKey,\n    device_id: thisDevice\n  }];\n  var authBody = {\n    version: 1,\n    blockchain_id: blockchainID,\n    app_private_key: appPrivateKey,\n    app_domain: appDomain,\n    methods: appMethods,\n    app_public_keys: appPublicKeys,\n    device_id: thisDevice\n  }; // make token\n\n  var tokenSigner = new jsontokens_1.TokenSigner('ES256k', appPrivateKey);\n  var token = tokenSigner.sign(authBody);\n  return token;\n}\n\nexports.makeCoreSessionRequest = makeCoreSessionRequest;\n/**\n * Send Core a request for a session token.\n *\n * @param {String} coreHost host name of the core node\n * @param {Number} corePort port number of the core node\n * @param {String} coreAuthRequest  a signed JWT encoding the authentication request\n * @param {String} apiPassword the API password for Core\n *\n * @return {Promise} the resolves to a JWT signed with the Core API server's private key\n * that authorizes the bearer to carry out the requested operations and rejects\n * with an error message otherwise\n * @deprecated\n * @private\n * @ignore\n */\n\nfunction sendCoreSessionRequest(coreHost, corePort, coreAuthRequest, apiPassword) {\n  return Promise.resolve().then(function () {\n    if (!apiPassword) {\n      throw new Error('Missing API password');\n    }\n  }).then(function () {\n    var options = {\n      headers: {\n        Authorization: \"bearer \".concat(apiPassword)\n      }\n    };\n    var url = \"http://\".concat(coreHost, \":\").concat(corePort, \"/v1/auth?authRequest=\").concat(coreAuthRequest);\n    return fetchUtil_1.fetchPrivate(url, options);\n  }).then(function (response) {\n    if (!response.ok) {\n      throw new Error('HTTP status not OK');\n    }\n\n    return response.text();\n  }).then(function (responseText) {\n    var responseJson = JSON.parse(responseText);\n    var token = responseJson.token;\n\n    if (!token) {\n      throw new Error('Failed to get Core session token');\n    }\n\n    return token;\n  }).catch(function (error) {\n    console.error(error);\n    throw new Error('Invalid Core response: not JSON');\n  });\n}\n\nexports.sendCoreSessionRequest = sendCoreSessionRequest;\n/**\n * Get a core session token.  Generate an auth request, sign it, send it to Core,\n * and get back a session token.\n *\n * @param {String} coreHost Core API server's hostname\n * @param {Number} corePort Core API server's port number\n * @param {String} apiPassword core api password\n * @param  {String} appPrivateKey Application's private key\n * @param  {String} blockchainId blockchain ID of the user signing in.\n * `null` if user has no blockchain ID\n * @param {String} authRequest authentication request token\n * @param {String} deviceId identifier for the current device\n *\n * @return {Promise} a Promise that resolves to a Core session token or rejects\n * with an error message.\n * @deprecated\n * @private\n * @ignore\n */\n\nfunction getCoreSession(coreHost, corePort, apiPassword, appPrivateKey) {\n  var blockchainId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var authRequest = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var deviceId = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : '0';\n\n  if (!authRequest) {\n    return Promise.reject('No authRequest provided');\n  }\n\n  try {\n    var authRequestObject = jsontokens_1.decodeToken(authRequest);\n\n    if (!authRequestObject) {\n      return Promise.reject('Invalid authRequest in URL query string');\n    }\n\n    if (!authRequestObject.payload) {\n      return Promise.reject('Invalid authRequest in URL query string');\n    }\n\n    var payload = authRequestObject.payload;\n\n    if (typeof payload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n\n    var appDomain = payload.domain_name;\n\n    if (!appDomain) {\n      return Promise.reject('No domain_name in authRequest');\n    }\n\n    var appMethods = payload.scopes;\n    var coreAuthRequest = makeCoreSessionRequest(appDomain, appMethods, appPrivateKey, blockchainId, deviceId);\n    return sendCoreSessionRequest(coreHost, corePort, coreAuthRequest, apiPassword);\n  } catch (e) {\n    console.error(e.stack);\n    return Promise.reject('Failed to parse authRequest in URL');\n  }\n}\n\nexports.getCoreSession = getCoreSession;","map":{"version":3,"sources":["../../src/auth/authSession.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// @ts-ignore: Could not find a declaration file for module\nconst jsontokens_1 = require(\"jsontokens\");\nrequire(\"cross-fetch/polyfill\");\nconst fetchUtil_1 = require(\"../fetchUtil\");\n/**\n * Create an authentication token to be sent to the Core API server\n * in order to generate a Core session JWT.\n *\n * @param {String} appDomain  The unique application identifier (e.g. foo.app, www.foo.com, etc).\n * @param {Array} appMethods  The list of API methods this application will need.\n * @param {String} appPrivateKey  The application-specific private key\n * @param {String|null} blockchainID  This is the blockchain ID of the requester\n * @param {String} thisDevice Identifier of the current device\n *\n * @return {String} a JWT signed by the app's private key\n * @deprecated\n * @private\n * @ignore\n */\nfunction makeCoreSessionRequest(appDomain, appMethods, appPrivateKey, blockchainID = null, thisDevice = null) {\n    if (thisDevice === null) {\n        thisDevice = '.default';\n    }\n    const appPublicKey = jsontokens_1.SECP256K1Client.derivePublicKey(appPrivateKey);\n    const appPublicKeys = [{\n            public_key: appPublicKey,\n            device_id: thisDevice\n        }];\n    const authBody = {\n        version: 1,\n        blockchain_id: blockchainID,\n        app_private_key: appPrivateKey,\n        app_domain: appDomain,\n        methods: appMethods,\n        app_public_keys: appPublicKeys,\n        device_id: thisDevice\n    };\n    // make token\n    const tokenSigner = new jsontokens_1.TokenSigner('ES256k', appPrivateKey);\n    const token = tokenSigner.sign(authBody);\n    return token;\n}\nexports.makeCoreSessionRequest = makeCoreSessionRequest;\n/**\n * Send Core a request for a session token.\n *\n * @param {String} coreHost host name of the core node\n * @param {Number} corePort port number of the core node\n * @param {String} coreAuthRequest  a signed JWT encoding the authentication request\n * @param {String} apiPassword the API password for Core\n *\n * @return {Promise} the resolves to a JWT signed with the Core API server's private key\n * that authorizes the bearer to carry out the requested operations and rejects\n * with an error message otherwise\n * @deprecated\n * @private\n * @ignore\n */\nfunction sendCoreSessionRequest(coreHost, corePort, coreAuthRequest, apiPassword) {\n    return Promise.resolve().then(() => {\n        if (!apiPassword) {\n            throw new Error('Missing API password');\n        }\n    })\n        .then(() => {\n        const options = {\n            headers: {\n                Authorization: `bearer ${apiPassword}`\n            }\n        };\n        const url = `http://${coreHost}:${corePort}/v1/auth?authRequest=${coreAuthRequest}`;\n        return fetchUtil_1.fetchPrivate(url, options);\n    })\n        .then((response) => {\n        if (!response.ok) {\n            throw new Error('HTTP status not OK');\n        }\n        return response.text();\n    })\n        .then((responseText) => {\n        const responseJson = JSON.parse(responseText);\n        const token = responseJson.token;\n        if (!token) {\n            throw new Error('Failed to get Core session token');\n        }\n        return token;\n    })\n        .catch((error) => {\n        console.error(error);\n        throw new Error('Invalid Core response: not JSON');\n    });\n}\nexports.sendCoreSessionRequest = sendCoreSessionRequest;\n/**\n * Get a core session token.  Generate an auth request, sign it, send it to Core,\n * and get back a session token.\n *\n * @param {String} coreHost Core API server's hostname\n * @param {Number} corePort Core API server's port number\n * @param {String} apiPassword core api password\n * @param  {String} appPrivateKey Application's private key\n * @param  {String} blockchainId blockchain ID of the user signing in.\n * `null` if user has no blockchain ID\n * @param {String} authRequest authentication request token\n * @param {String} deviceId identifier for the current device\n *\n * @return {Promise} a Promise that resolves to a Core session token or rejects\n * with an error message.\n * @deprecated\n * @private\n * @ignore\n */\nfunction getCoreSession(coreHost, corePort, apiPassword, appPrivateKey, blockchainId = null, authRequest = null, deviceId = '0') {\n    if (!authRequest) {\n        return Promise.reject('No authRequest provided');\n    }\n    try {\n        const authRequestObject = jsontokens_1.decodeToken(authRequest);\n        if (!authRequestObject) {\n            return Promise.reject('Invalid authRequest in URL query string');\n        }\n        if (!authRequestObject.payload) {\n            return Promise.reject('Invalid authRequest in URL query string');\n        }\n        const payload = authRequestObject.payload;\n        if (typeof payload === 'string') {\n            throw new Error('Unexpected token payload type of string');\n        }\n        const appDomain = payload.domain_name;\n        if (!appDomain) {\n            return Promise.reject('No domain_name in authRequest');\n        }\n        const appMethods = payload.scopes;\n        const coreAuthRequest = makeCoreSessionRequest(appDomain, appMethods, appPrivateKey, blockchainId, deviceId);\n        return sendCoreSessionRequest(coreHost, corePort, coreAuthRequest, apiPassword);\n    }\n    catch (e) {\n        console.error(e.stack);\n        return Promise.reject('Failed to parse authRequest in URL');\n    }\n}\nexports.getCoreSession = getCoreSession;\n//# sourceMappingURL=authSession.js.map"]},"metadata":{},"sourceType":"script"}