{"ast":null,"code":"\"use strict\";\n\nvar _possibleConstructorReturn = require(\"/home/aashan/2048/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/aashan/2048/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/aashan/2048/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _slicedToArray = require(\"/home/aashan/2048/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/home/aashan/2048/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/aashan/2048/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\n\nvar FormData = require(\"form-data\"); // @ts-ignore\n\n\nvar BN = require(\"bn.js\");\n\nvar RIPEMD160 = require(\"ripemd160\");\n\nvar errors_1 = require(\"./errors\");\n\nvar logger_1 = require(\"./logger\");\n\nvar config_1 = require(\"./config\");\n\nvar fetchUtil_1 = require(\"./fetchUtil\");\n\nvar SATOSHIS_PER_BTC = 1e8;\nvar TX_BROADCAST_SERVICE_ZONE_FILE_ENDPOINT = 'zone-file';\nvar TX_BROADCAST_SERVICE_REGISTRATION_ENDPOINT = 'registration';\nvar TX_BROADCAST_SERVICE_TX_ENDPOINT = 'transaction';\n/**\n * @private\n * @ignore\n */\n\nvar BitcoinNetwork =\n/*#__PURE__*/\nfunction () {\n  function BitcoinNetwork() {\n    _classCallCheck(this, BitcoinNetwork);\n  }\n\n  _createClass(BitcoinNetwork, [{\n    key: \"broadcastTransaction\",\n    value: function broadcastTransaction(transaction) {\n      return Promise.reject(new Error(\"Not implemented, broadcastTransaction(\".concat(transaction, \")\")));\n    }\n  }, {\n    key: \"getBlockHeight\",\n    value: function getBlockHeight() {\n      return Promise.reject(new Error('Not implemented, getBlockHeight()'));\n    }\n  }, {\n    key: \"getTransactionInfo\",\n    value: function getTransactionInfo(txid) {\n      return Promise.reject(new Error(\"Not implemented, getTransactionInfo(\".concat(txid, \")\")));\n    }\n  }, {\n    key: \"getNetworkedUTXOs\",\n    value: function getNetworkedUTXOs(address) {\n      return Promise.reject(new Error(\"Not implemented, getNetworkedUTXOs(\".concat(address, \")\")));\n    }\n  }]);\n\n  return BitcoinNetwork;\n}();\n\nexports.BitcoinNetwork = BitcoinNetwork;\n/**\n * @private\n * @ignore\n */\n\nvar BlockstackNetwork =\n/*#__PURE__*/\nfunction () {\n  function BlockstackNetwork(apiUrl, broadcastServiceUrl, bitcoinAPI) {\n    var network = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : bitcoinjs_lib_1.networks.bitcoin;\n\n    _classCallCheck(this, BlockstackNetwork);\n\n    this.blockstackAPIUrl = apiUrl;\n    this.broadcastServiceUrl = broadcastServiceUrl;\n    this.layer1 = network;\n    this.btc = bitcoinAPI;\n    this.DUST_MINIMUM = 5500;\n    this.includeUtxoMap = {};\n    this.excludeUtxoSet = [];\n    this.MAGIC_BYTES = 'id';\n  }\n\n  _createClass(BlockstackNetwork, [{\n    key: \"coerceAddress\",\n    value: function coerceAddress(address) {\n      var _bitcoinjs_lib_1$addr = bitcoinjs_lib_1.address.fromBase58Check(address),\n          hash = _bitcoinjs_lib_1$addr.hash,\n          version = _bitcoinjs_lib_1$addr.version;\n\n      var scriptHashes = [bitcoinjs_lib_1.networks.bitcoin.scriptHash, bitcoinjs_lib_1.networks.testnet.scriptHash];\n      var pubKeyHashes = [bitcoinjs_lib_1.networks.bitcoin.pubKeyHash, bitcoinjs_lib_1.networks.testnet.pubKeyHash];\n      var coercedVersion;\n\n      if (scriptHashes.indexOf(version) >= 0) {\n        coercedVersion = this.layer1.scriptHash;\n      } else if (pubKeyHashes.indexOf(version) >= 0) {\n        coercedVersion = this.layer1.pubKeyHash;\n      } else {\n        throw new Error(\"Unrecognized address version number \".concat(version, \" in \").concat(address));\n      }\n\n      return bitcoinjs_lib_1.address.toBase58Check(hash, coercedVersion);\n    }\n    /**\n    * @ignore\n    */\n\n  }, {\n    key: \"getDefaultBurnAddress\",\n    value: function getDefaultBurnAddress() {\n      return this.coerceAddress('1111111111111111111114oLvT2');\n    }\n    /**\n     * Get the price of a name via the legacy /v1/prices API endpoint.\n     * @param {String} fullyQualifiedName the name to query\n     * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }\n     * @private\n     */\n\n  }, {\n    key: \"getNamePriceV1\",\n    value: function getNamePriceV1(fullyQualifiedName) {\n      var _this = this;\n\n      // legacy code path\n      return fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v1/prices/names/\").concat(fullyQualifiedName)).then(function (resp) {\n        if (!resp.ok) {\n          throw new Error(\"Failed to query name price for \".concat(fullyQualifiedName));\n        }\n\n        return resp;\n      }).then(function (resp) {\n        return resp.json();\n      }).then(function (resp) {\n        return resp.name_price;\n      }).then(function (namePrice) {\n        if (!namePrice || !namePrice.satoshis) {\n          throw new Error(\"Failed to get price for \".concat(fullyQualifiedName, \". Does the namespace exist?\"));\n        }\n\n        if (namePrice.satoshis < _this.DUST_MINIMUM) {\n          namePrice.satoshis = _this.DUST_MINIMUM;\n        }\n\n        var result = {\n          units: 'BTC',\n          amount: new BN(String(namePrice.satoshis))\n        };\n        return result;\n      });\n    }\n    /**\n     * Get the price of a namespace via the legacy /v1/prices API endpoint.\n     * @param {String} namespaceID the namespace to query\n     * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }\n     * @private\n     */\n\n  }, {\n    key: \"getNamespacePriceV1\",\n    value: function getNamespacePriceV1(namespaceID) {\n      var _this2 = this;\n\n      // legacy code path\n      return fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v1/prices/namespaces/\").concat(namespaceID)).then(function (resp) {\n        if (!resp.ok) {\n          throw new Error(\"Failed to query name price for \".concat(namespaceID));\n        }\n\n        return resp;\n      }).then(function (resp) {\n        return resp.json();\n      }).then(function (namespacePrice) {\n        if (!namespacePrice || !namespacePrice.satoshis) {\n          throw new Error(\"Failed to get price for \".concat(namespaceID));\n        }\n\n        if (namespacePrice.satoshis < _this2.DUST_MINIMUM) {\n          namespacePrice.satoshis = _this2.DUST_MINIMUM;\n        }\n\n        var result = {\n          units: 'BTC',\n          amount: new BN(String(namespacePrice.satoshis))\n        };\n        return result;\n      });\n    }\n    /**\n     * Get the price of a name via the /v2/prices API endpoint.\n     * @param {String} fullyQualifiedName the name to query\n     * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }\n     * @private\n     */\n\n  }, {\n    key: \"getNamePriceV2\",\n    value: function getNamePriceV2(fullyQualifiedName) {\n      var _this3 = this;\n\n      return fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v2/prices/names/\").concat(fullyQualifiedName)).then(function (resp) {\n        if (resp.status !== 200) {\n          // old core node \n          throw new Error('The upstream node does not handle the /v2/ price namespace');\n        }\n\n        return resp;\n      }).then(function (resp) {\n        return resp.json();\n      }).then(function (resp) {\n        return resp.name_price;\n      }).then(function (namePrice) {\n        if (!namePrice) {\n          throw new Error(\"Failed to get price for \".concat(fullyQualifiedName, \". Does the namespace exist?\"));\n        }\n\n        var result = {\n          units: namePrice.units,\n          amount: new BN(namePrice.amount)\n        };\n\n        if (namePrice.units === 'BTC') {\n          // must be at least dust-minimum\n          var dustMin = new BN(String(_this3.DUST_MINIMUM));\n\n          if (result.amount.ucmp(dustMin) < 0) {\n            result.amount = dustMin;\n          }\n        }\n\n        return result;\n      });\n    }\n    /**\n     * Get the price of a namespace via the /v2/prices API endpoint.\n     * @param {String} namespaceID the namespace to query\n     * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }\n     * @private\n     */\n\n  }, {\n    key: \"getNamespacePriceV2\",\n    value: function getNamespacePriceV2(namespaceID) {\n      var _this4 = this;\n\n      return fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v2/prices/namespaces/\").concat(namespaceID)).then(function (resp) {\n        if (resp.status !== 200) {\n          // old core node \n          throw new Error('The upstream node does not handle the /v2/ price namespace');\n        }\n\n        return resp;\n      }).then(function (resp) {\n        return resp.json();\n      }).then(function (namespacePrice) {\n        if (!namespacePrice) {\n          throw new Error(\"Failed to get price for \".concat(namespaceID));\n        }\n\n        var result = {\n          units: namespacePrice.units,\n          amount: new BN(namespacePrice.amount)\n        };\n\n        if (namespacePrice.units === 'BTC') {\n          // must be at least dust-minimum\n          var dustMin = new BN(String(_this4.DUST_MINIMUM));\n\n          if (result.amount.ucmp(dustMin) < 0) {\n            result.amount = dustMin;\n          }\n        }\n\n        return result;\n      });\n    }\n    /**\n     * Get the price of a name.\n     * @param {String} fullyQualifiedName the name to query\n     * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }, where\n     *   .units encodes the cryptocurrency units to pay (e.g. BTC, STACKS), and\n     *   .amount encodes the number of units, in the smallest denominiated amount\n     *   (e.g. if .units is BTC, .amount will be satoshis; if .units is STACKS,\n     *   .amount will be microStacks)\n     */\n\n  }, {\n    key: \"getNamePrice\",\n    value: function getNamePrice(fullyQualifiedName) {\n      var _this5 = this;\n\n      // handle v1 or v2 \n      return Promise.resolve().then(function () {\n        return _this5.getNamePriceV2(fullyQualifiedName);\n      }).catch(function () {\n        return _this5.getNamePriceV1(fullyQualifiedName);\n      });\n    }\n    /**\n     * Get the price of a namespace\n     * @param {String} namespaceID the namespace to query\n     * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }, where\n     *   .units encodes the cryptocurrency units to pay (e.g. BTC, STACKS), and\n     *   .amount encodes the number of units, in the smallest denominiated amount\n     *   (e.g. if .units is BTC, .amount will be satoshis; if .units is STACKS,\n     *   .amount will be microStacks)\n     */\n\n  }, {\n    key: \"getNamespacePrice\",\n    value: function getNamespacePrice(namespaceID) {\n      var _this6 = this;\n\n      // handle v1 or v2 \n      return Promise.resolve().then(function () {\n        return _this6.getNamespacePriceV2(namespaceID);\n      }).catch(function () {\n        return _this6.getNamespacePriceV1(namespaceID);\n      });\n    }\n    /**\n     * How many blocks can pass between a name expiring and the name being able to be\n     * re-registered by a different owner?\n     * @param {string} fullyQualifiedName unused\n     * @return {Promise} a promise to the number of blocks\n     */\n\n  }, {\n    key: \"getGracePeriod\",\n    value: function getGracePeriod(fullyQualifiedName) {\n      return Promise.resolve(5000);\n    }\n    /**\n     * Get the names -- both on-chain and off-chain -- owned by an address.\n     * @param {String} address the blockchain address (the hash of the owner public key)\n     * @return {Promise} a promise that resolves to a list of names (Strings)\n     */\n\n  }, {\n    key: \"getNamesOwned\",\n    value: function getNamesOwned(address) {\n      var networkAddress = this.coerceAddress(address);\n      return fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v1/addresses/bitcoin/\").concat(networkAddress)).then(function (resp) {\n        return resp.json();\n      }).then(function (obj) {\n        return obj.names;\n      });\n    }\n    /**\n     * Get the blockchain address to which a name's registration fee must be sent\n     * (the address will depend on the namespace in which it is registered.)\n     * @param {String} namespace the namespace ID\n     * @return {Promise} a promise that resolves to an address (String)\n     */\n\n  }, {\n    key: \"getNamespaceBurnAddress\",\n    value: function getNamespaceBurnAddress(namespace) {\n      var _this7 = this;\n\n      return Promise.all([fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v1/namespaces/\").concat(namespace)), this.getBlockHeight()]).then(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            resp = _ref2[0],\n            blockHeight = _ref2[1];\n\n        if (resp.status === 404) {\n          throw new Error(\"No such namespace '\".concat(namespace, \"'\"));\n        } else {\n          return Promise.all([resp.json(), blockHeight]);\n        }\n      }).then(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            namespaceInfo = _ref4[0],\n            blockHeight = _ref4[1];\n\n        var address = _this7.getDefaultBurnAddress();\n\n        if (namespaceInfo.version === 2) {\n          // pay-to-namespace-creator if this namespace is less than 1 year old\n          if (namespaceInfo.reveal_block + 52595 >= blockHeight) {\n            address = namespaceInfo.address;\n          }\n        }\n\n        return address;\n      }).then(function (address) {\n        return _this7.coerceAddress(address);\n      });\n    }\n    /**\n     * Get WHOIS-like information for a name, including the address that owns it,\n     * the block at which it expires, and the zone file anchored to it (if available).\n     * @param {String} fullyQualifiedName the name to query.  Can be on-chain of off-chain.\n     * @return {Promise} a promise that resolves to the WHOIS-like information\n     */\n\n  }, {\n    key: \"getNameInfo\",\n    value: function getNameInfo(fullyQualifiedName) {\n      var _this8 = this;\n\n      logger_1.Logger.debug(this.blockstackAPIUrl);\n      var nameLookupURL = \"\".concat(this.blockstackAPIUrl, \"/v1/names/\").concat(fullyQualifiedName);\n      return fetchUtil_1.fetchPrivate(nameLookupURL).then(function (resp) {\n        if (resp.status === 404) {\n          throw new Error('Name not found');\n        } else if (resp.status !== 200) {\n          throw new Error(\"Bad response status: \".concat(resp.status));\n        } else {\n          return resp.json();\n        }\n      }).then(function (nameInfo) {\n        logger_1.Logger.debug(\"nameInfo: \".concat(JSON.stringify(nameInfo))); // the returned address _should_ be in the correct network ---\n        //  blockstackd gets into trouble because it tries to coerce back to mainnet\n        //  and the regtest transaction generation libraries want to use testnet addresses\n\n        if (nameInfo.address) {\n          return Object.assign({}, nameInfo, {\n            address: _this8.coerceAddress(nameInfo.address)\n          });\n        } else {\n          return nameInfo;\n        }\n      });\n    }\n    /**\n     * Get the pricing parameters and creation history of a namespace.\n     * @param {String} namespaceID the namespace to query\n     * @return {Promise} a promise that resolves to the namespace information.\n     */\n\n  }, {\n    key: \"getNamespaceInfo\",\n    value: function getNamespaceInfo(namespaceID) {\n      var _this9 = this;\n\n      return fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v1/namespaces/\").concat(namespaceID)).then(function (resp) {\n        if (resp.status === 404) {\n          throw new Error('Namespace not found');\n        } else if (resp.status !== 200) {\n          throw new Error(\"Bad response status: \".concat(resp.status));\n        } else {\n          return resp.json();\n        }\n      }).then(function (namespaceInfo) {\n        // the returned address _should_ be in the correct network ---\n        //  blockstackd gets into trouble because it tries to coerce back to mainnet\n        //  and the regtest transaction generation libraries want to use testnet addresses\n        if (namespaceInfo.address && namespaceInfo.recipient_address) {\n          return Object.assign({}, namespaceInfo, {\n            address: _this9.coerceAddress(namespaceInfo.address),\n            recipient_address: _this9.coerceAddress(namespaceInfo.recipient_address)\n          });\n        } else {\n          return namespaceInfo;\n        }\n      });\n    }\n    /**\n     * Get a zone file, given its hash.  Throws an exception if the zone file\n     * obtained does not match the hash.\n     * @param {String} zonefileHash the ripemd160(sha256) hash of the zone file\n     * @return {Promise} a promise that resolves to the zone file's text\n     */\n\n  }, {\n    key: \"getZonefile\",\n    value: function getZonefile(zonefileHash) {\n      return fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v1/zonefiles/\").concat(zonefileHash)).then(function (resp) {\n        if (resp.status === 200) {\n          return resp.text().then(function (body) {\n            var sha256 = bitcoinjs_lib_1.crypto.sha256(Buffer.from(body));\n            var h = new RIPEMD160().update(sha256).digest('hex');\n\n            if (h !== zonefileHash) {\n              throw new Error(\"Zone file contents hash to \".concat(h, \", not \").concat(zonefileHash));\n            }\n\n            return body;\n          });\n        } else {\n          throw new Error(\"Bad response status: \".concat(resp.status));\n        }\n      });\n    }\n    /**\n     * Get the status of an account for a particular token holding.  This includes its total number of\n     * expenditures and credits, lockup times, last txid, and so on.\n     * @param {String} address the account\n     * @param {String} tokenType the token type to query\n     * @return {Promise} a promise that resolves to an object representing the state of the account\n     *   for this token\n     */\n\n  }, {\n    key: \"getAccountStatus\",\n    value: function getAccountStatus(address, tokenType) {\n      var _this10 = this;\n\n      return fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v1/accounts/\").concat(address, \"/\").concat(tokenType, \"/status\")).then(function (resp) {\n        if (resp.status === 404) {\n          throw new Error('Account not found');\n        } else if (resp.status !== 200) {\n          throw new Error(\"Bad response status: \".concat(resp.status));\n        } else {\n          return resp.json();\n        }\n      }).then(function (accountStatus) {\n        // coerce all addresses, and convert credit/debit to biginteger\n        var formattedStatus = Object.assign({}, accountStatus, {\n          address: _this10.coerceAddress(accountStatus.address),\n          debit_value: new BN(String(accountStatus.debit_value)),\n          credit_value: new BN(String(accountStatus.credit_value))\n        });\n        return formattedStatus;\n      });\n    }\n    /**\n     * Get a page of an account's transaction history.\n     * @param {String} address the account's address\n     * @param {number} page the page number.  Page 0 is the most recent transactions\n     * @return {Promise} a promise that resolves to an Array of Objects, where each Object encodes\n     *   states of the account at various block heights (e.g. prior balances, txids, etc)\n     */\n\n  }, {\n    key: \"getAccountHistoryPage\",\n    value: function getAccountHistoryPage(address, page) {\n      var _this11 = this;\n\n      var url = \"\".concat(this.blockstackAPIUrl, \"/v1/accounts/\").concat(address, \"/history?page=\").concat(page);\n      return fetchUtil_1.fetchPrivate(url).then(function (resp) {\n        if (resp.status === 404) {\n          throw new Error('Account not found');\n        } else if (resp.status !== 200) {\n          throw new Error(\"Bad response status: \".concat(resp.status));\n        } else {\n          return resp.json();\n        }\n      }).then(function (historyList) {\n        if (historyList.error) {\n          throw new Error(\"Unable to get account history page: \".concat(historyList.error));\n        } // coerse all addresses and convert to bigint\n\n\n        return historyList.map(function (histEntry) {\n          histEntry.address = _this11.coerceAddress(histEntry.address);\n          histEntry.debit_value = new BN(String(histEntry.debit_value));\n          histEntry.credit_value = new BN(String(histEntry.credit_value));\n          return histEntry;\n        });\n      });\n    }\n    /**\n     * Get the state(s) of an account at a particular block height.  This includes the state of the\n     * account beginning with this block's transactions, as well as all of the states the account\n     * passed through when this block was processed (if any).\n     * @param {String} address the account's address\n     * @param {Integer} blockHeight the block to query\n     * @return {Promise} a promise that resolves to an Array of Objects, where each Object encodes\n     *   states of the account at this block.\n     */\n\n  }, {\n    key: \"getAccountAt\",\n    value: function getAccountAt(address, blockHeight) {\n      var _this12 = this;\n\n      var url = \"\".concat(this.blockstackAPIUrl, \"/v1/accounts/\").concat(address, \"/history/\").concat(blockHeight);\n      return fetchUtil_1.fetchPrivate(url).then(function (resp) {\n        if (resp.status === 404) {\n          throw new Error('Account not found');\n        } else if (resp.status !== 200) {\n          throw new Error(\"Bad response status: \".concat(resp.status));\n        } else {\n          return resp.json();\n        }\n      }).then(function (historyList) {\n        if (historyList.error) {\n          throw new Error(\"Unable to get historic account state: \".concat(historyList.error));\n        } // coerce all addresses \n\n\n        return historyList.map(function (histEntry) {\n          histEntry.address = _this12.coerceAddress(histEntry.address);\n          histEntry.debit_value = new BN(String(histEntry.debit_value));\n          histEntry.credit_value = new BN(String(histEntry.credit_value));\n          return histEntry;\n        });\n      });\n    }\n    /**\n     * Get the set of token types that this account owns\n     * @param {String} address the account's address\n     * @return {Promise} a promise that resolves to an Array of Strings, where each item encodes the\n     *   type of token this account holds (excluding the underlying blockchain's tokens)\n     */\n\n  }, {\n    key: \"getAccountTokens\",\n    value: function getAccountTokens(address) {\n      return fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v1/accounts/\").concat(address, \"/tokens\")).then(function (resp) {\n        if (resp.status === 404) {\n          throw new Error('Account not found');\n        } else if (resp.status !== 200) {\n          throw new Error(\"Bad response status: \".concat(resp.status));\n        } else {\n          return resp.json();\n        }\n      }).then(function (tokenList) {\n        if (tokenList.error) {\n          throw new Error(\"Unable to get token list: \".concat(tokenList.error));\n        }\n\n        return tokenList;\n      });\n    }\n    /**\n     * Get the number of tokens owned by an account.  If the account does not exist or has no\n     * tokens of this type, then 0 will be returned.\n     * @param {String} address the account's address\n     * @param {String} tokenType the type of token to query.\n     * @return {Promise} a promise that resolves to a BigInteger that encodes the number of tokens\n     *   held by this account.\n     */\n\n  }, {\n    key: \"getAccountBalance\",\n    value: function getAccountBalance(address, tokenType) {\n      return fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v1/accounts/\").concat(address, \"/\").concat(tokenType, \"/balance\")).then(function (resp) {\n        if (resp.status === 404) {\n          // talking to an older blockstack core node without the accounts API\n          return Promise.resolve().then(function () {\n            return new BN('0');\n          });\n        } else if (resp.status !== 200) {\n          throw new Error(\"Bad response status: \".concat(resp.status));\n        } else {\n          return resp.json();\n        }\n      }).then(function (tokenBalance) {\n        if (tokenBalance.error) {\n          throw new Error(\"Unable to get account balance: \".concat(tokenBalance.error));\n        }\n\n        var balance = '0';\n\n        if (tokenBalance && tokenBalance.balance) {\n          balance = tokenBalance.balance;\n        }\n\n        return new BN(balance);\n      });\n    }\n    /**\n     * Performs a POST request to the given URL\n     * @param  {String} endpoint  the name of\n     * @param  {String} body [description]\n     * @return {Promise<Object|Error>} Returns a `Promise` that resolves to the object requested.\n     * In the event of an error, it rejects with:\n     * * a `RemoteServiceError` if there is a problem\n     * with the transaction broadcast service\n     * * `MissingParameterError` if you call the function without a required\n     * parameter\n     *\n     * @private\n     */\n\n  }, {\n    key: \"broadcastServiceFetchHelper\",\n    value: function broadcastServiceFetchHelper(endpoint, body) {\n      var requestHeaders = {\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n      };\n      var options = {\n        method: 'POST',\n        headers: requestHeaders,\n        body: JSON.stringify(body)\n      };\n      var url = \"\".concat(this.broadcastServiceUrl, \"/v1/broadcast/\").concat(endpoint);\n      return fetchUtil_1.fetchPrivate(url, options).then(function (response) {\n        if (response.ok) {\n          return response.json();\n        } else {\n          throw new errors_1.RemoteServiceError(response);\n        }\n      });\n    }\n    /**\n    * Broadcasts a signed bitcoin transaction to the network optionally waiting to broadcast the\n    * transaction until a second transaction has a certain number of confirmations.\n    *\n    * @param  {string} transaction the hex-encoded transaction to broadcast\n    * @param  {string} transactionToWatch the hex transaction id of the transaction to watch for\n    * the specified number of confirmations before broadcasting the `transaction`\n    * @param  {number} confirmations the number of confirmations `transactionToWatch` must have\n    * before broadcasting `transaction`.\n    * @return {Promise<Object|Error>} Returns a Promise that resolves to an object with a\n    * `transaction_hash` key containing the transaction hash of the broadcasted transaction.\n    *\n    * In the event of an error, it rejects with:\n    * * a `RemoteServiceError` if there is a problem\n    *   with the transaction broadcast service\n    * * `MissingParameterError` if you call the function without a required\n    *   parameter\n    * @private\n    */\n\n  }, {\n    key: \"broadcastTransaction\",\n    value: function broadcastTransaction(transaction) {\n      var transactionToWatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var confirmations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 6;\n\n      if (!transaction) {\n        var error = new errors_1.MissingParameterError('transaction');\n        return Promise.reject(error);\n      }\n\n      if (!confirmations && confirmations !== 0) {\n        var _error = new errors_1.MissingParameterError('confirmations');\n\n        return Promise.reject(_error);\n      }\n\n      if (transactionToWatch === null) {\n        return this.btc.broadcastTransaction(transaction);\n      } else {\n        /*\n         * POST /v1/broadcast/transaction\n         * Request body:\n         * JSON.stringify({\n         *  transaction,\n         *  transactionToWatch,\n         *  confirmations\n         * })\n         */\n        var endpoint = TX_BROADCAST_SERVICE_TX_ENDPOINT;\n        var requestBody = {\n          transaction: transaction,\n          transactionToWatch: transactionToWatch,\n          confirmations: confirmations\n        };\n        return this.broadcastServiceFetchHelper(endpoint, requestBody);\n      }\n    }\n    /**\n     * Broadcasts a zone file to the Atlas network via the transaction broadcast service.\n     *\n     * @param  {String} zoneFile the zone file to be broadcast to the Atlas network\n     * @param  {String} transactionToWatch the hex transaction id of the transaction\n     * to watch for confirmation before broadcasting the zone file to the Atlas network\n     * @return {Promise<Object|Error>} Returns a Promise that resolves to an object with a\n     * `transaction_hash` key containing the transaction hash of the broadcasted transaction.\n     *\n     * In the event of an error, it rejects with:\n     * * a `RemoteServiceError` if there is a problem\n     *   with the transaction broadcast service\n     * * `MissingParameterError` if you call the function without a required\n     *   parameter\n     * @private\n     */\n\n  }, {\n    key: \"broadcastZoneFile\",\n    value: function broadcastZoneFile(zoneFile) {\n      var transactionToWatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (!zoneFile) {\n        return Promise.reject(new errors_1.MissingParameterError('zoneFile'));\n      } // TODO: validate zonefile\n\n\n      if (transactionToWatch) {\n        // broadcast via transaction broadcast service\n\n        /*\n         * POST /v1/broadcast/zone-file\n         * Request body:\n         * JSON.stringify({\n         *  zoneFile,\n         *  transactionToWatch\n         * })\n         */\n        var requestBody = {\n          zoneFile: zoneFile,\n          transactionToWatch: transactionToWatch\n        };\n        var endpoint = TX_BROADCAST_SERVICE_ZONE_FILE_ENDPOINT;\n        return this.broadcastServiceFetchHelper(endpoint, requestBody);\n      } else {\n        // broadcast via core endpoint\n        // zone file is two words but core's api treats it as one word 'zonefile'\n        var _requestBody = {\n          zonefile: zoneFile\n        };\n        return fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v1/zonefile/\"), {\n          method: 'POST',\n          body: JSON.stringify(_requestBody),\n          headers: {\n            'Content-Type': 'application/json'\n          }\n        }).then(function (resp) {\n          var json = resp.json();\n          return json.then(function (respObj) {\n            if (respObj.hasOwnProperty('error')) {\n              throw new errors_1.RemoteServiceError(resp);\n            }\n\n            return respObj.servers;\n          });\n        });\n      }\n    }\n    /**\n     * Sends the preorder and registration transactions and zone file\n     * for a Blockstack name registration\n     * along with the to the transaction broadcast service.\n     *\n     * The transaction broadcast:\n     *\n     * * immediately broadcasts the preorder transaction\n     * * broadcasts the register transactions after the preorder transaction\n     * has an appropriate number of confirmations\n     * * broadcasts the zone file to the Atlas network after the register transaction\n     * has an appropriate number of confirmations\n     *\n     * @param  {String} preorderTransaction the hex-encoded, signed preorder transaction generated\n     * using the `makePreorder` function\n     * @param  {String} registerTransaction the hex-encoded, signed register transaction generated\n     * using the `makeRegister` function\n     * @param  {String} zoneFile the zone file to be broadcast to the Atlas network\n     * @return {Promise<Object|Error>} Returns a Promise that resolves to an object with a\n     * `transaction_hash` key containing the transaction hash of the broadcasted transaction.\n     *\n     * In the event of an error, it rejects with:\n     * * a `RemoteServiceError` if there is a problem\n     *   with the transaction broadcast service\n     * * `MissingParameterError` if you call the function without a required\n     *   parameter\n     * @private\n     */\n\n  }, {\n    key: \"broadcastNameRegistration\",\n    value: function broadcastNameRegistration(preorderTransaction, registerTransaction, zoneFile) {\n      /*\n         * POST /v1/broadcast/registration\n         * Request body:\n         * JSON.stringify({\n         * preorderTransaction,\n         * registerTransaction,\n         * zoneFile\n         * })\n         */\n      if (!preorderTransaction) {\n        var error = new errors_1.MissingParameterError('preorderTransaction');\n        return Promise.reject(error);\n      }\n\n      if (!registerTransaction) {\n        var _error2 = new errors_1.MissingParameterError('registerTransaction');\n\n        return Promise.reject(_error2);\n      }\n\n      if (!zoneFile) {\n        var _error3 = new errors_1.MissingParameterError('zoneFile');\n\n        return Promise.reject(_error3);\n      }\n\n      var requestBody = {\n        preorderTransaction: preorderTransaction,\n        registerTransaction: registerTransaction,\n        zoneFile: zoneFile\n      };\n      var endpoint = TX_BROADCAST_SERVICE_REGISTRATION_ENDPOINT;\n      return this.broadcastServiceFetchHelper(endpoint, requestBody);\n    }\n    /**\n     * @ignore\n     */\n\n  }, {\n    key: \"getFeeRate\",\n    value: function getFeeRate() {\n      return fetchUtil_1.fetchPrivate('https://bitcoinfees.earn.com/api/v1/fees/recommended').then(function (resp) {\n        return resp.json();\n      }).then(function (rates) {\n        return Math.floor(rates.fastestFee);\n      });\n    }\n    /**\n     * @ignore\n     */\n\n  }, {\n    key: \"countDustOutputs\",\n    value: function countDustOutputs() {\n      throw new Error('Not implemented.');\n    }\n    /**\n     * @ignore\n     */\n\n  }, {\n    key: \"getUTXOs\",\n    value: function getUTXOs(address) {\n      var _this13 = this;\n\n      return this.getNetworkedUTXOs(address).then(function (networkedUTXOs) {\n        var returnSet = networkedUTXOs.concat();\n\n        if (_this13.includeUtxoMap.hasOwnProperty(address)) {\n          returnSet = networkedUTXOs.concat(_this13.includeUtxoMap[address]);\n        } // aaron: I am *well* aware this is O(n)*O(m) runtime\n        //    however, clients should clear the exclude set periodically\n\n\n        var excludeSet = _this13.excludeUtxoSet;\n        returnSet = returnSet.filter(function (utxo) {\n          var inExcludeSet = excludeSet.reduce(function (inSet, utxoToCheck) {\n            return inSet || utxoToCheck.tx_hash === utxo.tx_hash && utxoToCheck.tx_output_n === utxo.tx_output_n;\n          }, false);\n          return !inExcludeSet;\n        });\n        return returnSet;\n      });\n    }\n    /**\n     * This will modify the network's utxo set to include UTXOs\n     *  from the given transaction and exclude UTXOs *spent* in\n     *  that transaction\n     * @param {String} txHex - the hex-encoded transaction to use\n     * @return {void} no return value, this modifies the UTXO config state\n     * @private\n     * @ignore\n     */\n\n  }, {\n    key: \"modifyUTXOSetFrom\",\n    value: function modifyUTXOSetFrom(txHex) {\n      var _this14 = this;\n\n      var tx = bitcoinjs_lib_1.Transaction.fromHex(txHex);\n      var excludeSet = this.excludeUtxoSet.concat();\n      tx.ins.forEach(function (utxoUsed) {\n        var reverseHash = Buffer.from(utxoUsed.hash);\n        reverseHash.reverse();\n        excludeSet.push({\n          tx_hash: reverseHash.toString('hex'),\n          tx_output_n: utxoUsed.index\n        });\n      });\n      this.excludeUtxoSet = excludeSet;\n      var txHash = Buffer.from(tx.getHash().reverse()).toString('hex');\n      tx.outs.forEach(function (utxoCreated, txOutputN) {\n        var isNullData = function isNullData(script) {\n          try {\n            bitcoinjs_lib_1.payments.embed({\n              output: script\n            }, {\n              validate: true\n            });\n            return true;\n          } catch (_) {\n            return false;\n          }\n        };\n\n        if (isNullData(utxoCreated.script)) {\n          return;\n        }\n\n        var address = bitcoinjs_lib_1.address.fromOutputScript(utxoCreated.script, _this14.layer1);\n        var includeSet = [];\n\n        if (_this14.includeUtxoMap.hasOwnProperty(address)) {\n          includeSet = includeSet.concat(_this14.includeUtxoMap[address]);\n        }\n\n        includeSet.push({\n          tx_hash: txHash,\n          confirmations: 0,\n          value: utxoCreated.value,\n          tx_output_n: txOutputN\n        });\n        _this14.includeUtxoMap[address] = includeSet;\n      });\n    }\n  }, {\n    key: \"resetUTXOs\",\n    value: function resetUTXOs(address) {\n      delete this.includeUtxoMap[address];\n      this.excludeUtxoSet = [];\n    }\n    /**\n    * @ignore\n    */\n\n  }, {\n    key: \"getConsensusHash\",\n    value: function getConsensusHash() {\n      return fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v1/blockchains/bitcoin/consensus\")).then(function (resp) {\n        return resp.json();\n      }).then(function (x) {\n        return x.consensus_hash;\n      });\n    }\n  }, {\n    key: \"getTransactionInfo\",\n    value: function getTransactionInfo(txHash) {\n      return this.btc.getTransactionInfo(txHash);\n    }\n    /**\n     * @ignore\n     */\n\n  }, {\n    key: \"getBlockHeight\",\n    value: function getBlockHeight() {\n      return this.btc.getBlockHeight();\n    }\n  }, {\n    key: \"getNetworkedUTXOs\",\n    value: function getNetworkedUTXOs(address) {\n      return this.btc.getNetworkedUTXOs(address);\n    }\n  }]);\n\n  return BlockstackNetwork;\n}();\n\nexports.BlockstackNetwork = BlockstackNetwork;\n/**\n * @ignore\n */\n\nvar LocalRegtest =\n/*#__PURE__*/\nfunction (_BlockstackNetwork) {\n  _inherits(LocalRegtest, _BlockstackNetwork);\n\n  function LocalRegtest(apiUrl, broadcastServiceUrl, bitcoinAPI) {\n    _classCallCheck(this, LocalRegtest);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(LocalRegtest).call(this, apiUrl, broadcastServiceUrl, bitcoinAPI, bitcoinjs_lib_1.networks.testnet));\n  }\n\n  _createClass(LocalRegtest, [{\n    key: \"getFeeRate\",\n    value: function getFeeRate() {\n      return Promise.resolve(Math.floor(0.00001000 * SATOSHIS_PER_BTC));\n    }\n  }]);\n\n  return LocalRegtest;\n}(BlockstackNetwork);\n\nexports.LocalRegtest = LocalRegtest;\n/**\n * @ignore\n */\n\nvar BitcoindAPI =\n/*#__PURE__*/\nfunction (_BitcoinNetwork) {\n  _inherits(BitcoindAPI, _BitcoinNetwork);\n\n  function BitcoindAPI(bitcoindUrl, bitcoindCredentials) {\n    var _this15;\n\n    _classCallCheck(this, BitcoindAPI);\n\n    _this15 = _possibleConstructorReturn(this, _getPrototypeOf(BitcoindAPI).call(this));\n    _this15.bitcoindUrl = bitcoindUrl;\n    _this15.bitcoindCredentials = bitcoindCredentials;\n    _this15.importedBefore = {};\n    return _this15;\n  }\n\n  _createClass(BitcoindAPI, [{\n    key: \"broadcastTransaction\",\n    value: function broadcastTransaction(transaction) {\n      var jsonRPC = {\n        jsonrpc: '1.0',\n        method: 'sendrawtransaction',\n        params: [transaction]\n      };\n      var authString = Buffer.from(\"\".concat(this.bitcoindCredentials.username, \":\").concat(this.bitcoindCredentials.password)).toString('base64');\n      var headers = {\n        Authorization: \"Basic \".concat(authString)\n      };\n      return fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n        method: 'POST',\n        body: JSON.stringify(jsonRPC),\n        headers: headers\n      }).then(function (resp) {\n        return resp.json();\n      }).then(function (respObj) {\n        return respObj.result;\n      });\n    }\n  }, {\n    key: \"getBlockHeight\",\n    value: function getBlockHeight() {\n      var jsonRPC = {\n        jsonrpc: '1.0',\n        method: 'getblockcount'\n      };\n      var authString = Buffer.from(\"\".concat(this.bitcoindCredentials.username, \":\").concat(this.bitcoindCredentials.password)).toString('base64');\n      var headers = {\n        Authorization: \"Basic \".concat(authString)\n      };\n      return fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n        method: 'POST',\n        body: JSON.stringify(jsonRPC),\n        headers: headers\n      }).then(function (resp) {\n        return resp.json();\n      }).then(function (respObj) {\n        return respObj.result;\n      });\n    }\n  }, {\n    key: \"getTransactionInfo\",\n    value: function getTransactionInfo(txHash) {\n      var _this16 = this;\n\n      var jsonRPC = {\n        jsonrpc: '1.0',\n        method: 'gettransaction',\n        params: [txHash]\n      };\n      var authString = Buffer.from(\"\".concat(this.bitcoindCredentials.username, \":\").concat(this.bitcoindCredentials.password)).toString('base64');\n      var headers = {\n        Authorization: \"Basic \".concat(authString)\n      };\n      return fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n        method: 'POST',\n        body: JSON.stringify(jsonRPC),\n        headers: headers\n      }).then(function (resp) {\n        return resp.json();\n      }).then(function (respObj) {\n        return respObj.result;\n      }).then(function (txInfo) {\n        return txInfo.blockhash;\n      }).then(function (blockhash) {\n        var jsonRPCBlock = {\n          jsonrpc: '1.0',\n          method: 'getblockheader',\n          params: [blockhash]\n        };\n        headers.Authorization = \"Basic \".concat(authString);\n        return fetchUtil_1.fetchPrivate(_this16.bitcoindUrl, {\n          method: 'POST',\n          body: JSON.stringify(jsonRPCBlock),\n          headers: headers\n        });\n      }).then(function (resp) {\n        return resp.json();\n      }).then(function (respObj) {\n        if (!respObj || !respObj.result) {\n          // unconfirmed \n          throw new Error('Unconfirmed transaction');\n        } else {\n          return {\n            block_height: respObj.result.height\n          };\n        }\n      });\n    }\n  }, {\n    key: \"getNetworkedUTXOs\",\n    value: function getNetworkedUTXOs(address) {\n      var _this17 = this;\n\n      var jsonRPCImport = {\n        jsonrpc: '1.0',\n        method: 'importaddress',\n        params: [address]\n      };\n      var jsonRPCUnspent = {\n        jsonrpc: '1.0',\n        method: 'listunspent',\n        params: [0, 9999999, [address]]\n      };\n      var authString = Buffer.from(\"\".concat(this.bitcoindCredentials.username, \":\").concat(this.bitcoindCredentials.password)).toString('base64');\n      var headers = {\n        Authorization: \"Basic \".concat(authString)\n      };\n      var importPromise = this.importedBefore[address] ? Promise.resolve() : fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n        method: 'POST',\n        body: JSON.stringify(jsonRPCImport),\n        headers: headers\n      }).then(function () {\n        _this17.importedBefore[address] = true;\n      });\n      return importPromise.then(function () {\n        return fetchUtil_1.fetchPrivate(_this17.bitcoindUrl, {\n          method: 'POST',\n          body: JSON.stringify(jsonRPCUnspent),\n          headers: headers\n        });\n      }).then(function (resp) {\n        return resp.json();\n      }).then(function (x) {\n        return x.result;\n      }).then(function (utxos) {\n        return utxos.map(function (x) {\n          return {\n            value: Math.round(x.amount * SATOSHIS_PER_BTC),\n            confirmations: x.confirmations,\n            tx_hash: x.txid,\n            tx_output_n: x.vout\n          };\n        });\n      });\n    }\n  }]);\n\n  return BitcoindAPI;\n}(BitcoinNetwork);\n\nexports.BitcoindAPI = BitcoindAPI;\n/**\n * @ignore\n */\n\nvar InsightClient =\n/*#__PURE__*/\nfunction (_BitcoinNetwork2) {\n  _inherits(InsightClient, _BitcoinNetwork2);\n\n  function InsightClient() {\n    var _this18;\n\n    var insightUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'https://utxo.technofractal.com/';\n\n    _classCallCheck(this, InsightClient);\n\n    _this18 = _possibleConstructorReturn(this, _getPrototypeOf(InsightClient).call(this));\n    _this18.apiUrl = insightUrl;\n    return _this18;\n  }\n\n  _createClass(InsightClient, [{\n    key: \"broadcastTransaction\",\n    value: function broadcastTransaction(transaction) {\n      var jsonData = {\n        rawtx: transaction\n      };\n      return fetchUtil_1.fetchPrivate(\"\".concat(this.apiUrl, \"/tx/send\"), {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(jsonData)\n      }).then(function (resp) {\n        return resp.json();\n      });\n    }\n  }, {\n    key: \"getBlockHeight\",\n    value: function getBlockHeight() {\n      return fetchUtil_1.fetchPrivate(\"\".concat(this.apiUrl, \"/status\")).then(function (resp) {\n        return resp.json();\n      }).then(function (status) {\n        return status.blocks;\n      });\n    }\n  }, {\n    key: \"getTransactionInfo\",\n    value: function getTransactionInfo(txHash) {\n      var _this19 = this;\n\n      return fetchUtil_1.fetchPrivate(\"\".concat(this.apiUrl, \"/tx/\").concat(txHash)).then(function (resp) {\n        return resp.json();\n      }).then(function (transactionInfo) {\n        if (transactionInfo.error) {\n          throw new Error(\"Error finding transaction: \".concat(transactionInfo.error));\n        }\n\n        return fetchUtil_1.fetchPrivate(\"\".concat(_this19.apiUrl, \"/block/\").concat(transactionInfo.blockHash));\n      }).then(function (resp) {\n        return resp.json();\n      }).then(function (blockInfo) {\n        return {\n          block_height: blockInfo.height\n        };\n      });\n    }\n  }, {\n    key: \"getNetworkedUTXOs\",\n    value: function getNetworkedUTXOs(address) {\n      return fetchUtil_1.fetchPrivate(\"\".concat(this.apiUrl, \"/addr/\").concat(address, \"/utxo\")).then(function (resp) {\n        return resp.json();\n      }).then(function (utxos) {\n        return utxos.map(function (x) {\n          return {\n            value: x.satoshis,\n            confirmations: x.confirmations,\n            tx_hash: x.txid,\n            tx_output_n: x.vout\n          };\n        });\n      });\n    }\n  }]);\n\n  return InsightClient;\n}(BitcoinNetwork);\n\nexports.InsightClient = InsightClient;\n/**\n * @ignore\n */\n\nvar BlockchainInfoApi =\n/*#__PURE__*/\nfunction (_BitcoinNetwork3) {\n  _inherits(BlockchainInfoApi, _BitcoinNetwork3);\n\n  function BlockchainInfoApi() {\n    var _this20;\n\n    var blockchainInfoUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'https://blockchain.info';\n\n    _classCallCheck(this, BlockchainInfoApi);\n\n    _this20 = _possibleConstructorReturn(this, _getPrototypeOf(BlockchainInfoApi).call(this));\n    _this20.utxoProviderUrl = blockchainInfoUrl;\n    return _this20;\n  }\n\n  _createClass(BlockchainInfoApi, [{\n    key: \"getBlockHeight\",\n    value: function getBlockHeight() {\n      return fetchUtil_1.fetchPrivate(\"\".concat(this.utxoProviderUrl, \"/latestblock?cors=true\")).then(function (resp) {\n        return resp.json();\n      }).then(function (blockObj) {\n        return blockObj.height;\n      });\n    }\n  }, {\n    key: \"getNetworkedUTXOs\",\n    value: function getNetworkedUTXOs(address) {\n      return fetchUtil_1.fetchPrivate(\"\".concat(this.utxoProviderUrl, \"/unspent?format=json&active=\").concat(address, \"&cors=true\")).then(function (resp) {\n        if (resp.status === 500) {\n          logger_1.Logger.debug('UTXO provider 500 usually means no UTXOs: returning []');\n          return {\n            unspent_outputs: []\n          };\n        } else {\n          return resp.json();\n        }\n      }).then(function (utxoJSON) {\n        return utxoJSON.unspent_outputs;\n      }).then(function (utxoList) {\n        return utxoList.map(function (utxo) {\n          var utxoOut = {\n            value: utxo.value,\n            tx_output_n: utxo.tx_output_n,\n            confirmations: utxo.confirmations,\n            tx_hash: utxo.tx_hash_big_endian\n          };\n          return utxoOut;\n        });\n      });\n    }\n  }, {\n    key: \"getTransactionInfo\",\n    value: function getTransactionInfo(txHash) {\n      return fetchUtil_1.fetchPrivate(\"\".concat(this.utxoProviderUrl, \"/rawtx/\").concat(txHash, \"?cors=true\")).then(function (resp) {\n        if (resp.status === 200) {\n          return resp.json();\n        } else {\n          throw new Error(\"Could not lookup transaction info for '\".concat(txHash, \"'. Server error.\"));\n        }\n      }).then(function (respObj) {\n        return {\n          block_height: respObj.block_height\n        };\n      });\n    }\n  }, {\n    key: \"broadcastTransaction\",\n    value: function broadcastTransaction(transaction) {\n      var form = new FormData();\n      form.append('tx', transaction);\n      return fetchUtil_1.fetchPrivate(\"\".concat(this.utxoProviderUrl, \"/pushtx?cors=true\"), {\n        method: 'POST',\n        body: form\n      }).then(function (resp) {\n        var text = resp.text();\n        return text.then(function (respText) {\n          if (respText.toLowerCase().indexOf('transaction submitted') >= 0) {\n            var txHash = Buffer.from(bitcoinjs_lib_1.Transaction.fromHex(transaction).getHash().reverse()).toString('hex'); // big_endian\n\n            return txHash;\n          } else {\n            throw new errors_1.RemoteServiceError(resp, \"Broadcast transaction failed with message: \".concat(respText));\n          }\n        });\n      });\n    }\n  }]);\n\n  return BlockchainInfoApi;\n}(BitcoinNetwork);\n\nexports.BlockchainInfoApi = BlockchainInfoApi;\n/**\n* @ignore\n*/\n\nvar LOCAL_REGTEST = new LocalRegtest('http://localhost:16268', 'http://localhost:16269', new BitcoindAPI('http://localhost:18332/', {\n  username: 'blockstack',\n  password: 'blockstacksystem'\n}));\n/**\n* @ignore\n*/\n\nvar MAINNET_DEFAULT = new BlockstackNetwork('https://core.blockstack.org', 'https://broadcast.blockstack.org', new BlockchainInfoApi());\n/**\n * Get WHOIS-like information for a name, including the address that owns it,\n * the block at which it expires, and the zone file anchored to it (if available).\n * @param {String} fullyQualifiedName the name to query.  Can be on-chain of off-chain.\n * @return {Promise} a promise that resolves to the WHOIS-like information\n */\n\nfunction getNameInfo(fullyQualifiedName) {\n  return config_1.config.network.getNameInfo(fullyQualifiedName);\n}\n\nexports.getNameInfo = getNameInfo;\n/**\n* @ignore\n*/\n\nexports.network = {\n  BlockstackNetwork: BlockstackNetwork,\n  LocalRegtest: LocalRegtest,\n  BlockchainInfoApi: BlockchainInfoApi,\n  BitcoindAPI: BitcoindAPI,\n  InsightClient: InsightClient,\n  defaults: {\n    LOCAL_REGTEST: LOCAL_REGTEST,\n    MAINNET_DEFAULT: MAINNET_DEFAULT\n  }\n};","map":{"version":3,"sources":["../src/network.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\nconst FormData = require(\"form-data\");\n// @ts-ignore\nconst BN = require(\"bn.js\");\nconst RIPEMD160 = require(\"ripemd160\");\nconst errors_1 = require(\"./errors\");\nconst logger_1 = require(\"./logger\");\nconst config_1 = require(\"./config\");\nconst fetchUtil_1 = require(\"./fetchUtil\");\nconst SATOSHIS_PER_BTC = 1e8;\nconst TX_BROADCAST_SERVICE_ZONE_FILE_ENDPOINT = 'zone-file';\nconst TX_BROADCAST_SERVICE_REGISTRATION_ENDPOINT = 'registration';\nconst TX_BROADCAST_SERVICE_TX_ENDPOINT = 'transaction';\n/**\n * @private\n * @ignore\n */\nclass BitcoinNetwork {\n    broadcastTransaction(transaction) {\n        return Promise.reject(new Error(`Not implemented, broadcastTransaction(${transaction})`));\n    }\n    getBlockHeight() {\n        return Promise.reject(new Error('Not implemented, getBlockHeight()'));\n    }\n    getTransactionInfo(txid) {\n        return Promise.reject(new Error(`Not implemented, getTransactionInfo(${txid})`));\n    }\n    getNetworkedUTXOs(address) {\n        return Promise.reject(new Error(`Not implemented, getNetworkedUTXOs(${address})`));\n    }\n}\nexports.BitcoinNetwork = BitcoinNetwork;\n/**\n * @private\n * @ignore\n */\nclass BlockstackNetwork {\n    constructor(apiUrl, broadcastServiceUrl, bitcoinAPI, network = bitcoinjs_lib_1.networks.bitcoin) {\n        this.blockstackAPIUrl = apiUrl;\n        this.broadcastServiceUrl = broadcastServiceUrl;\n        this.layer1 = network;\n        this.btc = bitcoinAPI;\n        this.DUST_MINIMUM = 5500;\n        this.includeUtxoMap = {};\n        this.excludeUtxoSet = [];\n        this.MAGIC_BYTES = 'id';\n    }\n    coerceAddress(address) {\n        const { hash, version } = bitcoinjs_lib_1.address.fromBase58Check(address);\n        const scriptHashes = [bitcoinjs_lib_1.networks.bitcoin.scriptHash,\n            bitcoinjs_lib_1.networks.testnet.scriptHash];\n        const pubKeyHashes = [bitcoinjs_lib_1.networks.bitcoin.pubKeyHash,\n            bitcoinjs_lib_1.networks.testnet.pubKeyHash];\n        let coercedVersion;\n        if (scriptHashes.indexOf(version) >= 0) {\n            coercedVersion = this.layer1.scriptHash;\n        }\n        else if (pubKeyHashes.indexOf(version) >= 0) {\n            coercedVersion = this.layer1.pubKeyHash;\n        }\n        else {\n            throw new Error(`Unrecognized address version number ${version} in ${address}`);\n        }\n        return bitcoinjs_lib_1.address.toBase58Check(hash, coercedVersion);\n    }\n    /**\n    * @ignore\n    */\n    getDefaultBurnAddress() {\n        return this.coerceAddress('1111111111111111111114oLvT2');\n    }\n    /**\n     * Get the price of a name via the legacy /v1/prices API endpoint.\n     * @param {String} fullyQualifiedName the name to query\n     * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }\n     * @private\n     */\n    getNamePriceV1(fullyQualifiedName) {\n        // legacy code path\n        return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/prices/names/${fullyQualifiedName}`)\n            .then((resp) => {\n            if (!resp.ok) {\n                throw new Error(`Failed to query name price for ${fullyQualifiedName}`);\n            }\n            return resp;\n        })\n            .then(resp => resp.json())\n            .then(resp => resp.name_price)\n            .then((namePrice) => {\n            if (!namePrice || !namePrice.satoshis) {\n                throw new Error(`Failed to get price for ${fullyQualifiedName}. Does the namespace exist?`);\n            }\n            if (namePrice.satoshis < this.DUST_MINIMUM) {\n                namePrice.satoshis = this.DUST_MINIMUM;\n            }\n            const result = {\n                units: 'BTC',\n                amount: new BN(String(namePrice.satoshis))\n            };\n            return result;\n        });\n    }\n    /**\n     * Get the price of a namespace via the legacy /v1/prices API endpoint.\n     * @param {String} namespaceID the namespace to query\n     * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }\n     * @private\n     */\n    getNamespacePriceV1(namespaceID) {\n        // legacy code path\n        return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/prices/namespaces/${namespaceID}`)\n            .then((resp) => {\n            if (!resp.ok) {\n                throw new Error(`Failed to query name price for ${namespaceID}`);\n            }\n            return resp;\n        })\n            .then(resp => resp.json())\n            .then((namespacePrice) => {\n            if (!namespacePrice || !namespacePrice.satoshis) {\n                throw new Error(`Failed to get price for ${namespaceID}`);\n            }\n            if (namespacePrice.satoshis < this.DUST_MINIMUM) {\n                namespacePrice.satoshis = this.DUST_MINIMUM;\n            }\n            const result = {\n                units: 'BTC',\n                amount: new BN(String(namespacePrice.satoshis))\n            };\n            return result;\n        });\n    }\n    /**\n     * Get the price of a name via the /v2/prices API endpoint.\n     * @param {String} fullyQualifiedName the name to query\n     * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }\n     * @private\n     */\n    getNamePriceV2(fullyQualifiedName) {\n        return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v2/prices/names/${fullyQualifiedName}`)\n            .then((resp) => {\n            if (resp.status !== 200) {\n                // old core node \n                throw new Error('The upstream node does not handle the /v2/ price namespace');\n            }\n            return resp;\n        })\n            .then(resp => resp.json())\n            .then(resp => resp.name_price)\n            .then((namePrice) => {\n            if (!namePrice) {\n                throw new Error(`Failed to get price for ${fullyQualifiedName}. Does the namespace exist?`);\n            }\n            const result = {\n                units: namePrice.units,\n                amount: new BN(namePrice.amount)\n            };\n            if (namePrice.units === 'BTC') {\n                // must be at least dust-minimum\n                const dustMin = new BN(String(this.DUST_MINIMUM));\n                if (result.amount.ucmp(dustMin) < 0) {\n                    result.amount = dustMin;\n                }\n            }\n            return result;\n        });\n    }\n    /**\n     * Get the price of a namespace via the /v2/prices API endpoint.\n     * @param {String} namespaceID the namespace to query\n     * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }\n     * @private\n     */\n    getNamespacePriceV2(namespaceID) {\n        return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v2/prices/namespaces/${namespaceID}`)\n            .then((resp) => {\n            if (resp.status !== 200) {\n                // old core node \n                throw new Error('The upstream node does not handle the /v2/ price namespace');\n            }\n            return resp;\n        })\n            .then(resp => resp.json())\n            .then((namespacePrice) => {\n            if (!namespacePrice) {\n                throw new Error(`Failed to get price for ${namespaceID}`);\n            }\n            const result = {\n                units: namespacePrice.units,\n                amount: new BN(namespacePrice.amount)\n            };\n            if (namespacePrice.units === 'BTC') {\n                // must be at least dust-minimum\n                const dustMin = new BN(String(this.DUST_MINIMUM));\n                if (result.amount.ucmp(dustMin) < 0) {\n                    result.amount = dustMin;\n                }\n            }\n            return result;\n        });\n    }\n    /**\n     * Get the price of a name.\n     * @param {String} fullyQualifiedName the name to query\n     * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }, where\n     *   .units encodes the cryptocurrency units to pay (e.g. BTC, STACKS), and\n     *   .amount encodes the number of units, in the smallest denominiated amount\n     *   (e.g. if .units is BTC, .amount will be satoshis; if .units is STACKS,\n     *   .amount will be microStacks)\n     */\n    getNamePrice(fullyQualifiedName) {\n        // handle v1 or v2 \n        return Promise.resolve().then(() => this.getNamePriceV2(fullyQualifiedName))\n            .catch(() => this.getNamePriceV1(fullyQualifiedName));\n    }\n    /**\n     * Get the price of a namespace\n     * @param {String} namespaceID the namespace to query\n     * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }, where\n     *   .units encodes the cryptocurrency units to pay (e.g. BTC, STACKS), and\n     *   .amount encodes the number of units, in the smallest denominiated amount\n     *   (e.g. if .units is BTC, .amount will be satoshis; if .units is STACKS,\n     *   .amount will be microStacks)\n     */\n    getNamespacePrice(namespaceID) {\n        // handle v1 or v2 \n        return Promise.resolve().then(() => this.getNamespacePriceV2(namespaceID))\n            .catch(() => this.getNamespacePriceV1(namespaceID));\n    }\n    /**\n     * How many blocks can pass between a name expiring and the name being able to be\n     * re-registered by a different owner?\n     * @param {string} fullyQualifiedName unused\n     * @return {Promise} a promise to the number of blocks\n     */\n    getGracePeriod(fullyQualifiedName) {\n        return Promise.resolve(5000);\n    }\n    /**\n     * Get the names -- both on-chain and off-chain -- owned by an address.\n     * @param {String} address the blockchain address (the hash of the owner public key)\n     * @return {Promise} a promise that resolves to a list of names (Strings)\n     */\n    getNamesOwned(address) {\n        const networkAddress = this.coerceAddress(address);\n        return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/addresses/bitcoin/${networkAddress}`)\n            .then(resp => resp.json())\n            .then(obj => obj.names);\n    }\n    /**\n     * Get the blockchain address to which a name's registration fee must be sent\n     * (the address will depend on the namespace in which it is registered.)\n     * @param {String} namespace the namespace ID\n     * @return {Promise} a promise that resolves to an address (String)\n     */\n    getNamespaceBurnAddress(namespace) {\n        return Promise.all([\n            fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/namespaces/${namespace}`),\n            this.getBlockHeight()\n        ])\n            .then(([resp, blockHeight]) => {\n            if (resp.status === 404) {\n                throw new Error(`No such namespace '${namespace}'`);\n            }\n            else {\n                return Promise.all([resp.json(), blockHeight]);\n            }\n        })\n            .then(([namespaceInfo, blockHeight]) => {\n            let address = this.getDefaultBurnAddress();\n            if (namespaceInfo.version === 2) {\n                // pay-to-namespace-creator if this namespace is less than 1 year old\n                if (namespaceInfo.reveal_block + 52595 >= blockHeight) {\n                    address = namespaceInfo.address;\n                }\n            }\n            return address;\n        })\n            .then(address => this.coerceAddress(address));\n    }\n    /**\n     * Get WHOIS-like information for a name, including the address that owns it,\n     * the block at which it expires, and the zone file anchored to it (if available).\n     * @param {String} fullyQualifiedName the name to query.  Can be on-chain of off-chain.\n     * @return {Promise} a promise that resolves to the WHOIS-like information\n     */\n    getNameInfo(fullyQualifiedName) {\n        logger_1.Logger.debug(this.blockstackAPIUrl);\n        const nameLookupURL = `${this.blockstackAPIUrl}/v1/names/${fullyQualifiedName}`;\n        return fetchUtil_1.fetchPrivate(nameLookupURL)\n            .then((resp) => {\n            if (resp.status === 404) {\n                throw new Error('Name not found');\n            }\n            else if (resp.status !== 200) {\n                throw new Error(`Bad response status: ${resp.status}`);\n            }\n            else {\n                return resp.json();\n            }\n        })\n            .then((nameInfo) => {\n            logger_1.Logger.debug(`nameInfo: ${JSON.stringify(nameInfo)}`);\n            // the returned address _should_ be in the correct network ---\n            //  blockstackd gets into trouble because it tries to coerce back to mainnet\n            //  and the regtest transaction generation libraries want to use testnet addresses\n            if (nameInfo.address) {\n                return Object.assign({}, nameInfo, { address: this.coerceAddress(nameInfo.address) });\n            }\n            else {\n                return nameInfo;\n            }\n        });\n    }\n    /**\n     * Get the pricing parameters and creation history of a namespace.\n     * @param {String} namespaceID the namespace to query\n     * @return {Promise} a promise that resolves to the namespace information.\n     */\n    getNamespaceInfo(namespaceID) {\n        return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/namespaces/${namespaceID}`)\n            .then((resp) => {\n            if (resp.status === 404) {\n                throw new Error('Namespace not found');\n            }\n            else if (resp.status !== 200) {\n                throw new Error(`Bad response status: ${resp.status}`);\n            }\n            else {\n                return resp.json();\n            }\n        })\n            .then((namespaceInfo) => {\n            // the returned address _should_ be in the correct network ---\n            //  blockstackd gets into trouble because it tries to coerce back to mainnet\n            //  and the regtest transaction generation libraries want to use testnet addresses\n            if (namespaceInfo.address && namespaceInfo.recipient_address) {\n                return Object.assign({}, namespaceInfo, {\n                    address: this.coerceAddress(namespaceInfo.address),\n                    recipient_address: this.coerceAddress(namespaceInfo.recipient_address)\n                });\n            }\n            else {\n                return namespaceInfo;\n            }\n        });\n    }\n    /**\n     * Get a zone file, given its hash.  Throws an exception if the zone file\n     * obtained does not match the hash.\n     * @param {String} zonefileHash the ripemd160(sha256) hash of the zone file\n     * @return {Promise} a promise that resolves to the zone file's text\n     */\n    getZonefile(zonefileHash) {\n        return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/zonefiles/${zonefileHash}`)\n            .then((resp) => {\n            if (resp.status === 200) {\n                return resp.text()\n                    .then((body) => {\n                    const sha256 = bitcoinjs_lib_1.crypto.sha256(Buffer.from(body));\n                    const h = (new RIPEMD160()).update(sha256).digest('hex');\n                    if (h !== zonefileHash) {\n                        throw new Error(`Zone file contents hash to ${h}, not ${zonefileHash}`);\n                    }\n                    return body;\n                });\n            }\n            else {\n                throw new Error(`Bad response status: ${resp.status}`);\n            }\n        });\n    }\n    /**\n     * Get the status of an account for a particular token holding.  This includes its total number of\n     * expenditures and credits, lockup times, last txid, and so on.\n     * @param {String} address the account\n     * @param {String} tokenType the token type to query\n     * @return {Promise} a promise that resolves to an object representing the state of the account\n     *   for this token\n     */\n    getAccountStatus(address, tokenType) {\n        return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/accounts/${address}/${tokenType}/status`)\n            .then((resp) => {\n            if (resp.status === 404) {\n                throw new Error('Account not found');\n            }\n            else if (resp.status !== 200) {\n                throw new Error(`Bad response status: ${resp.status}`);\n            }\n            else {\n                return resp.json();\n            }\n        }).then((accountStatus) => {\n            // coerce all addresses, and convert credit/debit to biginteger\n            const formattedStatus = Object.assign({}, accountStatus, {\n                address: this.coerceAddress(accountStatus.address),\n                debit_value: new BN(String(accountStatus.debit_value)),\n                credit_value: new BN(String(accountStatus.credit_value))\n            });\n            return formattedStatus;\n        });\n    }\n    /**\n     * Get a page of an account's transaction history.\n     * @param {String} address the account's address\n     * @param {number} page the page number.  Page 0 is the most recent transactions\n     * @return {Promise} a promise that resolves to an Array of Objects, where each Object encodes\n     *   states of the account at various block heights (e.g. prior balances, txids, etc)\n     */\n    getAccountHistoryPage(address, page) {\n        const url = `${this.blockstackAPIUrl}/v1/accounts/${address}/history?page=${page}`;\n        return fetchUtil_1.fetchPrivate(url)\n            .then((resp) => {\n            if (resp.status === 404) {\n                throw new Error('Account not found');\n            }\n            else if (resp.status !== 200) {\n                throw new Error(`Bad response status: ${resp.status}`);\n            }\n            else {\n                return resp.json();\n            }\n        })\n            .then((historyList) => {\n            if (historyList.error) {\n                throw new Error(`Unable to get account history page: ${historyList.error}`);\n            }\n            // coerse all addresses and convert to bigint\n            return historyList.map((histEntry) => {\n                histEntry.address = this.coerceAddress(histEntry.address);\n                histEntry.debit_value = new BN(String(histEntry.debit_value));\n                histEntry.credit_value = new BN(String(histEntry.credit_value));\n                return histEntry;\n            });\n        });\n    }\n    /**\n     * Get the state(s) of an account at a particular block height.  This includes the state of the\n     * account beginning with this block's transactions, as well as all of the states the account\n     * passed through when this block was processed (if any).\n     * @param {String} address the account's address\n     * @param {Integer} blockHeight the block to query\n     * @return {Promise} a promise that resolves to an Array of Objects, where each Object encodes\n     *   states of the account at this block.\n     */\n    getAccountAt(address, blockHeight) {\n        const url = `${this.blockstackAPIUrl}/v1/accounts/${address}/history/${blockHeight}`;\n        return fetchUtil_1.fetchPrivate(url)\n            .then((resp) => {\n            if (resp.status === 404) {\n                throw new Error('Account not found');\n            }\n            else if (resp.status !== 200) {\n                throw new Error(`Bad response status: ${resp.status}`);\n            }\n            else {\n                return resp.json();\n            }\n        })\n            .then((historyList) => {\n            if (historyList.error) {\n                throw new Error(`Unable to get historic account state: ${historyList.error}`);\n            }\n            // coerce all addresses \n            return historyList.map((histEntry) => {\n                histEntry.address = this.coerceAddress(histEntry.address);\n                histEntry.debit_value = new BN(String(histEntry.debit_value));\n                histEntry.credit_value = new BN(String(histEntry.credit_value));\n                return histEntry;\n            });\n        });\n    }\n    /**\n     * Get the set of token types that this account owns\n     * @param {String} address the account's address\n     * @return {Promise} a promise that resolves to an Array of Strings, where each item encodes the\n     *   type of token this account holds (excluding the underlying blockchain's tokens)\n     */\n    getAccountTokens(address) {\n        return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/accounts/${address}/tokens`)\n            .then((resp) => {\n            if (resp.status === 404) {\n                throw new Error('Account not found');\n            }\n            else if (resp.status !== 200) {\n                throw new Error(`Bad response status: ${resp.status}`);\n            }\n            else {\n                return resp.json();\n            }\n        })\n            .then((tokenList) => {\n            if (tokenList.error) {\n                throw new Error(`Unable to get token list: ${tokenList.error}`);\n            }\n            return tokenList;\n        });\n    }\n    /**\n     * Get the number of tokens owned by an account.  If the account does not exist or has no\n     * tokens of this type, then 0 will be returned.\n     * @param {String} address the account's address\n     * @param {String} tokenType the type of token to query.\n     * @return {Promise} a promise that resolves to a BigInteger that encodes the number of tokens\n     *   held by this account.\n     */\n    getAccountBalance(address, tokenType) {\n        return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/accounts/${address}/${tokenType}/balance`)\n            .then((resp) => {\n            if (resp.status === 404) {\n                // talking to an older blockstack core node without the accounts API\n                return Promise.resolve().then(() => new BN('0'));\n            }\n            else if (resp.status !== 200) {\n                throw new Error(`Bad response status: ${resp.status}`);\n            }\n            else {\n                return resp.json();\n            }\n        })\n            .then((tokenBalance) => {\n            if (tokenBalance.error) {\n                throw new Error(`Unable to get account balance: ${tokenBalance.error}`);\n            }\n            let balance = '0';\n            if (tokenBalance && tokenBalance.balance) {\n                balance = tokenBalance.balance;\n            }\n            return new BN(balance);\n        });\n    }\n    /**\n     * Performs a POST request to the given URL\n     * @param  {String} endpoint  the name of\n     * @param  {String} body [description]\n     * @return {Promise<Object|Error>} Returns a `Promise` that resolves to the object requested.\n     * In the event of an error, it rejects with:\n     * * a `RemoteServiceError` if there is a problem\n     * with the transaction broadcast service\n     * * `MissingParameterError` if you call the function without a required\n     * parameter\n     *\n     * @private\n     */\n    broadcastServiceFetchHelper(endpoint, body) {\n        const requestHeaders = {\n            Accept: 'application/json',\n            'Content-Type': 'application/json'\n        };\n        const options = {\n            method: 'POST',\n            headers: requestHeaders,\n            body: JSON.stringify(body)\n        };\n        const url = `${this.broadcastServiceUrl}/v1/broadcast/${endpoint}`;\n        return fetchUtil_1.fetchPrivate(url, options)\n            .then((response) => {\n            if (response.ok) {\n                return response.json();\n            }\n            else {\n                throw new errors_1.RemoteServiceError(response);\n            }\n        });\n    }\n    /**\n    * Broadcasts a signed bitcoin transaction to the network optionally waiting to broadcast the\n    * transaction until a second transaction has a certain number of confirmations.\n    *\n    * @param  {string} transaction the hex-encoded transaction to broadcast\n    * @param  {string} transactionToWatch the hex transaction id of the transaction to watch for\n    * the specified number of confirmations before broadcasting the `transaction`\n    * @param  {number} confirmations the number of confirmations `transactionToWatch` must have\n    * before broadcasting `transaction`.\n    * @return {Promise<Object|Error>} Returns a Promise that resolves to an object with a\n    * `transaction_hash` key containing the transaction hash of the broadcasted transaction.\n    *\n    * In the event of an error, it rejects with:\n    * * a `RemoteServiceError` if there is a problem\n    *   with the transaction broadcast service\n    * * `MissingParameterError` if you call the function without a required\n    *   parameter\n    * @private\n    */\n    broadcastTransaction(transaction, transactionToWatch = null, confirmations = 6) {\n        if (!transaction) {\n            const error = new errors_1.MissingParameterError('transaction');\n            return Promise.reject(error);\n        }\n        if (!confirmations && confirmations !== 0) {\n            const error = new errors_1.MissingParameterError('confirmations');\n            return Promise.reject(error);\n        }\n        if (transactionToWatch === null) {\n            return this.btc.broadcastTransaction(transaction);\n        }\n        else {\n            /*\n             * POST /v1/broadcast/transaction\n             * Request body:\n             * JSON.stringify({\n             *  transaction,\n             *  transactionToWatch,\n             *  confirmations\n             * })\n             */\n            const endpoint = TX_BROADCAST_SERVICE_TX_ENDPOINT;\n            const requestBody = {\n                transaction,\n                transactionToWatch,\n                confirmations\n            };\n            return this.broadcastServiceFetchHelper(endpoint, requestBody);\n        }\n    }\n    /**\n     * Broadcasts a zone file to the Atlas network via the transaction broadcast service.\n     *\n     * @param  {String} zoneFile the zone file to be broadcast to the Atlas network\n     * @param  {String} transactionToWatch the hex transaction id of the transaction\n     * to watch for confirmation before broadcasting the zone file to the Atlas network\n     * @return {Promise<Object|Error>} Returns a Promise that resolves to an object with a\n     * `transaction_hash` key containing the transaction hash of the broadcasted transaction.\n     *\n     * In the event of an error, it rejects with:\n     * * a `RemoteServiceError` if there is a problem\n     *   with the transaction broadcast service\n     * * `MissingParameterError` if you call the function without a required\n     *   parameter\n     * @private\n     */\n    broadcastZoneFile(zoneFile, transactionToWatch = null) {\n        if (!zoneFile) {\n            return Promise.reject(new errors_1.MissingParameterError('zoneFile'));\n        }\n        // TODO: validate zonefile\n        if (transactionToWatch) {\n            // broadcast via transaction broadcast service\n            /*\n             * POST /v1/broadcast/zone-file\n             * Request body:\n             * JSON.stringify({\n             *  zoneFile,\n             *  transactionToWatch\n             * })\n             */\n            const requestBody = {\n                zoneFile,\n                transactionToWatch\n            };\n            const endpoint = TX_BROADCAST_SERVICE_ZONE_FILE_ENDPOINT;\n            return this.broadcastServiceFetchHelper(endpoint, requestBody);\n        }\n        else {\n            // broadcast via core endpoint\n            // zone file is two words but core's api treats it as one word 'zonefile'\n            const requestBody = { zonefile: zoneFile };\n            return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/zonefile/`, {\n                method: 'POST',\n                body: JSON.stringify(requestBody),\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            })\n                .then((resp) => {\n                const json = resp.json();\n                return json\n                    .then((respObj) => {\n                    if (respObj.hasOwnProperty('error')) {\n                        throw new errors_1.RemoteServiceError(resp);\n                    }\n                    return respObj.servers;\n                });\n            });\n        }\n    }\n    /**\n     * Sends the preorder and registration transactions and zone file\n     * for a Blockstack name registration\n     * along with the to the transaction broadcast service.\n     *\n     * The transaction broadcast:\n     *\n     * * immediately broadcasts the preorder transaction\n     * * broadcasts the register transactions after the preorder transaction\n     * has an appropriate number of confirmations\n     * * broadcasts the zone file to the Atlas network after the register transaction\n     * has an appropriate number of confirmations\n     *\n     * @param  {String} preorderTransaction the hex-encoded, signed preorder transaction generated\n     * using the `makePreorder` function\n     * @param  {String} registerTransaction the hex-encoded, signed register transaction generated\n     * using the `makeRegister` function\n     * @param  {String} zoneFile the zone file to be broadcast to the Atlas network\n     * @return {Promise<Object|Error>} Returns a Promise that resolves to an object with a\n     * `transaction_hash` key containing the transaction hash of the broadcasted transaction.\n     *\n     * In the event of an error, it rejects with:\n     * * a `RemoteServiceError` if there is a problem\n     *   with the transaction broadcast service\n     * * `MissingParameterError` if you call the function without a required\n     *   parameter\n     * @private\n     */\n    broadcastNameRegistration(preorderTransaction, registerTransaction, zoneFile) {\n        /*\n           * POST /v1/broadcast/registration\n           * Request body:\n           * JSON.stringify({\n           * preorderTransaction,\n           * registerTransaction,\n           * zoneFile\n           * })\n           */\n        if (!preorderTransaction) {\n            const error = new errors_1.MissingParameterError('preorderTransaction');\n            return Promise.reject(error);\n        }\n        if (!registerTransaction) {\n            const error = new errors_1.MissingParameterError('registerTransaction');\n            return Promise.reject(error);\n        }\n        if (!zoneFile) {\n            const error = new errors_1.MissingParameterError('zoneFile');\n            return Promise.reject(error);\n        }\n        const requestBody = {\n            preorderTransaction,\n            registerTransaction,\n            zoneFile\n        };\n        const endpoint = TX_BROADCAST_SERVICE_REGISTRATION_ENDPOINT;\n        return this.broadcastServiceFetchHelper(endpoint, requestBody);\n    }\n    /**\n     * @ignore\n     */\n    getFeeRate() {\n        return fetchUtil_1.fetchPrivate('https://bitcoinfees.earn.com/api/v1/fees/recommended')\n            .then(resp => resp.json())\n            .then(rates => Math.floor(rates.fastestFee));\n    }\n    /**\n     * @ignore\n     */\n    countDustOutputs() {\n        throw new Error('Not implemented.');\n    }\n    /**\n     * @ignore\n     */\n    getUTXOs(address) {\n        return this.getNetworkedUTXOs(address)\n            .then((networkedUTXOs) => {\n            let returnSet = networkedUTXOs.concat();\n            if (this.includeUtxoMap.hasOwnProperty(address)) {\n                returnSet = networkedUTXOs.concat(this.includeUtxoMap[address]);\n            }\n            // aaron: I am *well* aware this is O(n)*O(m) runtime\n            //    however, clients should clear the exclude set periodically\n            const excludeSet = this.excludeUtxoSet;\n            returnSet = returnSet.filter((utxo) => {\n                const inExcludeSet = excludeSet.reduce((inSet, utxoToCheck) => inSet || (utxoToCheck.tx_hash === utxo.tx_hash\n                    && utxoToCheck.tx_output_n === utxo.tx_output_n), false);\n                return !inExcludeSet;\n            });\n            return returnSet;\n        });\n    }\n    /**\n     * This will modify the network's utxo set to include UTXOs\n     *  from the given transaction and exclude UTXOs *spent* in\n     *  that transaction\n     * @param {String} txHex - the hex-encoded transaction to use\n     * @return {void} no return value, this modifies the UTXO config state\n     * @private\n     * @ignore\n     */\n    modifyUTXOSetFrom(txHex) {\n        const tx = bitcoinjs_lib_1.Transaction.fromHex(txHex);\n        const excludeSet = this.excludeUtxoSet.concat();\n        tx.ins.forEach((utxoUsed) => {\n            const reverseHash = Buffer.from(utxoUsed.hash);\n            reverseHash.reverse();\n            excludeSet.push({\n                tx_hash: reverseHash.toString('hex'),\n                tx_output_n: utxoUsed.index\n            });\n        });\n        this.excludeUtxoSet = excludeSet;\n        const txHash = Buffer.from(tx.getHash().reverse()).toString('hex');\n        tx.outs.forEach((utxoCreated, txOutputN) => {\n            const isNullData = function isNullData(script) {\n                try {\n                    bitcoinjs_lib_1.payments.embed({ output: script }, { validate: true });\n                    return true;\n                }\n                catch (_) {\n                    return false;\n                }\n            };\n            if (isNullData(utxoCreated.script)) {\n                return;\n            }\n            const address = bitcoinjs_lib_1.address.fromOutputScript(utxoCreated.script, this.layer1);\n            let includeSet = [];\n            if (this.includeUtxoMap.hasOwnProperty(address)) {\n                includeSet = includeSet.concat(this.includeUtxoMap[address]);\n            }\n            includeSet.push({\n                tx_hash: txHash,\n                confirmations: 0,\n                value: utxoCreated.value,\n                tx_output_n: txOutputN\n            });\n            this.includeUtxoMap[address] = includeSet;\n        });\n    }\n    resetUTXOs(address) {\n        delete this.includeUtxoMap[address];\n        this.excludeUtxoSet = [];\n    }\n    /**\n    * @ignore\n    */\n    getConsensusHash() {\n        return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/blockchains/bitcoin/consensus`)\n            .then(resp => resp.json())\n            .then(x => x.consensus_hash);\n    }\n    getTransactionInfo(txHash) {\n        return this.btc.getTransactionInfo(txHash);\n    }\n    /**\n     * @ignore\n     */\n    getBlockHeight() {\n        return this.btc.getBlockHeight();\n    }\n    getNetworkedUTXOs(address) {\n        return this.btc.getNetworkedUTXOs(address);\n    }\n}\nexports.BlockstackNetwork = BlockstackNetwork;\n/**\n * @ignore\n */\nclass LocalRegtest extends BlockstackNetwork {\n    constructor(apiUrl, broadcastServiceUrl, bitcoinAPI) {\n        super(apiUrl, broadcastServiceUrl, bitcoinAPI, bitcoinjs_lib_1.networks.testnet);\n    }\n    getFeeRate() {\n        return Promise.resolve(Math.floor(0.00001000 * SATOSHIS_PER_BTC));\n    }\n}\nexports.LocalRegtest = LocalRegtest;\n/**\n * @ignore\n */\nclass BitcoindAPI extends BitcoinNetwork {\n    constructor(bitcoindUrl, bitcoindCredentials) {\n        super();\n        this.bitcoindUrl = bitcoindUrl;\n        this.bitcoindCredentials = bitcoindCredentials;\n        this.importedBefore = {};\n    }\n    broadcastTransaction(transaction) {\n        const jsonRPC = {\n            jsonrpc: '1.0',\n            method: 'sendrawtransaction',\n            params: [transaction]\n        };\n        const authString = Buffer.from(`${this.bitcoindCredentials.username}:${this.bitcoindCredentials.password}`)\n            .toString('base64');\n        const headers = { Authorization: `Basic ${authString}` };\n        return fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n            method: 'POST',\n            body: JSON.stringify(jsonRPC),\n            headers\n        })\n            .then(resp => resp.json())\n            .then(respObj => respObj.result);\n    }\n    getBlockHeight() {\n        const jsonRPC = {\n            jsonrpc: '1.0',\n            method: 'getblockcount'\n        };\n        const authString = Buffer.from(`${this.bitcoindCredentials.username}:${this.bitcoindCredentials.password}`)\n            .toString('base64');\n        const headers = { Authorization: `Basic ${authString}` };\n        return fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n            method: 'POST',\n            body: JSON.stringify(jsonRPC),\n            headers\n        })\n            .then(resp => resp.json())\n            .then(respObj => respObj.result);\n    }\n    getTransactionInfo(txHash) {\n        const jsonRPC = {\n            jsonrpc: '1.0',\n            method: 'gettransaction',\n            params: [txHash]\n        };\n        const authString = Buffer.from(`${this.bitcoindCredentials.username}:${this.bitcoindCredentials.password}`)\n            .toString('base64');\n        const headers = { Authorization: `Basic ${authString}` };\n        return fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n            method: 'POST',\n            body: JSON.stringify(jsonRPC),\n            headers\n        })\n            .then(resp => resp.json())\n            .then(respObj => respObj.result)\n            .then(txInfo => txInfo.blockhash)\n            .then((blockhash) => {\n            const jsonRPCBlock = {\n                jsonrpc: '1.0',\n                method: 'getblockheader',\n                params: [blockhash]\n            };\n            headers.Authorization = `Basic ${authString}`;\n            return fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n                method: 'POST',\n                body: JSON.stringify(jsonRPCBlock),\n                headers\n            });\n        })\n            .then(resp => resp.json())\n            .then((respObj) => {\n            if (!respObj || !respObj.result) {\n                // unconfirmed \n                throw new Error('Unconfirmed transaction');\n            }\n            else {\n                return { block_height: respObj.result.height };\n            }\n        });\n    }\n    getNetworkedUTXOs(address) {\n        const jsonRPCImport = {\n            jsonrpc: '1.0',\n            method: 'importaddress',\n            params: [address]\n        };\n        const jsonRPCUnspent = {\n            jsonrpc: '1.0',\n            method: 'listunspent',\n            params: [0, 9999999, [address]]\n        };\n        const authString = Buffer.from(`${this.bitcoindCredentials.username}:${this.bitcoindCredentials.password}`)\n            .toString('base64');\n        const headers = { Authorization: `Basic ${authString}` };\n        const importPromise = (this.importedBefore[address])\n            ? Promise.resolve()\n            : fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n                method: 'POST',\n                body: JSON.stringify(jsonRPCImport),\n                headers\n            })\n                .then(() => { this.importedBefore[address] = true; });\n        return importPromise\n            .then(() => fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n            method: 'POST',\n            body: JSON.stringify(jsonRPCUnspent),\n            headers\n        }))\n            .then(resp => resp.json())\n            .then(x => x.result)\n            .then(utxos => utxos.map((x) => ({\n            value: Math.round(x.amount * SATOSHIS_PER_BTC),\n            confirmations: x.confirmations,\n            tx_hash: x.txid,\n            tx_output_n: x.vout\n        })));\n    }\n}\nexports.BitcoindAPI = BitcoindAPI;\n/**\n * @ignore\n */\nclass InsightClient extends BitcoinNetwork {\n    constructor(insightUrl = 'https://utxo.technofractal.com/') {\n        super();\n        this.apiUrl = insightUrl;\n    }\n    broadcastTransaction(transaction) {\n        const jsonData = { rawtx: transaction };\n        return fetchUtil_1.fetchPrivate(`${this.apiUrl}/tx/send`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(jsonData)\n        })\n            .then(resp => resp.json());\n    }\n    getBlockHeight() {\n        return fetchUtil_1.fetchPrivate(`${this.apiUrl}/status`)\n            .then(resp => resp.json())\n            .then(status => status.blocks);\n    }\n    getTransactionInfo(txHash) {\n        return fetchUtil_1.fetchPrivate(`${this.apiUrl}/tx/${txHash}`)\n            .then(resp => resp.json())\n            .then((transactionInfo) => {\n            if (transactionInfo.error) {\n                throw new Error(`Error finding transaction: ${transactionInfo.error}`);\n            }\n            return fetchUtil_1.fetchPrivate(`${this.apiUrl}/block/${transactionInfo.blockHash}`);\n        })\n            .then(resp => resp.json())\n            .then(blockInfo => ({ block_height: blockInfo.height }));\n    }\n    getNetworkedUTXOs(address) {\n        return fetchUtil_1.fetchPrivate(`${this.apiUrl}/addr/${address}/utxo`)\n            .then(resp => resp.json())\n            .then(utxos => utxos.map((x) => ({\n            value: x.satoshis,\n            confirmations: x.confirmations,\n            tx_hash: x.txid,\n            tx_output_n: x.vout\n        })));\n    }\n}\nexports.InsightClient = InsightClient;\n/**\n * @ignore\n */\nclass BlockchainInfoApi extends BitcoinNetwork {\n    constructor(blockchainInfoUrl = 'https://blockchain.info') {\n        super();\n        this.utxoProviderUrl = blockchainInfoUrl;\n    }\n    getBlockHeight() {\n        return fetchUtil_1.fetchPrivate(`${this.utxoProviderUrl}/latestblock?cors=true`)\n            .then(resp => resp.json())\n            .then(blockObj => blockObj.height);\n    }\n    getNetworkedUTXOs(address) {\n        return fetchUtil_1.fetchPrivate(`${this.utxoProviderUrl}/unspent?format=json&active=${address}&cors=true`)\n            .then((resp) => {\n            if (resp.status === 500) {\n                logger_1.Logger.debug('UTXO provider 500 usually means no UTXOs: returning []');\n                return {\n                    unspent_outputs: []\n                };\n            }\n            else {\n                return resp.json();\n            }\n        })\n            .then(utxoJSON => utxoJSON.unspent_outputs)\n            .then(utxoList => utxoList.map((utxo) => {\n            const utxoOut = {\n                value: utxo.value,\n                tx_output_n: utxo.tx_output_n,\n                confirmations: utxo.confirmations,\n                tx_hash: utxo.tx_hash_big_endian\n            };\n            return utxoOut;\n        }));\n    }\n    getTransactionInfo(txHash) {\n        return fetchUtil_1.fetchPrivate(`${this.utxoProviderUrl}/rawtx/${txHash}?cors=true`)\n            .then((resp) => {\n            if (resp.status === 200) {\n                return resp.json();\n            }\n            else {\n                throw new Error(`Could not lookup transaction info for '${txHash}'. Server error.`);\n            }\n        })\n            .then(respObj => ({ block_height: respObj.block_height }));\n    }\n    broadcastTransaction(transaction) {\n        const form = new FormData();\n        form.append('tx', transaction);\n        return fetchUtil_1.fetchPrivate(`${this.utxoProviderUrl}/pushtx?cors=true`, {\n            method: 'POST',\n            body: form\n        })\n            .then((resp) => {\n            const text = resp.text();\n            return text\n                .then((respText) => {\n                if (respText.toLowerCase().indexOf('transaction submitted') >= 0) {\n                    const txHash = Buffer.from(bitcoinjs_lib_1.Transaction.fromHex(transaction)\n                        .getHash()\n                        .reverse()).toString('hex'); // big_endian\n                    return txHash;\n                }\n                else {\n                    throw new errors_1.RemoteServiceError(resp, `Broadcast transaction failed with message: ${respText}`);\n                }\n            });\n        });\n    }\n}\nexports.BlockchainInfoApi = BlockchainInfoApi;\n/**\n* @ignore\n*/\nconst LOCAL_REGTEST = new LocalRegtest('http://localhost:16268', 'http://localhost:16269', new BitcoindAPI('http://localhost:18332/', { username: 'blockstack', password: 'blockstacksystem' }));\n/**\n* @ignore\n*/\nconst MAINNET_DEFAULT = new BlockstackNetwork('https://core.blockstack.org', 'https://broadcast.blockstack.org', new BlockchainInfoApi());\n/**\n * Get WHOIS-like information for a name, including the address that owns it,\n * the block at which it expires, and the zone file anchored to it (if available).\n * @param {String} fullyQualifiedName the name to query.  Can be on-chain of off-chain.\n * @return {Promise} a promise that resolves to the WHOIS-like information\n */\nfunction getNameInfo(fullyQualifiedName) {\n    return config_1.config.network.getNameInfo(fullyQualifiedName);\n}\nexports.getNameInfo = getNameInfo;\n/**\n* @ignore\n*/\nexports.network = {\n    BlockstackNetwork,\n    LocalRegtest,\n    BlockchainInfoApi,\n    BitcoindAPI,\n    InsightClient,\n    defaults: { LOCAL_REGTEST, MAINNET_DEFAULT }\n};\n//# sourceMappingURL=network.js.map"]},"metadata":{},"sourceType":"script"}