{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/aashan/2048/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"/home/aashan/2048/node_modules/@babel/runtime/regenerator\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar hub_1 = require(\"./hub\");\n\nexports.connectToGaiaHub = hub_1.connectToGaiaHub;\nexports.uploadToGaiaHub = hub_1.uploadToGaiaHub;\nexports.BLOCKSTACK_GAIA_HUB_LABEL = hub_1.BLOCKSTACK_GAIA_HUB_LABEL; // export { type GaiaHubConfig } from './hub'\n\nvar ec_1 = require(\"../encryption/ec\");\n\nvar keys_1 = require(\"../keys\");\n\nvar profileLookup_1 = require(\"../profiles/profileLookup\");\n\nvar errors_1 = require(\"../errors\");\n\nvar logger_1 = require(\"../logger\");\n\nvar userSession_1 = require(\"../auth/userSession\");\n\nvar utils_1 = require(\"../utils\");\n\nvar fetchUtil_1 = require(\"../fetchUtil\");\n\nvar SIGNATURE_FILE_SUFFIX = '.sig';\n/**\n * Fetch the public read URL of a user file for the specified app.\n * @param {String} path - the path to the file to read\n * @param {String} username - The Blockstack ID of the user to look up\n * @param {String} appOrigin - The app origin\n * @param {String} [zoneFileLookupURL=null] - The URL\n * to use for zonefile lookup. If falsey, this will use the\n * blockstack.js's [[getNameInfo]] function instead.\n * @return {Promise<string>} that resolves to the public read URL of the file\n * or rejects with an error\n */\n\nfunction getUserAppFileUrl(path, username, appOrigin, zoneFileLookupURL) {\n  return __awaiter(this, void 0, void 0,\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee() {\n    var profile, bucketUrl, url, bucket;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return profileLookup_1.lookupProfile(username, zoneFileLookupURL);\n\n          case 2:\n            profile = _context.sent;\n            bucketUrl = null;\n\n            if (profile.hasOwnProperty('apps')) {\n              if (profile.apps.hasOwnProperty(appOrigin)) {\n                url = profile.apps[appOrigin];\n                bucket = url.replace(/\\/?(\\?|#|$)/, '/$1');\n                bucketUrl = \"\".concat(bucket).concat(path);\n              }\n            }\n\n            return _context.abrupt(\"return\", bucketUrl);\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n\nexports.getUserAppFileUrl = getUserAppFileUrl;\n/**\n *\n *\n * @deprecated\n * #### v19 Use [[UserSession.encryptContent]].\n *\n * Encrypts the data provided with the app public key.\n * @param {String|Buffer} content - data to encrypt\n * @param {Object} [options=null] - options object\n * @param {String} options.publicKey - the hex string of the ECDSA public\n * key to use for encryption. If not provided, will use user's appPublicKey.\n * @return {String} Stringified ciphertext object\n */\n\nfunction encryptContent(content, options, caller) {\n  var opts = Object.assign({}, options);\n\n  if (!opts.publicKey) {\n    var privateKey = (caller || new userSession_1.UserSession()).loadUserData().appPrivateKey;\n    opts.publicKey = keys_1.getPublicKeyFromPrivate(privateKey);\n  }\n\n  var cipherObject = ec_1.encryptECIES(opts.publicKey, content);\n  return JSON.stringify(cipherObject);\n}\n\nexports.encryptContent = encryptContent;\n/**\n *\n * @deprecated\n * #### v19 Use [[UserSession.decryptContent]].\n *\n * Decrypts data encrypted with `encryptContent` with the\n * transit private key.\n * @param {String|Buffer} content - encrypted content.\n * @param {Object} [options=null] - options object\n * @param {String} options.privateKey - the hex string of the ECDSA private\n * key to use for decryption. If not provided, will use user's appPrivateKey.\n * @return {String|Buffer} decrypted content.\n */\n\nfunction decryptContent(content, options, caller) {\n  var opts = Object.assign({}, options);\n\n  if (!opts.privateKey) {\n    opts.privateKey = (caller || new userSession_1.UserSession()).loadUserData().appPrivateKey;\n  }\n\n  try {\n    var cipherObject = JSON.parse(content);\n    return ec_1.decryptECIES(opts.privateKey, cipherObject);\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      throw new Error('Failed to parse encrypted content JSON. The content may not ' + 'be encrypted. If using getFile, try passing { decrypt: false }.');\n    } else {\n      throw err;\n    }\n  }\n}\n\nexports.decryptContent = decryptContent;\n/* Get the gaia address used for servicing multiplayer reads for the given\n * (username, app) pair.\n * @private\n * @ignore\n */\n\nfunction getGaiaAddress(app, username, zoneFileLookupURL, caller) {\n  return __awaiter(this, void 0, void 0,\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2() {\n    var opts, fileUrl, gaiaHubConfig, matches;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            opts = normalizeOptions({\n              app: app,\n              username: username\n            }, caller);\n\n            if (!username) {\n              _context2.next = 7;\n              break;\n            }\n\n            _context2.next = 4;\n            return getUserAppFileUrl('/', opts.username, opts.app, zoneFileLookupURL);\n\n          case 4:\n            fileUrl = _context2.sent;\n            _context2.next = 14;\n            break;\n\n          case 7:\n            if (!caller) {\n              caller = new userSession_1.UserSession();\n            }\n\n            _context2.next = 10;\n            return caller.getOrSetLocalGaiaHubConnection();\n\n          case 10:\n            gaiaHubConfig = _context2.sent;\n            _context2.next = 13;\n            return hub_1.getFullReadUrl('/', gaiaHubConfig);\n\n          case 13:\n            fileUrl = _context2.sent;\n\n          case 14:\n            matches = fileUrl.match(/([13][a-km-zA-HJ-NP-Z0-9]{26,35})/);\n\n            if (matches) {\n              _context2.next = 17;\n              break;\n            }\n\n            throw new Error('Failed to parse gaia address');\n\n          case 17:\n            return _context2.abrupt(\"return\", matches[matches.length - 1]);\n\n          case 18:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n}\n/**\n * @param {Object} [options=null] - options object\n * @param {String} options.username - the Blockstack ID to lookup for multi-player storage\n * @param {String} options.app - the app to lookup for multi-player storage -\n * defaults to current origin\n *\n * @ignore\n */\n\n\nfunction normalizeOptions(options, caller) {\n  var opts = Object.assign({}, options);\n\n  if (opts.username) {\n    if (!opts.app) {\n      var appConfig = (caller || new userSession_1.UserSession()).appConfig;\n\n      if (!appConfig) {\n        throw new errors_1.InvalidStateError('Missing AppConfig');\n      }\n\n      opts.app = appConfig.appDomain;\n    }\n  }\n\n  return opts;\n}\n/**\n * @deprecated\n * #### v19 Use [[UserSession.getFileUrl]] instead.\n *\n * @param {String} path - the path to the file to read\n * @returns {Promise<string>} that resolves to the URL or rejects with an error\n */\n\n\nfunction getFileUrl(path, options, caller) {\n  return __awaiter(this, void 0, void 0,\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee3() {\n    var opts, readUrl, gaiaHubConfig;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            opts = normalizeOptions(options, caller);\n\n            if (!opts.username) {\n              _context3.next = 7;\n              break;\n            }\n\n            _context3.next = 4;\n            return getUserAppFileUrl(path, opts.username, opts.app, opts.zoneFileLookupURL);\n\n          case 4:\n            readUrl = _context3.sent;\n            _context3.next = 13;\n            break;\n\n          case 7:\n            _context3.next = 9;\n            return (caller || new userSession_1.UserSession()).getOrSetLocalGaiaHubConnection();\n\n          case 9:\n            gaiaHubConfig = _context3.sent;\n            _context3.next = 12;\n            return hub_1.getFullReadUrl(path, gaiaHubConfig);\n\n          case 12:\n            readUrl = _context3.sent;\n\n          case 13:\n            if (readUrl) {\n              _context3.next = 17;\n              break;\n            }\n\n            throw new Error('Missing readURL');\n\n          case 17:\n            return _context3.abrupt(\"return\", readUrl);\n\n          case 18:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n}\n\nexports.getFileUrl = getFileUrl;\n/* Handle fetching the contents from a given path. Handles both\n *  multi-player reads and reads from own storage.\n * @private\n * @ignore\n */\n\nfunction getFileContents(path, app, username, zoneFileLookupURL, forceText, caller) {\n  return Promise.resolve().then(function () {\n    var opts = {\n      app: app,\n      username: username,\n      zoneFileLookupURL: zoneFileLookupURL\n    };\n    return getFileUrl(path, opts, caller);\n  }).then(function (readUrl) {\n    return fetchUtil_1.fetchPrivate(readUrl);\n  }).then(function (response) {\n    if (response.status !== 200) {\n      if (response.status === 404) {\n        logger_1.Logger.debug(\"getFile \".concat(path, \" returned 404, returning null\"));\n        return null;\n      } else {\n        throw new Error(\"getFile \".concat(path, \" failed with HTTP status \").concat(response.status));\n      }\n    }\n\n    var contentType = response.headers.get('Content-Type');\n\n    if (forceText || contentType === null || contentType.startsWith('text') || contentType === 'application/json') {\n      return response.text();\n    } else {\n      return response.arrayBuffer();\n    }\n  });\n}\n/* Handle fetching an unencrypted file, its associated signature\n *  and then validate it. Handles both multi-player reads and reads\n *  from own storage.\n * @private\n * @ignore\n */\n\n\nfunction getFileSignedUnencrypted(path, opt, caller) {\n  // future optimization note:\n  //    in the case of _multi-player_ reads, this does a lot of excess\n  //    profile lookups to figure out where to read files\n  //    do browsers cache all these requests if Content-Cache is set?\n  return Promise.all([getFileContents(path, opt.app, opt.username, opt.zoneFileLookupURL, false, caller), getFileContents(\"\".concat(path).concat(SIGNATURE_FILE_SUFFIX), opt.app, opt.username, opt.zoneFileLookupURL, true, caller), getGaiaAddress(opt.app, opt.username, opt.zoneFileLookupURL, caller)]).then(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 3),\n        fileContents = _ref2[0],\n        signatureContents = _ref2[1],\n        gaiaAddress = _ref2[2];\n\n    if (!fileContents) {\n      return fileContents;\n    }\n\n    if (!gaiaAddress) {\n      throw new errors_1.SignatureVerificationError('Failed to get gaia address for verification of: ' + \"\".concat(path));\n    }\n\n    if (!signatureContents || typeof signatureContents !== 'string') {\n      throw new errors_1.SignatureVerificationError('Failed to obtain signature for file: ' + \"\".concat(path, \" -- looked in \").concat(path).concat(SIGNATURE_FILE_SUFFIX));\n    }\n\n    var signature;\n    var publicKey;\n\n    try {\n      var sigObject = JSON.parse(signatureContents);\n      signature = sigObject.signature;\n      publicKey = sigObject.publicKey;\n    } catch (err) {\n      if (err instanceof SyntaxError) {\n        throw new Error('Failed to parse signature content JSON ' + \"(path: \".concat(path).concat(SIGNATURE_FILE_SUFFIX, \")\") + ' The content may be corrupted.');\n      } else {\n        throw err;\n      }\n    }\n\n    var signerAddress = keys_1.publicKeyToAddress(publicKey);\n\n    if (gaiaAddress !== signerAddress) {\n      throw new errors_1.SignatureVerificationError(\"Signer pubkey address (\".concat(signerAddress, \") doesn't\") + \" match gaia address (\".concat(gaiaAddress, \")\"));\n    } else if (!ec_1.verifyECDSA(fileContents, publicKey, signature)) {\n      throw new errors_1.SignatureVerificationError('Contents do not match ECDSA signature: ' + \"path: \".concat(path, \", signature: \").concat(path).concat(SIGNATURE_FILE_SUFFIX));\n    } else {\n      return fileContents;\n    }\n  });\n}\n/* Handle signature verification and decryption for contents which are\n *  expected to be signed and encrypted. This works for single and\n *  multiplayer reads. In the case of multiplayer reads, it uses the\n *  gaia address for verification of the claimed public key.\n * @private\n * @ignore\n */\n\n\nfunction handleSignedEncryptedContents(caller, path, storedContents, app, username, zoneFileLookupURL) {\n  var appPrivateKey = caller.loadUserData().appPrivateKey;\n  var appPublicKey = keys_1.getPublicKeyFromPrivate(appPrivateKey);\n  var addressPromise;\n\n  if (username) {\n    addressPromise = getGaiaAddress(app, username, zoneFileLookupURL, caller);\n  } else {\n    var address = keys_1.publicKeyToAddress(appPublicKey);\n    addressPromise = Promise.resolve(address);\n  }\n\n  return addressPromise.then(function (address) {\n    if (!address) {\n      throw new errors_1.SignatureVerificationError('Failed to get gaia address for verification of: ' + \"\".concat(path));\n    }\n\n    var sigObject;\n\n    try {\n      sigObject = JSON.parse(storedContents);\n    } catch (err) {\n      if (err instanceof SyntaxError) {\n        throw new Error('Failed to parse encrypted, signed content JSON. The content may not ' + 'be encrypted. If using getFile, try passing' + ' { verify: false, decrypt: false }.');\n      } else {\n        throw err;\n      }\n    }\n\n    var signature = sigObject.signature;\n    var signerPublicKey = sigObject.publicKey;\n    var cipherText = sigObject.cipherText;\n    var signerAddress = keys_1.publicKeyToAddress(signerPublicKey);\n\n    if (!signerPublicKey || !cipherText || !signature) {\n      throw new errors_1.SignatureVerificationError('Failed to get signature verification data from file:' + \" \".concat(path));\n    } else if (signerAddress !== address) {\n      throw new errors_1.SignatureVerificationError(\"Signer pubkey address (\".concat(signerAddress, \") doesn't\") + \" match gaia address (\".concat(address, \")\"));\n    } else if (!ec_1.verifyECDSA(cipherText, signerPublicKey, signature)) {\n      throw new errors_1.SignatureVerificationError('Contents do not match ECDSA signature in file:' + \" \".concat(path));\n    } else {\n      return caller.decryptContent(cipherText);\n    }\n  });\n}\n/**\n * Retrieves the specified file from the app's data store.\n * @param {String} path - the path to the file to read\n * @returns {Promise} that resolves to the raw data in the file\n * or rejects with an error\n */\n\n\nfunction getFile(path, options, caller) {\n  var defaults = {\n    decrypt: true,\n    verify: false,\n    username: null,\n    app: utils_1.getGlobalObject('location', {\n      returnEmptyObject: true\n    }).origin,\n    zoneFileLookupURL: null\n  };\n  var opt = Object.assign({}, defaults, options);\n\n  if (!caller) {\n    caller = new userSession_1.UserSession();\n  } // in the case of signature verification, but no\n  //  encryption expected, need to fetch _two_ files.\n\n\n  if (opt.verify && !opt.decrypt) {\n    return getFileSignedUnencrypted(path, opt, caller);\n  }\n\n  return getFileContents(path, opt.app, opt.username, opt.zoneFileLookupURL, !!opt.decrypt, caller).then(function (storedContents) {\n    if (storedContents === null) {\n      return storedContents;\n    } else if (opt.decrypt && !opt.verify) {\n      if (typeof storedContents !== 'string') {\n        throw new Error('Expected to get back a string for the cipherText');\n      }\n\n      return caller.decryptContent(storedContents);\n    } else if (opt.decrypt && opt.verify) {\n      if (typeof storedContents !== 'string') {\n        throw new Error('Expected to get back a string for the cipherText');\n      }\n\n      return handleSignedEncryptedContents(caller, path, storedContents, opt.app, opt.username, opt.zoneFileLookupURL);\n    } else if (!opt.verify && !opt.decrypt) {\n      return storedContents;\n    } else {\n      throw new Error('Should be unreachable.');\n    }\n  });\n}\n\nexports.getFile = getFile;\n/**\n * Stores the data provided in the app's data store to to the file specified.\n * @param {String} path - the path to store the data in\n * @param {String|Buffer} content - the data to store in the file\n * @return {Promise} that resolves if the operation succeed and rejects\n * if it failed\n */\n\nfunction putFile(path, content, options, caller) {\n  return __awaiter(this, void 0, void 0,\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee4() {\n    var defaults, opt, contentType, privateKey, publicKey, signatureObject, signatureContent, _gaiaHubConfig, fileUrls, freshHubConfig, _fileUrls, cipherText, _signatureObject, signedCipherObject, gaiaHubConfig, _freshHubConfig, file;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            defaults = {\n              encrypt: true,\n              sign: false,\n              contentType: ''\n            };\n            opt = Object.assign({}, defaults, options);\n            contentType = opt.contentType;\n\n            if (!contentType) {\n              contentType = typeof content === 'string' ? 'text/plain; charset=utf-8' : 'application/octet-stream';\n            }\n\n            if (!caller) {\n              caller = new userSession_1.UserSession();\n            } // First, let's figure out if we need to get public/private keys,\n            //  or if they were passed in\n\n\n            privateKey = '';\n            publicKey = '';\n\n            if (opt.sign) {\n              if (typeof opt.sign === 'string') {\n                privateKey = opt.sign;\n              } else {\n                privateKey = caller.loadUserData().appPrivateKey;\n              }\n            }\n\n            if (opt.encrypt) {\n              if (typeof opt.encrypt === 'string') {\n                publicKey = opt.encrypt;\n              } else {\n                if (!privateKey) {\n                  privateKey = caller.loadUserData().appPrivateKey;\n                }\n\n                publicKey = keys_1.getPublicKeyFromPrivate(privateKey);\n              }\n            } // In the case of signing, but *not* encrypting,\n            //   we perform two uploads. So the control-flow\n            //   here will return there.\n\n\n            if (!(!opt.encrypt && opt.sign)) {\n              _context4.next = 31;\n              break;\n            }\n\n            signatureObject = ec_1.signECDSA(privateKey, content);\n            signatureContent = JSON.stringify(signatureObject);\n            _context4.next = 14;\n            return caller.getOrSetLocalGaiaHubConnection();\n\n          case 14:\n            _gaiaHubConfig = _context4.sent;\n            _context4.prev = 15;\n            _context4.next = 18;\n            return Promise.all([hub_1.uploadToGaiaHub(path, content, _gaiaHubConfig, contentType), hub_1.uploadToGaiaHub(\"\".concat(path).concat(SIGNATURE_FILE_SUFFIX), signatureContent, _gaiaHubConfig, 'application/json')]);\n\n          case 18:\n            fileUrls = _context4.sent;\n            return _context4.abrupt(\"return\", fileUrls[0]);\n\n          case 22:\n            _context4.prev = 22;\n            _context4.t0 = _context4[\"catch\"](15);\n            _context4.next = 26;\n            return caller.setLocalGaiaHubConnection();\n\n          case 26:\n            freshHubConfig = _context4.sent;\n            _context4.next = 29;\n            return Promise.all([hub_1.uploadToGaiaHub(path, content, freshHubConfig, contentType), hub_1.uploadToGaiaHub(\"\".concat(path).concat(SIGNATURE_FILE_SUFFIX), signatureContent, freshHubConfig, 'application/json')]);\n\n          case 29:\n            _fileUrls = _context4.sent;\n            return _context4.abrupt(\"return\", _fileUrls[0]);\n\n          case 31:\n            // In all other cases, we only need one upload.\n            if (opt.encrypt && !opt.sign) {\n              content = encryptContent(content, {\n                publicKey: publicKey\n              });\n              contentType = 'application/json';\n            } else if (opt.encrypt && opt.sign) {\n              cipherText = encryptContent(content, {\n                publicKey: publicKey\n              });\n              _signatureObject = ec_1.signECDSA(privateKey, cipherText);\n              signedCipherObject = {\n                signature: _signatureObject.signature,\n                publicKey: _signatureObject.publicKey,\n                cipherText: cipherText\n              };\n              content = JSON.stringify(signedCipherObject);\n              contentType = 'application/json';\n            }\n\n            _context4.next = 34;\n            return caller.getOrSetLocalGaiaHubConnection();\n\n          case 34:\n            gaiaHubConfig = _context4.sent;\n            _context4.prev = 35;\n            _context4.next = 38;\n            return hub_1.uploadToGaiaHub(path, content, gaiaHubConfig, contentType);\n\n          case 38:\n            return _context4.abrupt(\"return\", _context4.sent);\n\n          case 41:\n            _context4.prev = 41;\n            _context4.t1 = _context4[\"catch\"](35);\n            _context4.next = 45;\n            return caller.setLocalGaiaHubConnection();\n\n          case 45:\n            _freshHubConfig = _context4.sent;\n            _context4.next = 48;\n            return hub_1.uploadToGaiaHub(path, content, _freshHubConfig, contentType);\n\n          case 48:\n            file = _context4.sent;\n            return _context4.abrupt(\"return\", file);\n\n          case 50:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, null, [[15, 22], [35, 41]]);\n  }));\n}\n\nexports.putFile = putFile;\n/**\n * Deletes the specified file from the app's data store.\n * @param path - The path to the file to delete.\n * @param options - Optional options object.\n * @param options.wasSigned - Set to true if the file was originally signed\n * in order for the corresponding signature file to also be deleted.\n * @returns Resolves when the file has been removed or rejects with an error.\n */\n\nfunction deleteFile(path, options, caller) {\n  return __awaiter(this, void 0, void 0,\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee5() {\n    var gaiaHubConfig, opts, freshHubConfig, _freshHubConfig2;\n\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            if (!caller) {\n              caller = new userSession_1.UserSession();\n            }\n\n            _context5.next = 3;\n            return caller.getOrSetLocalGaiaHubConnection();\n\n          case 3:\n            gaiaHubConfig = _context5.sent;\n            opts = Object.assign({}, options);\n\n            if (!opts.wasSigned) {\n              _context5.next = 24;\n              break;\n            }\n\n            _context5.prev = 6;\n            _context5.next = 9;\n            return hub_1.deleteFromGaiaHub(path, gaiaHubConfig);\n\n          case 9:\n            _context5.next = 11;\n            return hub_1.deleteFromGaiaHub(\"\".concat(path).concat(SIGNATURE_FILE_SUFFIX), gaiaHubConfig);\n\n          case 11:\n            _context5.next = 22;\n            break;\n\n          case 13:\n            _context5.prev = 13;\n            _context5.t0 = _context5[\"catch\"](6);\n            _context5.next = 17;\n            return caller.setLocalGaiaHubConnection();\n\n          case 17:\n            freshHubConfig = _context5.sent;\n            _context5.next = 20;\n            return hub_1.deleteFromGaiaHub(path, freshHubConfig);\n\n          case 20:\n            _context5.next = 22;\n            return hub_1.deleteFromGaiaHub(\"\".concat(path).concat(SIGNATURE_FILE_SUFFIX), gaiaHubConfig);\n\n          case 22:\n            _context5.next = 36;\n            break;\n\n          case 24:\n            _context5.prev = 24;\n            _context5.next = 27;\n            return hub_1.deleteFromGaiaHub(path, gaiaHubConfig);\n\n          case 27:\n            _context5.next = 36;\n            break;\n\n          case 29:\n            _context5.prev = 29;\n            _context5.t1 = _context5[\"catch\"](24);\n            _context5.next = 33;\n            return caller.setLocalGaiaHubConnection();\n\n          case 33:\n            _freshHubConfig2 = _context5.sent;\n            _context5.next = 36;\n            return hub_1.deleteFromGaiaHub(path, _freshHubConfig2);\n\n          case 36:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5, null, [[6, 13], [24, 29]]);\n  }));\n}\n\nexports.deleteFile = deleteFile;\n/**\n * Get the app storage bucket URL\n * @param {String} gaiaHubUrl - the gaia hub URL\n * @param {String} appPrivateKey - the app private key used to generate the app address\n * @returns {Promise} That resolves to the URL of the app index file\n * or rejects if it fails\n */\n\nfunction getAppBucketUrl(gaiaHubUrl, appPrivateKey) {\n  return hub_1.getBucketUrl(gaiaHubUrl, appPrivateKey);\n}\n\nexports.getAppBucketUrl = getAppBucketUrl;\n/**\n * Loop over the list of files in a Gaia hub, and run a callback on each entry.\n * Not meant to be called by external clients.\n * @param {GaiaHubConfig} hubConfig - the Gaia hub config\n * @param {String | null} page - the page ID\n * @param {number} callCount - the loop count\n * @param {number} fileCount - the number of files listed so far\n * @param {function} callback - the callback to invoke on each file.  If it returns a falsey\n *  value, then the loop stops.  If it returns a truthy value, the loop continues.\n * @returns {Promise} that resolves to the number of files listed.\n * @private\n * @ignore\n */\n\nfunction listFilesLoop(caller, hubConfig, page, callCount, fileCount, callback) {\n  return __awaiter(this, void 0, void 0,\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee6() {\n    var response, pageRequest, fetchOptions, freshHubConfig, responseText, responseJSON, entries, nextPage, i, rc;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            if (!(callCount > 65536)) {\n              _context6.next = 2;\n              break;\n            }\n\n            throw new Error('Too many entries to list');\n\n          case 2:\n            _context6.t0 = hubConfig;\n\n            if (_context6.t0) {\n              _context6.next = 7;\n              break;\n            }\n\n            _context6.next = 6;\n            return caller.getOrSetLocalGaiaHubConnection();\n\n          case 6:\n            _context6.t0 = _context6.sent;\n\n          case 7:\n            hubConfig = _context6.t0;\n            _context6.prev = 8;\n            pageRequest = JSON.stringify({\n              page: page\n            });\n            fetchOptions = {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json',\n                'Content-Length': \"\".concat(pageRequest.length),\n                Authorization: \"bearer \".concat(hubConfig.token)\n              },\n              body: pageRequest\n            };\n            _context6.next = 13;\n            return fetchUtil_1.fetchPrivate(\"\".concat(hubConfig.server, \"/list-files/\").concat(hubConfig.address), fetchOptions);\n\n          case 13:\n            response = _context6.sent;\n\n            if (response.ok) {\n              _context6.next = 16;\n              break;\n            }\n\n            throw new Error(\"listFiles failed with HTTP status \".concat(response.status));\n\n          case 16:\n            _context6.next = 26;\n            break;\n\n          case 18:\n            _context6.prev = 18;\n            _context6.t1 = _context6[\"catch\"](8);\n\n            if (!(callCount === 0)) {\n              _context6.next = 25;\n              break;\n            }\n\n            _context6.next = 23;\n            return caller.setLocalGaiaHubConnection();\n\n          case 23:\n            freshHubConfig = _context6.sent;\n            return _context6.abrupt(\"return\", listFilesLoop(caller, freshHubConfig, page, callCount + 1, 0, callback));\n\n          case 25:\n            throw _context6.t1;\n\n          case 26:\n            _context6.next = 28;\n            return response.text();\n\n          case 28:\n            responseText = _context6.sent;\n            responseJSON = JSON.parse(responseText);\n            entries = responseJSON.entries;\n            nextPage = responseJSON.page;\n\n            if (!(entries === null || entries === undefined)) {\n              _context6.next = 34;\n              break;\n            }\n\n            throw new Error('Bad listFiles response: no entries');\n\n          case 34:\n            i = 0;\n\n          case 35:\n            if (!(i < entries.length)) {\n              _context6.next = 42;\n              break;\n            }\n\n            rc = callback(entries[i]);\n\n            if (rc) {\n              _context6.next = 39;\n              break;\n            }\n\n            return _context6.abrupt(\"return\", fileCount + i);\n\n          case 39:\n            i++;\n            _context6.next = 35;\n            break;\n\n          case 42:\n            if (!(nextPage && entries.length > 0)) {\n              _context6.next = 46;\n              break;\n            }\n\n            return _context6.abrupt(\"return\", listFilesLoop(caller, hubConfig, nextPage, callCount + 1, fileCount + entries.length, callback));\n\n          case 46:\n            return _context6.abrupt(\"return\", fileCount + entries.length);\n\n          case 47:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6, null, [[8, 18]]);\n  }));\n}\n/**\n * List the set of files in this application's Gaia storage bucket.\n * @param {function} callback - a callback to invoke on each named file that\n * returns `true` to continue the listing operation or `false` to end it\n * @return {Promise} that resolves to the number of files listed\n */\n\n\nfunction listFiles(callback, caller) {\n  caller = caller || new userSession_1.UserSession();\n  return listFilesLoop(caller, null, null, 0, 0, callback);\n}\n\nexports.listFiles = listFiles;","map":{"version":3,"sources":["../../src/storage/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst hub_1 = require(\"./hub\");\nexports.connectToGaiaHub = hub_1.connectToGaiaHub;\nexports.uploadToGaiaHub = hub_1.uploadToGaiaHub;\nexports.BLOCKSTACK_GAIA_HUB_LABEL = hub_1.BLOCKSTACK_GAIA_HUB_LABEL;\n// export { type GaiaHubConfig } from './hub'\nconst ec_1 = require(\"../encryption/ec\");\nconst keys_1 = require(\"../keys\");\nconst profileLookup_1 = require(\"../profiles/profileLookup\");\nconst errors_1 = require(\"../errors\");\nconst logger_1 = require(\"../logger\");\nconst userSession_1 = require(\"../auth/userSession\");\nconst utils_1 = require(\"../utils\");\nconst fetchUtil_1 = require(\"../fetchUtil\");\nconst SIGNATURE_FILE_SUFFIX = '.sig';\n/**\n * Fetch the public read URL of a user file for the specified app.\n * @param {String} path - the path to the file to read\n * @param {String} username - The Blockstack ID of the user to look up\n * @param {String} appOrigin - The app origin\n * @param {String} [zoneFileLookupURL=null] - The URL\n * to use for zonefile lookup. If falsey, this will use the\n * blockstack.js's [[getNameInfo]] function instead.\n * @return {Promise<string>} that resolves to the public read URL of the file\n * or rejects with an error\n */\nfunction getUserAppFileUrl(path, username, appOrigin, zoneFileLookupURL) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const profile = yield profileLookup_1.lookupProfile(username, zoneFileLookupURL);\n        let bucketUrl = null;\n        if (profile.hasOwnProperty('apps')) {\n            if (profile.apps.hasOwnProperty(appOrigin)) {\n                const url = profile.apps[appOrigin];\n                const bucket = url.replace(/\\/?(\\?|#|$)/, '/$1');\n                bucketUrl = `${bucket}${path}`;\n            }\n        }\n        return bucketUrl;\n    });\n}\nexports.getUserAppFileUrl = getUserAppFileUrl;\n/**\n *\n *\n * @deprecated\n * #### v19 Use [[UserSession.encryptContent]].\n *\n * Encrypts the data provided with the app public key.\n * @param {String|Buffer} content - data to encrypt\n * @param {Object} [options=null] - options object\n * @param {String} options.publicKey - the hex string of the ECDSA public\n * key to use for encryption. If not provided, will use user's appPublicKey.\n * @return {String} Stringified ciphertext object\n */\nfunction encryptContent(content, options, caller) {\n    const opts = Object.assign({}, options);\n    if (!opts.publicKey) {\n        const privateKey = (caller || new userSession_1.UserSession()).loadUserData().appPrivateKey;\n        opts.publicKey = keys_1.getPublicKeyFromPrivate(privateKey);\n    }\n    const cipherObject = ec_1.encryptECIES(opts.publicKey, content);\n    return JSON.stringify(cipherObject);\n}\nexports.encryptContent = encryptContent;\n/**\n *\n * @deprecated\n * #### v19 Use [[UserSession.decryptContent]].\n *\n * Decrypts data encrypted with `encryptContent` with the\n * transit private key.\n * @param {String|Buffer} content - encrypted content.\n * @param {Object} [options=null] - options object\n * @param {String} options.privateKey - the hex string of the ECDSA private\n * key to use for decryption. If not provided, will use user's appPrivateKey.\n * @return {String|Buffer} decrypted content.\n */\nfunction decryptContent(content, options, caller) {\n    const opts = Object.assign({}, options);\n    if (!opts.privateKey) {\n        opts.privateKey = (caller || new userSession_1.UserSession()).loadUserData().appPrivateKey;\n    }\n    try {\n        const cipherObject = JSON.parse(content);\n        return ec_1.decryptECIES(opts.privateKey, cipherObject);\n    }\n    catch (err) {\n        if (err instanceof SyntaxError) {\n            throw new Error('Failed to parse encrypted content JSON. The content may not '\n                + 'be encrypted. If using getFile, try passing { decrypt: false }.');\n        }\n        else {\n            throw err;\n        }\n    }\n}\nexports.decryptContent = decryptContent;\n/* Get the gaia address used for servicing multiplayer reads for the given\n * (username, app) pair.\n * @private\n * @ignore\n */\nfunction getGaiaAddress(app, username, zoneFileLookupURL, caller) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const opts = normalizeOptions({ app, username }, caller);\n        let fileUrl;\n        if (username) {\n            fileUrl = yield getUserAppFileUrl('/', opts.username, opts.app, zoneFileLookupURL);\n        }\n        else {\n            if (!caller) {\n                caller = new userSession_1.UserSession();\n            }\n            const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();\n            fileUrl = yield hub_1.getFullReadUrl('/', gaiaHubConfig);\n        }\n        const matches = fileUrl.match(/([13][a-km-zA-HJ-NP-Z0-9]{26,35})/);\n        if (!matches) {\n            throw new Error('Failed to parse gaia address');\n        }\n        return matches[matches.length - 1];\n    });\n}\n/**\n * @param {Object} [options=null] - options object\n * @param {String} options.username - the Blockstack ID to lookup for multi-player storage\n * @param {String} options.app - the app to lookup for multi-player storage -\n * defaults to current origin\n *\n * @ignore\n */\nfunction normalizeOptions(options, caller) {\n    const opts = Object.assign({}, options);\n    if (opts.username) {\n        if (!opts.app) {\n            const appConfig = (caller || new userSession_1.UserSession()).appConfig;\n            if (!appConfig) {\n                throw new errors_1.InvalidStateError('Missing AppConfig');\n            }\n            opts.app = appConfig.appDomain;\n        }\n    }\n    return opts;\n}\n/**\n * @deprecated\n * #### v19 Use [[UserSession.getFileUrl]] instead.\n *\n * @param {String} path - the path to the file to read\n * @returns {Promise<string>} that resolves to the URL or rejects with an error\n */\nfunction getFileUrl(path, options, caller) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const opts = normalizeOptions(options, caller);\n        let readUrl;\n        if (opts.username) {\n            readUrl = yield getUserAppFileUrl(path, opts.username, opts.app, opts.zoneFileLookupURL);\n        }\n        else {\n            const gaiaHubConfig = yield (caller || new userSession_1.UserSession()).getOrSetLocalGaiaHubConnection();\n            readUrl = yield hub_1.getFullReadUrl(path, gaiaHubConfig);\n        }\n        if (!readUrl) {\n            throw new Error('Missing readURL');\n        }\n        else {\n            return readUrl;\n        }\n    });\n}\nexports.getFileUrl = getFileUrl;\n/* Handle fetching the contents from a given path. Handles both\n *  multi-player reads and reads from own storage.\n * @private\n * @ignore\n */\nfunction getFileContents(path, app, username, zoneFileLookupURL, forceText, caller) {\n    return Promise.resolve()\n        .then(() => {\n        const opts = { app, username, zoneFileLookupURL };\n        return getFileUrl(path, opts, caller);\n    })\n        .then(readUrl => fetchUtil_1.fetchPrivate(readUrl))\n        .then((response) => {\n        if (response.status !== 200) {\n            if (response.status === 404) {\n                logger_1.Logger.debug(`getFile ${path} returned 404, returning null`);\n                return null;\n            }\n            else {\n                throw new Error(`getFile ${path} failed with HTTP status ${response.status}`);\n            }\n        }\n        const contentType = response.headers.get('Content-Type');\n        if (forceText || contentType === null\n            || contentType.startsWith('text')\n            || contentType === 'application/json') {\n            return response.text();\n        }\n        else {\n            return response.arrayBuffer();\n        }\n    });\n}\n/* Handle fetching an unencrypted file, its associated signature\n *  and then validate it. Handles both multi-player reads and reads\n *  from own storage.\n * @private\n * @ignore\n */\nfunction getFileSignedUnencrypted(path, opt, caller) {\n    // future optimization note:\n    //    in the case of _multi-player_ reads, this does a lot of excess\n    //    profile lookups to figure out where to read files\n    //    do browsers cache all these requests if Content-Cache is set?\n    return Promise.all([getFileContents(path, opt.app, opt.username, opt.zoneFileLookupURL, false, caller),\n        getFileContents(`${path}${SIGNATURE_FILE_SUFFIX}`, opt.app, opt.username, opt.zoneFileLookupURL, true, caller),\n        getGaiaAddress(opt.app, opt.username, opt.zoneFileLookupURL, caller)])\n        .then(([fileContents, signatureContents, gaiaAddress]) => {\n        if (!fileContents) {\n            return fileContents;\n        }\n        if (!gaiaAddress) {\n            throw new errors_1.SignatureVerificationError('Failed to get gaia address for verification of: '\n                + `${path}`);\n        }\n        if (!signatureContents || typeof signatureContents !== 'string') {\n            throw new errors_1.SignatureVerificationError('Failed to obtain signature for file: '\n                + `${path} -- looked in ${path}${SIGNATURE_FILE_SUFFIX}`);\n        }\n        let signature;\n        let publicKey;\n        try {\n            const sigObject = JSON.parse(signatureContents);\n            signature = sigObject.signature;\n            publicKey = sigObject.publicKey;\n        }\n        catch (err) {\n            if (err instanceof SyntaxError) {\n                throw new Error('Failed to parse signature content JSON '\n                    + `(path: ${path}${SIGNATURE_FILE_SUFFIX})`\n                    + ' The content may be corrupted.');\n            }\n            else {\n                throw err;\n            }\n        }\n        const signerAddress = keys_1.publicKeyToAddress(publicKey);\n        if (gaiaAddress !== signerAddress) {\n            throw new errors_1.SignatureVerificationError(`Signer pubkey address (${signerAddress}) doesn't`\n                + ` match gaia address (${gaiaAddress})`);\n        }\n        else if (!ec_1.verifyECDSA(fileContents, publicKey, signature)) {\n            throw new errors_1.SignatureVerificationError('Contents do not match ECDSA signature: '\n                + `path: ${path}, signature: ${path}${SIGNATURE_FILE_SUFFIX}`);\n        }\n        else {\n            return fileContents;\n        }\n    });\n}\n/* Handle signature verification and decryption for contents which are\n *  expected to be signed and encrypted. This works for single and\n *  multiplayer reads. In the case of multiplayer reads, it uses the\n *  gaia address for verification of the claimed public key.\n * @private\n * @ignore\n */\nfunction handleSignedEncryptedContents(caller, path, storedContents, app, username, zoneFileLookupURL) {\n    const appPrivateKey = caller.loadUserData().appPrivateKey;\n    const appPublicKey = keys_1.getPublicKeyFromPrivate(appPrivateKey);\n    let addressPromise;\n    if (username) {\n        addressPromise = getGaiaAddress(app, username, zoneFileLookupURL, caller);\n    }\n    else {\n        const address = keys_1.publicKeyToAddress(appPublicKey);\n        addressPromise = Promise.resolve(address);\n    }\n    return addressPromise.then((address) => {\n        if (!address) {\n            throw new errors_1.SignatureVerificationError('Failed to get gaia address for verification of: '\n                + `${path}`);\n        }\n        let sigObject;\n        try {\n            sigObject = JSON.parse(storedContents);\n        }\n        catch (err) {\n            if (err instanceof SyntaxError) {\n                throw new Error('Failed to parse encrypted, signed content JSON. The content may not '\n                    + 'be encrypted. If using getFile, try passing'\n                    + ' { verify: false, decrypt: false }.');\n            }\n            else {\n                throw err;\n            }\n        }\n        const signature = sigObject.signature;\n        const signerPublicKey = sigObject.publicKey;\n        const cipherText = sigObject.cipherText;\n        const signerAddress = keys_1.publicKeyToAddress(signerPublicKey);\n        if (!signerPublicKey || !cipherText || !signature) {\n            throw new errors_1.SignatureVerificationError('Failed to get signature verification data from file:'\n                + ` ${path}`);\n        }\n        else if (signerAddress !== address) {\n            throw new errors_1.SignatureVerificationError(`Signer pubkey address (${signerAddress}) doesn't`\n                + ` match gaia address (${address})`);\n        }\n        else if (!ec_1.verifyECDSA(cipherText, signerPublicKey, signature)) {\n            throw new errors_1.SignatureVerificationError('Contents do not match ECDSA signature in file:'\n                + ` ${path}`);\n        }\n        else {\n            return caller.decryptContent(cipherText);\n        }\n    });\n}\n/**\n * Retrieves the specified file from the app's data store.\n * @param {String} path - the path to the file to read\n * @returns {Promise} that resolves to the raw data in the file\n * or rejects with an error\n */\nfunction getFile(path, options, caller) {\n    const defaults = {\n        decrypt: true,\n        verify: false,\n        username: null,\n        app: utils_1.getGlobalObject('location', { returnEmptyObject: true }).origin,\n        zoneFileLookupURL: null\n    };\n    const opt = Object.assign({}, defaults, options);\n    if (!caller) {\n        caller = new userSession_1.UserSession();\n    }\n    // in the case of signature verification, but no\n    //  encryption expected, need to fetch _two_ files.\n    if (opt.verify && !opt.decrypt) {\n        return getFileSignedUnencrypted(path, opt, caller);\n    }\n    return getFileContents(path, opt.app, opt.username, opt.zoneFileLookupURL, !!opt.decrypt, caller)\n        .then((storedContents) => {\n        if (storedContents === null) {\n            return storedContents;\n        }\n        else if (opt.decrypt && !opt.verify) {\n            if (typeof storedContents !== 'string') {\n                throw new Error('Expected to get back a string for the cipherText');\n            }\n            return caller.decryptContent(storedContents);\n        }\n        else if (opt.decrypt && opt.verify) {\n            if (typeof storedContents !== 'string') {\n                throw new Error('Expected to get back a string for the cipherText');\n            }\n            return handleSignedEncryptedContents(caller, path, storedContents, opt.app, opt.username, opt.zoneFileLookupURL);\n        }\n        else if (!opt.verify && !opt.decrypt) {\n            return storedContents;\n        }\n        else {\n            throw new Error('Should be unreachable.');\n        }\n    });\n}\nexports.getFile = getFile;\n/**\n * Stores the data provided in the app's data store to to the file specified.\n * @param {String} path - the path to store the data in\n * @param {String|Buffer} content - the data to store in the file\n * @return {Promise} that resolves if the operation succeed and rejects\n * if it failed\n */\nfunction putFile(path, content, options, caller) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const defaults = {\n            encrypt: true,\n            sign: false,\n            contentType: ''\n        };\n        const opt = Object.assign({}, defaults, options);\n        let { contentType } = opt;\n        if (!contentType) {\n            contentType = (typeof (content) === 'string') ? 'text/plain; charset=utf-8' : 'application/octet-stream';\n        }\n        if (!caller) {\n            caller = new userSession_1.UserSession();\n        }\n        // First, let's figure out if we need to get public/private keys,\n        //  or if they were passed in\n        let privateKey = '';\n        let publicKey = '';\n        if (opt.sign) {\n            if (typeof (opt.sign) === 'string') {\n                privateKey = opt.sign;\n            }\n            else {\n                privateKey = caller.loadUserData().appPrivateKey;\n            }\n        }\n        if (opt.encrypt) {\n            if (typeof (opt.encrypt) === 'string') {\n                publicKey = opt.encrypt;\n            }\n            else {\n                if (!privateKey) {\n                    privateKey = caller.loadUserData().appPrivateKey;\n                }\n                publicKey = keys_1.getPublicKeyFromPrivate(privateKey);\n            }\n        }\n        // In the case of signing, but *not* encrypting,\n        //   we perform two uploads. So the control-flow\n        //   here will return there.\n        if (!opt.encrypt && opt.sign) {\n            const signatureObject = ec_1.signECDSA(privateKey, content);\n            const signatureContent = JSON.stringify(signatureObject);\n            const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();\n            try {\n                const fileUrls = yield Promise.all([\n                    hub_1.uploadToGaiaHub(path, content, gaiaHubConfig, contentType),\n                    hub_1.uploadToGaiaHub(`${path}${SIGNATURE_FILE_SUFFIX}`, signatureContent, gaiaHubConfig, 'application/json')\n                ]);\n                return fileUrls[0];\n            }\n            catch (error) {\n                const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n                const fileUrls = yield Promise.all([\n                    hub_1.uploadToGaiaHub(path, content, freshHubConfig, contentType),\n                    hub_1.uploadToGaiaHub(`${path}${SIGNATURE_FILE_SUFFIX}`, signatureContent, freshHubConfig, 'application/json')\n                ]);\n                return fileUrls[0];\n            }\n        }\n        // In all other cases, we only need one upload.\n        if (opt.encrypt && !opt.sign) {\n            content = encryptContent(content, { publicKey });\n            contentType = 'application/json';\n        }\n        else if (opt.encrypt && opt.sign) {\n            const cipherText = encryptContent(content, { publicKey });\n            const signatureObject = ec_1.signECDSA(privateKey, cipherText);\n            const signedCipherObject = {\n                signature: signatureObject.signature,\n                publicKey: signatureObject.publicKey,\n                cipherText\n            };\n            content = JSON.stringify(signedCipherObject);\n            contentType = 'application/json';\n        }\n        const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();\n        try {\n            return yield hub_1.uploadToGaiaHub(path, content, gaiaHubConfig, contentType);\n        }\n        catch (error) {\n            const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n            const file = yield hub_1.uploadToGaiaHub(path, content, freshHubConfig, contentType);\n            return file;\n        }\n    });\n}\nexports.putFile = putFile;\n/**\n * Deletes the specified file from the app's data store.\n * @param path - The path to the file to delete.\n * @param options - Optional options object.\n * @param options.wasSigned - Set to true if the file was originally signed\n * in order for the corresponding signature file to also be deleted.\n * @returns Resolves when the file has been removed or rejects with an error.\n */\nfunction deleteFile(path, options, caller) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!caller) {\n            caller = new userSession_1.UserSession();\n        }\n        const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();\n        const opts = Object.assign({}, options);\n        if (opts.wasSigned) {\n            // If signed, delete both the content file and the .sig file\n            try {\n                yield hub_1.deleteFromGaiaHub(path, gaiaHubConfig);\n                yield hub_1.deleteFromGaiaHub(`${path}${SIGNATURE_FILE_SUFFIX}`, gaiaHubConfig);\n            }\n            catch (error) {\n                const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n                yield hub_1.deleteFromGaiaHub(path, freshHubConfig);\n                yield hub_1.deleteFromGaiaHub(`${path}${SIGNATURE_FILE_SUFFIX}`, gaiaHubConfig);\n            }\n        }\n        else {\n            try {\n                yield hub_1.deleteFromGaiaHub(path, gaiaHubConfig);\n            }\n            catch (error) {\n                const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n                yield hub_1.deleteFromGaiaHub(path, freshHubConfig);\n            }\n        }\n    });\n}\nexports.deleteFile = deleteFile;\n/**\n * Get the app storage bucket URL\n * @param {String} gaiaHubUrl - the gaia hub URL\n * @param {String} appPrivateKey - the app private key used to generate the app address\n * @returns {Promise} That resolves to the URL of the app index file\n * or rejects if it fails\n */\nfunction getAppBucketUrl(gaiaHubUrl, appPrivateKey) {\n    return hub_1.getBucketUrl(gaiaHubUrl, appPrivateKey);\n}\nexports.getAppBucketUrl = getAppBucketUrl;\n/**\n * Loop over the list of files in a Gaia hub, and run a callback on each entry.\n * Not meant to be called by external clients.\n * @param {GaiaHubConfig} hubConfig - the Gaia hub config\n * @param {String | null} page - the page ID\n * @param {number} callCount - the loop count\n * @param {number} fileCount - the number of files listed so far\n * @param {function} callback - the callback to invoke on each file.  If it returns a falsey\n *  value, then the loop stops.  If it returns a truthy value, the loop continues.\n * @returns {Promise} that resolves to the number of files listed.\n * @private\n * @ignore\n */\nfunction listFilesLoop(caller, hubConfig, page, callCount, fileCount, callback) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (callCount > 65536) {\n            // this is ridiculously huge, and probably indicates\n            // a faulty Gaia hub anyway (e.g. on that serves endless data)\n            throw new Error('Too many entries to list');\n        }\n        hubConfig = hubConfig || (yield caller.getOrSetLocalGaiaHubConnection());\n        let response;\n        try {\n            const pageRequest = JSON.stringify({ page });\n            const fetchOptions = {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Content-Length': `${pageRequest.length}`,\n                    Authorization: `bearer ${hubConfig.token}`\n                },\n                body: pageRequest\n            };\n            response = yield fetchUtil_1.fetchPrivate(`${hubConfig.server}/list-files/${hubConfig.address}`, fetchOptions);\n            if (!response.ok) {\n                throw new Error(`listFiles failed with HTTP status ${response.status}`);\n            }\n        }\n        catch (error) {\n            // If error occurs on the first call, perform a gaia re-connection and retry.\n            // Same logic as other gaia requests (putFile, getFile, etc).\n            if (callCount === 0) {\n                const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n                return listFilesLoop(caller, freshHubConfig, page, callCount + 1, 0, callback);\n            }\n            throw error;\n        }\n        const responseText = yield response.text();\n        const responseJSON = JSON.parse(responseText);\n        const entries = responseJSON.entries;\n        const nextPage = responseJSON.page;\n        if (entries === null || entries === undefined) {\n            // indicates a misbehaving Gaia hub or a misbehaving driver\n            // (i.e. the data is malformed)\n            throw new Error('Bad listFiles response: no entries');\n        }\n        for (let i = 0; i < entries.length; i++) {\n            const rc = callback(entries[i]);\n            if (!rc) {\n                // callback indicates that we're done\n                return fileCount + i;\n            }\n        }\n        if (nextPage && entries.length > 0) {\n            // keep going -- have more entries\n            return listFilesLoop(caller, hubConfig, nextPage, callCount + 1, fileCount + entries.length, callback);\n        }\n        else {\n            // no more entries -- end of data\n            return fileCount + entries.length;\n        }\n    });\n}\n/**\n * List the set of files in this application's Gaia storage bucket.\n * @param {function} callback - a callback to invoke on each named file that\n * returns `true` to continue the listing operation or `false` to end it\n * @return {Promise} that resolves to the number of files listed\n */\nfunction listFiles(callback, caller) {\n    caller = caller || new userSession_1.UserSession();\n    return listFilesLoop(caller, null, null, 0, 0, callback);\n}\nexports.listFiles = listFiles;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}