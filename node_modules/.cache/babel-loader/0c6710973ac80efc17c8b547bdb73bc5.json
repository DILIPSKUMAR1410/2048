{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/aashan/2048/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/aashan/2048/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar base64url_1 = __importDefault(require(\"base64url\"));\n\nvar cryptoClients_1 = require(\"./cryptoClients\");\n\nvar errors_1 = require(\"./errors\");\n\nvar TokenVerifier =\n/*#__PURE__*/\nfunction () {\n  function TokenVerifier(signingAlgorithm, rawPublicKey) {\n    _classCallCheck(this, TokenVerifier);\n\n    if (!(signingAlgorithm && rawPublicKey)) {\n      throw new errors_1.MissingParametersError('a signing algorithm and public key are required');\n    }\n\n    if (typeof signingAlgorithm !== 'string') {\n      throw 'signing algorithm parameter must be a string';\n    }\n\n    signingAlgorithm = signingAlgorithm.toUpperCase();\n\n    if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n      throw 'invalid signing algorithm';\n    }\n\n    this.tokenType = 'JWT';\n    this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n    this.rawPublicKey = rawPublicKey;\n  }\n\n  _createClass(TokenVerifier, [{\n    key: \"verify\",\n    value: function verify(token) {\n      if (typeof token === 'string') {\n        return this.verifyCompact(token);\n      } else if (typeof token === 'object') {\n        return this.verifyExpanded(token);\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"verifyCompact\",\n    value: function verifyCompact(token) {\n      // decompose the token into parts\n      var tokenParts = token.split('.'); // calculate the signing input hash\n\n      var signingInput = tokenParts[0] + '.' + tokenParts[1];\n      var signingInputHash = this.cryptoClient.createHash(signingInput); // extract the signature as a DER array\n\n      var derSignatureBuffer = this.cryptoClient.loadSignature(tokenParts[2]); // verify the signed hash\n\n      return this.cryptoClient.verifyHash(signingInputHash, derSignatureBuffer, this.rawPublicKey);\n    }\n  }, {\n    key: \"verifyExpanded\",\n    value: function verifyExpanded(token) {\n      var _this = this;\n\n      var signingInput = [token['header'].join('.'), base64url_1.default.encode(token['payload'])].join('.');\n      var signingInputHash = this.cryptoClient.createHash(signingInput);\n      var verified = true;\n      token['signature'].map(function (signature) {\n        var derSignatureBuffer = _this.cryptoClient.loadSignature(signature);\n\n        var signatureVerified = _this.cryptoClient.verifyHash(signingInputHash, derSignatureBuffer, _this.rawPublicKey);\n\n        if (!signatureVerified) {\n          verified = false;\n        }\n      });\n      return verified;\n    }\n  }]);\n\n  return TokenVerifier;\n}();\n\nexports.TokenVerifier = TokenVerifier;","map":{"version":3,"sources":["verifier.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,IAAA,WAAA,GAAA,eAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;;AACA,IAAA,eAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;IAGa,a;;;AAMT,yBAAY,gBAAZ,EAAsC,YAAtC,EAA0D;AAAA;;AACtD,QAAI,EAAE,gBAAgB,IAAI,YAAtB,CAAJ,EAAyC;AACrC,YAAM,IAAI,QAAA,CAAA,sBAAJ,CACF,iDADE,CAAN;AAEH;;AACD,QAAI,OAAO,gBAAP,KAA4B,QAAhC,EAA0C;AACtC,YAAM,8CAAN;AACH;;AACD,IAAA,gBAAgB,GAAG,gBAAgB,CAAC,WAAjB,EAAnB;;AACA,QAAI,CAAC,eAAA,CAAA,aAAA,CAAc,cAAd,CAA6B,gBAA7B,CAAL,EAAqD;AACjD,YAAM,2BAAN;AACH;;AACD,SAAK,SAAL,GAAiB,KAAjB;AACA,SAAK,YAAL,GAAoB,eAAA,CAAA,aAAA,CAAc,gBAAd,CAApB;AACA,SAAK,YAAL,GAAoB,YAApB;AACH;;;;2BAEM,K,EAA2B;AAC9B,UAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC3B,eAAO,KAAK,aAAL,CAAmB,KAAnB,CAAP;AACH,OAFD,MAEO,IAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAClC,eAAO,KAAK,cAAL,CAAoB,KAApB,CAAP;AACH,OAFM,MAEA;AACH,eAAO,KAAP;AACH;AACJ;;;kCAEa,K,EAAa;AACvB;AACA,UAAM,UAAU,GAAG,KAAK,CAAC,KAAN,CAAY,GAAZ,CAAnB,CAFuB,CAIvB;;AACA,UAAM,YAAY,GAAG,UAAU,CAAC,CAAD,CAAV,GAAgB,GAAhB,GAAsB,UAAU,CAAC,CAAD,CAArD;AACA,UAAM,gBAAgB,GAAG,KAAK,YAAL,CAAkB,UAAlB,CAA6B,YAA7B,CAAzB,CANuB,CAQvB;;AACA,UAAM,kBAAkB,GAAG,KAAK,YAAL,CAAkB,aAAlB,CAAgC,UAAU,CAAC,CAAD,CAA1C,CAA3B,CATuB,CAWvB;;AACA,aAAO,KAAK,YAAL,CAAkB,UAAlB,CACH,gBADG,EACe,kBADf,EACmC,KAAK,YADxC,CAAP;AAEH;;;mCAEc,K,EAAkB;AAAA;;AAC7B,UAAM,YAAY,GAAG,CACjB,KAAK,CAAC,QAAD,CAAL,CAAgB,IAAhB,CAAqB,GAArB,CADiB,EAEjB,WAAA,CAAA,OAAA,CAAU,MAAV,CAAiB,KAAK,CAAC,SAAD,CAAtB,CAFiB,EAGnB,IAHmB,CAGd,GAHc,CAArB;AAIA,UAAM,gBAAgB,GAAG,KAAK,YAAL,CAAkB,UAAlB,CAA6B,YAA7B,CAAzB;AAEA,UAAI,QAAQ,GAAG,IAAf;AAEA,MAAA,KAAK,CAAC,WAAD,CAAL,CAAmB,GAAnB,CAAuB,UAAC,SAAD,EAAsB;AACzC,YAAM,kBAAkB,GAAG,KAAI,CAAC,YAAL,CAAkB,aAAlB,CAAgC,SAAhC,CAA3B;;AACA,YAAM,iBAAiB,GAAG,KAAI,CAAC,YAAL,CAAkB,UAAlB,CACtB,gBADsB,EACJ,kBADI,EACgB,KAAI,CAAC,YADrB,CAA1B;;AAEA,YAAI,CAAC,iBAAL,EAAwB;AACpB,UAAA,QAAQ,GAAG,KAAX;AACH;AACJ,OAPD;AASA,aAAO,QAAP;AACH;;;;;;AApEL,OAAA,CAAA,aAAA,GAAA,aAAA","sourceRoot":"./","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base64url_1 = __importDefault(require(\"base64url\"));\nconst cryptoClients_1 = require(\"./cryptoClients\");\nconst errors_1 = require(\"./errors\");\nclass TokenVerifier {\n    constructor(signingAlgorithm, rawPublicKey) {\n        if (!(signingAlgorithm && rawPublicKey)) {\n            throw new errors_1.MissingParametersError('a signing algorithm and public key are required');\n        }\n        if (typeof signingAlgorithm !== 'string') {\n            throw 'signing algorithm parameter must be a string';\n        }\n        signingAlgorithm = signingAlgorithm.toUpperCase();\n        if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n            throw 'invalid signing algorithm';\n        }\n        this.tokenType = 'JWT';\n        this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n        this.rawPublicKey = rawPublicKey;\n    }\n    verify(token) {\n        if (typeof token === 'string') {\n            return this.verifyCompact(token);\n        }\n        else if (typeof token === 'object') {\n            return this.verifyExpanded(token);\n        }\n        else {\n            return false;\n        }\n    }\n    verifyCompact(token) {\n        // decompose the token into parts\n        const tokenParts = token.split('.');\n        // calculate the signing input hash\n        const signingInput = tokenParts[0] + '.' + tokenParts[1];\n        const signingInputHash = this.cryptoClient.createHash(signingInput);\n        // extract the signature as a DER array\n        const derSignatureBuffer = this.cryptoClient.loadSignature(tokenParts[2]);\n        // verify the signed hash\n        return this.cryptoClient.verifyHash(signingInputHash, derSignatureBuffer, this.rawPublicKey);\n    }\n    verifyExpanded(token) {\n        const signingInput = [\n            token['header'].join('.'),\n            base64url_1.default.encode(token['payload'])\n        ].join('.');\n        const signingInputHash = this.cryptoClient.createHash(signingInput);\n        let verified = true;\n        token['signature'].map((signature) => {\n            const derSignatureBuffer = this.cryptoClient.loadSignature(signature);\n            const signatureVerified = this.cryptoClient.verifyHash(signingInputHash, derSignatureBuffer, this.rawPublicKey);\n            if (!signatureVerified) {\n                verified = false;\n            }\n        });\n        return verified;\n    }\n}\nexports.TokenVerifier = TokenVerifier;\n//# sourceMappingURL=verifier.js.map"]},"metadata":{},"sourceType":"script"}