{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/aashan/2048/node_modules/@babel/runtime/regenerator\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar queryString = require(\"query-string\"); // @ts-ignore: Could not find a declaration file for module\n\n\nvar jsontokens_1 = require(\"jsontokens\");\n\nvar authVerification_1 = require(\"./authVerification\");\n\nvar utils_1 = require(\"../utils\");\n\nvar fetchUtil_1 = require(\"../fetchUtil\");\n\nvar dids_1 = require(\"../dids\");\n\nvar errors_1 = require(\"../errors\");\n\nvar authMessages_1 = require(\"./authMessages\");\n\nvar authConstants_1 = require(\"./authConstants\");\n\nvar profileTokens_1 = require(\"../profiles/profileTokens\");\n\nvar userSession_1 = require(\"./userSession\");\n\nvar config_1 = require(\"../config\");\n\nvar logger_1 = require(\"../logger\");\n\nvar protocolEchoDetection_1 = require(\"./protocolEchoDetection\");\n\nvar protocolLaunch_1 = require(\"./protocolLaunch\");\n\nvar DEFAULT_PROFILE = {\n  '@type': 'Person',\n  '@context': 'http://schema.org'\n};\n/**\n * @deprecated\n * #### v19 Use [[UserSession.isUserSignedIn]] instead.\n *\n * Check if a user is currently signed in.\n * @return {Boolean} `true` if the user is signed in, `false` if not.\n */\n\nfunction isUserSignedIn() {\n  console.warn('DEPRECATION WARNING: The static isUserSignedIn() function will be deprecated in ' + 'the next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method isUserSignedIn().');\n  var userSession = new userSession_1.UserSession();\n  return userSession.isUserSignedIn();\n}\n\nexports.isUserSignedIn = isUserSignedIn;\n/**\n *\n *\n * @deprecated\n * #### v19 Use [[UserSession.isUserSignedIn]] instead.\n *\n * Generates an authentication request and redirects the user to the Blockstack\n * browser to approve the sign in request.\n *\n * Please note that this requires that the web browser properly handles the\n * `blockstack:` URL protocol handler.\n *\n * Most applications should use this\n * method for sign in unless they require more fine grained control over how the\n * authentication request is generated. If your app falls into this category,\n * use `makeAuthRequest` and `redirectToSignInWithAuthRequest` to build your own sign in process.\n *\n * @param {String} [redirectURI=`${window.location.origin}/`]\n * The location to which the identity provider will redirect the user after\n * the user approves sign in.\n * @param  {String} [manifestURI=`${window.location.origin}/manifest.json`]\n * Location of the manifest file.\n * @param  {Array} [scopes=DEFAULT_SCOPE] Defaults to requesting write access to\n * this app's data store.\n * An array of strings indicating which permissions this app is requesting.\n * @return {void}\n */\n\nfunction redirectToSignIn(redirectURI, manifestURI, scopes) {\n  console.warn('DEPRECATION WARNING: The static redirectToSignIn() function will be deprecated in the ' + 'next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method redirectToSignIn().');\n  var authRequest = authMessages_1.makeAuthRequest(null, redirectURI, manifestURI, scopes);\n  redirectToSignInWithAuthRequest(authRequest);\n}\n\nexports.redirectToSignIn = redirectToSignIn;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.isSignInPending]] instead.\n *\n * Check if there is a authentication request that hasn't been handled.\n *\n * Also checks for a protocol echo reply (which if detected then the page\n * will be automatically redirected after this call).\n *\n * @return {Boolean} `true` if there is a pending sign in, otherwise `false`\n */\n\nfunction isSignInPending() {\n  try {\n    var isProtocolEcho = protocolEchoDetection_1.protocolEchoReplyDetection();\n\n    if (isProtocolEcho) {\n      logger_1.Logger.info('protocolEchoReply detected from isSignInPending call, the page is about to redirect.');\n      return true;\n    }\n  } catch (error) {\n    logger_1.Logger.error(\"Error checking for protocol echo reply isSignInPending: \".concat(error));\n  }\n\n  return !!getAuthResponseToken();\n}\n\nexports.isSignInPending = isSignInPending;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.getAuthResponseToken]] instead.\n *\n * Retrieve the authentication token from the URL query\n * @return {String} the authentication token if it exists otherwise `null`\n */\n\nfunction getAuthResponseToken() {\n  var search = utils_1.getGlobalObject('location', {\n    throwIfUnavailable: true,\n    usageDesc: 'getAuthResponseToken'\n  }).search;\n  var queryDict = queryString.parse(search);\n  return queryDict.authResponse ? queryDict.authResponse : '';\n}\n\nexports.getAuthResponseToken = getAuthResponseToken;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.loadUserData]] instead.\n *\n * Retrieves the user data object. The user's profile is stored in the key `profile`.\n * @return {Object} User data object.\n*/\n\nfunction loadUserData() {\n  console.warn('DEPRECATION WARNING: The static loadUserData() function will be deprecated in the ' + 'next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method loadUserData().');\n  var userSession = new userSession_1.UserSession();\n  return userSession.loadUserData();\n}\n\nexports.loadUserData = loadUserData;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.signUserOut]] instead.\n *\n * Sign the user out and optionally redirect to given location.\n * @param  redirectURL\n * Location to redirect user to after sign out.\n * Only used in environments with `window` available\n */\n\nfunction signUserOut(redirectURL, caller) {\n  var userSession = caller || new userSession_1.UserSession();\n  userSession.store.deleteSessionData();\n\n  if (redirectURL) {\n    utils_1.getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: 'signUserOut'\n    }).href = redirectURL;\n  }\n}\n\nexports.signUserOut = signUserOut;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.redirectToSignInWithAuthRequest]] instead.\n *\n * Redirects the user to the Blockstack browser to approve the sign in request\n * given.\n *\n * The user is redirected to the `blockstackIDHost` if the `blockstack:`\n * protocol handler is not detected. Please note that the protocol handler detection\n * does not work on all browsers.\n * @param  {String} authRequest - the authentication request generated by `makeAuthRequest`\n * @param  {String} blockstackIDHost - the URL to redirect the user to if the blockstack\n *                                     protocol handler is not detected\n * @return {void}\n */\n\nfunction redirectToSignInWithAuthRequest(authRequest) {\n  var blockstackIDHost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : authConstants_1.DEFAULT_BLOCKSTACK_HOST;\n  authRequest = authRequest || authMessages_1.makeAuthRequest();\n  var httpsURI = \"\".concat(blockstackIDHost, \"?authRequest=\").concat(authRequest);\n\n  var _utils_1$getGlobalObj = utils_1.getGlobalObjects(['navigator', 'location'], {\n    throwIfUnavailable: true,\n    usageDesc: 'redirectToSignInWithAuthRequest'\n  }),\n      navigator = _utils_1$getGlobalObj.navigator,\n      location = _utils_1$getGlobalObj.location; // If they're on a mobile OS, always redirect them to HTTPS site\n\n\n  if (/Android|webOS|iPhone|iPad|iPod|Opera Mini/i.test(navigator.userAgent)) {\n    logger_1.Logger.info('detected mobile OS, sending to https');\n    location.href = httpsURI;\n    return;\n  }\n\n  function successCallback() {\n    logger_1.Logger.info('protocol handler detected'); // The detection function should open the link for us\n  }\n\n  function failCallback() {\n    logger_1.Logger.warn('protocol handler not detected');\n    location.href = httpsURI;\n  }\n\n  protocolLaunch_1.launchCustomProtocol(authRequest, successCallback, failCallback);\n}\n\nexports.redirectToSignInWithAuthRequest = redirectToSignInWithAuthRequest;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.handlePendingSignIn]] instead.\n *\n * Try to process any pending sign in request by returning a `Promise` that resolves\n * to the user data object if the sign in succeeds.\n *\n * @param {String} nameLookupURL - the endpoint against which to verify public\n * keys match claimed username\n * @param {String} authResponseToken - the signed authentication response token\n * @param {String} transitKey - the transit private key that corresponds to the transit public key\n * that was provided in the authentication request\n * @return {Promise} that resolves to the user data object if successful and rejects\n * if handling the sign in request fails or there was no pending sign in request.\n */\n\nfunction handlePendingSignIn() {\n  var nameLookupURL = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var authResponseToken = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getAuthResponseToken();\n  var transitKey = arguments.length > 2 ? arguments[2] : undefined;\n  var caller = arguments.length > 3 ? arguments[3] : undefined;\n  return __awaiter(this, void 0, void 0,\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee() {\n    var isProtocolEcho, msg, sessionData, _tokenPayload, isValid, tokenPayload, appPrivateKey, coreSessionToken, hubUrl, gaiaAssociationToken, userData, profileURL, response, responseText, wrappedProfile, profile;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            isProtocolEcho = protocolEchoDetection_1.protocolEchoReplyDetection();\n\n            if (!isProtocolEcho) {\n              _context.next = 6;\n              break;\n            }\n\n            msg = 'handlePendingSignIn called while protocolEchoReply was detected, and ' + 'the page is about to redirect. This function will resolve with an error after ' + 'several seconds, if the page was not redirected for some reason.';\n            logger_1.Logger.info(msg);\n            return _context.abrupt(\"return\", new Promise(function (_resolve, reject) {\n              setTimeout(function () {\n                logger_1.Logger.error('Page should have redirected by now. handlePendingSignIn will now throw.');\n                reject(msg);\n              }, 3000);\n            }));\n\n          case 6:\n            _context.next = 11;\n            break;\n\n          case 8:\n            _context.prev = 8;\n            _context.t0 = _context[\"catch\"](0);\n            logger_1.Logger.error(\"Error checking for protocol echo reply handlePendingSignIn: \".concat(_context.t0));\n\n          case 11:\n            if (!caller) {\n              caller = new userSession_1.UserSession();\n            }\n\n            sessionData = caller.store.getSessionData();\n\n            if (!sessionData.userData) {\n              _context.next = 15;\n              break;\n            }\n\n            throw new errors_1.LoginFailedError('Existing user session found.');\n\n          case 15:\n            if (!transitKey) {\n              transitKey = caller.store.getSessionData().transitKey;\n            }\n\n            if (nameLookupURL) {\n              _context.next = 22;\n              break;\n            }\n\n            _tokenPayload = jsontokens_1.decodeToken(authResponseToken).payload;\n\n            if (!(typeof _tokenPayload === 'string')) {\n              _context.next = 20;\n              break;\n            }\n\n            throw new Error('Unexpected token payload type of string');\n\n          case 20:\n            if (utils_1.isLaterVersion(_tokenPayload.version, '1.3.0') && _tokenPayload.blockstackAPIUrl !== null && _tokenPayload.blockstackAPIUrl !== undefined) {\n              // override globally\n              logger_1.Logger.info(\"Overriding \".concat(config_1.config.network.blockstackAPIUrl, \" \") + \"with \".concat(_tokenPayload.blockstackAPIUrl));\n              config_1.config.network.blockstackAPIUrl = _tokenPayload.blockstackAPIUrl;\n            }\n\n            nameLookupURL = \"\".concat(config_1.config.network.blockstackAPIUrl).concat(authConstants_1.NAME_LOOKUP_PATH);\n\n          case 22:\n            _context.next = 24;\n            return authVerification_1.verifyAuthResponse(authResponseToken, nameLookupURL);\n\n          case 24:\n            isValid = _context.sent;\n\n            if (isValid) {\n              _context.next = 27;\n              break;\n            }\n\n            throw new errors_1.LoginFailedError('Invalid authentication response.');\n\n          case 27:\n            tokenPayload = jsontokens_1.decodeToken(authResponseToken).payload;\n\n            if (!(typeof tokenPayload === 'string')) {\n              _context.next = 30;\n              break;\n            }\n\n            throw new Error('Unexpected token payload type of string');\n\n          case 30:\n            // TODO: real version handling\n            appPrivateKey = tokenPayload.private_key;\n            coreSessionToken = tokenPayload.core_token;\n\n            if (!utils_1.isLaterVersion(tokenPayload.version, '1.1.0')) {\n              _context.next = 53;\n              break;\n            }\n\n            if (!(transitKey !== undefined && transitKey != null)) {\n              _context.next = 52;\n              break;\n            }\n\n            if (!(tokenPayload.private_key !== undefined && tokenPayload.private_key !== null)) {\n              _context.next = 49;\n              break;\n            }\n\n            _context.prev = 35;\n            appPrivateKey = authMessages_1.decryptPrivateKey(transitKey, tokenPayload.private_key);\n            _context.next = 49;\n            break;\n\n          case 39:\n            _context.prev = 39;\n            _context.t1 = _context[\"catch\"](35);\n            logger_1.Logger.warn('Failed decryption of appPrivateKey, will try to use as given');\n            _context.prev = 42;\n            utils_1.hexStringToECPair(tokenPayload.private_key);\n            _context.next = 49;\n            break;\n\n          case 46:\n            _context.prev = 46;\n            _context.t2 = _context[\"catch\"](42);\n            throw new errors_1.LoginFailedError('Failed decrypting appPrivateKey. Usually means' + ' that the transit key has changed during login.');\n\n          case 49:\n            if (coreSessionToken !== undefined && coreSessionToken !== null) {\n              try {\n                coreSessionToken = authMessages_1.decryptPrivateKey(transitKey, coreSessionToken);\n              } catch (e) {\n                logger_1.Logger.info('Failed decryption of coreSessionToken, will try to use as given');\n              }\n            }\n\n            _context.next = 53;\n            break;\n\n          case 52:\n            throw new errors_1.LoginFailedError('Authenticating with protocol > 1.1.0 requires transit' + ' key, and none found.');\n\n          case 53:\n            hubUrl = authConstants_1.BLOCKSTACK_DEFAULT_GAIA_HUB_URL;\n\n            if (utils_1.isLaterVersion(tokenPayload.version, '1.2.0') && tokenPayload.hubUrl !== null && tokenPayload.hubUrl !== undefined) {\n              hubUrl = tokenPayload.hubUrl;\n            }\n\n            if (utils_1.isLaterVersion(tokenPayload.version, '1.3.0') && tokenPayload.associationToken !== null && tokenPayload.associationToken !== undefined) {\n              gaiaAssociationToken = tokenPayload.associationToken;\n            }\n\n            userData = {\n              username: tokenPayload.username,\n              profile: tokenPayload.profile,\n              email: tokenPayload.email,\n              decentralizedID: tokenPayload.iss,\n              identityAddress: dids_1.getAddressFromDID(tokenPayload.iss),\n              appPrivateKey: appPrivateKey,\n              coreSessionToken: coreSessionToken,\n              authResponseToken: authResponseToken,\n              hubUrl: hubUrl,\n              gaiaAssociationToken: gaiaAssociationToken\n            };\n            profileURL = tokenPayload.profile_url;\n\n            if (!(!userData.profile && profileURL)) {\n              _context.next = 74;\n              break;\n            }\n\n            _context.next = 61;\n            return fetchUtil_1.fetchPrivate(profileURL);\n\n          case 61:\n            response = _context.sent;\n\n            if (response.ok) {\n              _context.next = 66;\n              break;\n            }\n\n            // return blank profile if we fail to fetch\n            userData.profile = Object.assign({}, DEFAULT_PROFILE);\n            _context.next = 72;\n            break;\n\n          case 66:\n            _context.next = 68;\n            return response.text();\n\n          case 68:\n            responseText = _context.sent;\n            wrappedProfile = JSON.parse(responseText);\n            profile = profileTokens_1.extractProfile(wrappedProfile[0].token);\n            userData.profile = profile;\n\n          case 72:\n            _context.next = 75;\n            break;\n\n          case 74:\n            userData.profile = tokenPayload.profile;\n\n          case 75:\n            sessionData.userData = userData;\n            caller.store.setSessionData(sessionData);\n            return _context.abrupt(\"return\", userData);\n\n          case 78:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[0, 8], [35, 39], [42, 46]]);\n  }));\n}\n\nexports.handlePendingSignIn = handlePendingSignIn;","map":{"version":3,"sources":["../../src/auth/authApp.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst queryString = require(\"query-string\");\n// @ts-ignore: Could not find a declaration file for module\nconst jsontokens_1 = require(\"jsontokens\");\nconst authVerification_1 = require(\"./authVerification\");\nconst utils_1 = require(\"../utils\");\nconst fetchUtil_1 = require(\"../fetchUtil\");\nconst dids_1 = require(\"../dids\");\nconst errors_1 = require(\"../errors\");\nconst authMessages_1 = require(\"./authMessages\");\nconst authConstants_1 = require(\"./authConstants\");\nconst profileTokens_1 = require(\"../profiles/profileTokens\");\nconst userSession_1 = require(\"./userSession\");\nconst config_1 = require(\"../config\");\nconst logger_1 = require(\"../logger\");\nconst protocolEchoDetection_1 = require(\"./protocolEchoDetection\");\nconst protocolLaunch_1 = require(\"./protocolLaunch\");\nconst DEFAULT_PROFILE = {\n    '@type': 'Person',\n    '@context': 'http://schema.org'\n};\n/**\n * @deprecated\n * #### v19 Use [[UserSession.isUserSignedIn]] instead.\n *\n * Check if a user is currently signed in.\n * @return {Boolean} `true` if the user is signed in, `false` if not.\n */\nfunction isUserSignedIn() {\n    console.warn('DEPRECATION WARNING: The static isUserSignedIn() function will be deprecated in '\n        + 'the next major release of blockstack.js. Create an instance of UserSession and call the '\n        + 'instance method isUserSignedIn().');\n    const userSession = new userSession_1.UserSession();\n    return userSession.isUserSignedIn();\n}\nexports.isUserSignedIn = isUserSignedIn;\n/**\n *\n *\n * @deprecated\n * #### v19 Use [[UserSession.isUserSignedIn]] instead.\n *\n * Generates an authentication request and redirects the user to the Blockstack\n * browser to approve the sign in request.\n *\n * Please note that this requires that the web browser properly handles the\n * `blockstack:` URL protocol handler.\n *\n * Most applications should use this\n * method for sign in unless they require more fine grained control over how the\n * authentication request is generated. If your app falls into this category,\n * use `makeAuthRequest` and `redirectToSignInWithAuthRequest` to build your own sign in process.\n *\n * @param {String} [redirectURI=`${window.location.origin}/`]\n * The location to which the identity provider will redirect the user after\n * the user approves sign in.\n * @param  {String} [manifestURI=`${window.location.origin}/manifest.json`]\n * Location of the manifest file.\n * @param  {Array} [scopes=DEFAULT_SCOPE] Defaults to requesting write access to\n * this app's data store.\n * An array of strings indicating which permissions this app is requesting.\n * @return {void}\n */\nfunction redirectToSignIn(redirectURI, manifestURI, scopes) {\n    console.warn('DEPRECATION WARNING: The static redirectToSignIn() function will be deprecated in the '\n        + 'next major release of blockstack.js. Create an instance of UserSession and call the '\n        + 'instance method redirectToSignIn().');\n    const authRequest = authMessages_1.makeAuthRequest(null, redirectURI, manifestURI, scopes);\n    redirectToSignInWithAuthRequest(authRequest);\n}\nexports.redirectToSignIn = redirectToSignIn;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.isSignInPending]] instead.\n *\n * Check if there is a authentication request that hasn't been handled.\n *\n * Also checks for a protocol echo reply (which if detected then the page\n * will be automatically redirected after this call).\n *\n * @return {Boolean} `true` if there is a pending sign in, otherwise `false`\n */\nfunction isSignInPending() {\n    try {\n        const isProtocolEcho = protocolEchoDetection_1.protocolEchoReplyDetection();\n        if (isProtocolEcho) {\n            logger_1.Logger.info('protocolEchoReply detected from isSignInPending call, the page is about to redirect.');\n            return true;\n        }\n    }\n    catch (error) {\n        logger_1.Logger.error(`Error checking for protocol echo reply isSignInPending: ${error}`);\n    }\n    return !!getAuthResponseToken();\n}\nexports.isSignInPending = isSignInPending;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.getAuthResponseToken]] instead.\n *\n * Retrieve the authentication token from the URL query\n * @return {String} the authentication token if it exists otherwise `null`\n */\nfunction getAuthResponseToken() {\n    const search = utils_1.getGlobalObject('location', { throwIfUnavailable: true, usageDesc: 'getAuthResponseToken' }).search;\n    const queryDict = queryString.parse(search);\n    return queryDict.authResponse ? queryDict.authResponse : '';\n}\nexports.getAuthResponseToken = getAuthResponseToken;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.loadUserData]] instead.\n *\n * Retrieves the user data object. The user's profile is stored in the key `profile`.\n * @return {Object} User data object.\n*/\nfunction loadUserData() {\n    console.warn('DEPRECATION WARNING: The static loadUserData() function will be deprecated in the '\n        + 'next major release of blockstack.js. Create an instance of UserSession and call the '\n        + 'instance method loadUserData().');\n    const userSession = new userSession_1.UserSession();\n    return userSession.loadUserData();\n}\nexports.loadUserData = loadUserData;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.signUserOut]] instead.\n *\n * Sign the user out and optionally redirect to given location.\n * @param  redirectURL\n * Location to redirect user to after sign out.\n * Only used in environments with `window` available\n */\nfunction signUserOut(redirectURL, caller) {\n    const userSession = caller || new userSession_1.UserSession();\n    userSession.store.deleteSessionData();\n    if (redirectURL) {\n        utils_1.getGlobalObject('location', { throwIfUnavailable: true, usageDesc: 'signUserOut' }).href = redirectURL;\n    }\n}\nexports.signUserOut = signUserOut;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.redirectToSignInWithAuthRequest]] instead.\n *\n * Redirects the user to the Blockstack browser to approve the sign in request\n * given.\n *\n * The user is redirected to the `blockstackIDHost` if the `blockstack:`\n * protocol handler is not detected. Please note that the protocol handler detection\n * does not work on all browsers.\n * @param  {String} authRequest - the authentication request generated by `makeAuthRequest`\n * @param  {String} blockstackIDHost - the URL to redirect the user to if the blockstack\n *                                     protocol handler is not detected\n * @return {void}\n */\nfunction redirectToSignInWithAuthRequest(authRequest, blockstackIDHost = authConstants_1.DEFAULT_BLOCKSTACK_HOST) {\n    authRequest = authRequest || authMessages_1.makeAuthRequest();\n    const httpsURI = `${blockstackIDHost}?authRequest=${authRequest}`;\n    const { navigator, location } = utils_1.getGlobalObjects(['navigator', 'location'], { throwIfUnavailable: true, usageDesc: 'redirectToSignInWithAuthRequest' });\n    // If they're on a mobile OS, always redirect them to HTTPS site\n    if (/Android|webOS|iPhone|iPad|iPod|Opera Mini/i.test(navigator.userAgent)) {\n        logger_1.Logger.info('detected mobile OS, sending to https');\n        location.href = httpsURI;\n        return;\n    }\n    function successCallback() {\n        logger_1.Logger.info('protocol handler detected');\n        // The detection function should open the link for us\n    }\n    function failCallback() {\n        logger_1.Logger.warn('protocol handler not detected');\n        location.href = httpsURI;\n    }\n    protocolLaunch_1.launchCustomProtocol(authRequest, successCallback, failCallback);\n}\nexports.redirectToSignInWithAuthRequest = redirectToSignInWithAuthRequest;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.handlePendingSignIn]] instead.\n *\n * Try to process any pending sign in request by returning a `Promise` that resolves\n * to the user data object if the sign in succeeds.\n *\n * @param {String} nameLookupURL - the endpoint against which to verify public\n * keys match claimed username\n * @param {String} authResponseToken - the signed authentication response token\n * @param {String} transitKey - the transit private key that corresponds to the transit public key\n * that was provided in the authentication request\n * @return {Promise} that resolves to the user data object if successful and rejects\n * if handling the sign in request fails or there was no pending sign in request.\n */\nfunction handlePendingSignIn(nameLookupURL = '', authResponseToken = getAuthResponseToken(), transitKey, caller) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const isProtocolEcho = protocolEchoDetection_1.protocolEchoReplyDetection();\n            if (isProtocolEcho) {\n                const msg = 'handlePendingSignIn called while protocolEchoReply was detected, and '\n                    + 'the page is about to redirect. This function will resolve with an error after '\n                    + 'several seconds, if the page was not redirected for some reason.';\n                logger_1.Logger.info(msg);\n                return new Promise((_resolve, reject) => {\n                    setTimeout(() => {\n                        logger_1.Logger.error('Page should have redirected by now. handlePendingSignIn will now throw.');\n                        reject(msg);\n                    }, 3000);\n                });\n            }\n        }\n        catch (error) {\n            logger_1.Logger.error(`Error checking for protocol echo reply handlePendingSignIn: ${error}`);\n        }\n        if (!caller) {\n            caller = new userSession_1.UserSession();\n        }\n        const sessionData = caller.store.getSessionData();\n        if (sessionData.userData) {\n            throw new errors_1.LoginFailedError('Existing user session found.');\n        }\n        if (!transitKey) {\n            transitKey = caller.store.getSessionData().transitKey;\n        }\n        if (!nameLookupURL) {\n            const tokenPayload = jsontokens_1.decodeToken(authResponseToken).payload;\n            if (typeof tokenPayload === 'string') {\n                throw new Error('Unexpected token payload type of string');\n            }\n            if (utils_1.isLaterVersion(tokenPayload.version, '1.3.0')\n                && tokenPayload.blockstackAPIUrl !== null && tokenPayload.blockstackAPIUrl !== undefined) {\n                // override globally\n                logger_1.Logger.info(`Overriding ${config_1.config.network.blockstackAPIUrl} `\n                    + `with ${tokenPayload.blockstackAPIUrl}`);\n                config_1.config.network.blockstackAPIUrl = tokenPayload.blockstackAPIUrl;\n            }\n            nameLookupURL = `${config_1.config.network.blockstackAPIUrl}${authConstants_1.NAME_LOOKUP_PATH}`;\n        }\n        const isValid = yield authVerification_1.verifyAuthResponse(authResponseToken, nameLookupURL);\n        if (!isValid) {\n            throw new errors_1.LoginFailedError('Invalid authentication response.');\n        }\n        const tokenPayload = jsontokens_1.decodeToken(authResponseToken).payload;\n        if (typeof tokenPayload === 'string') {\n            throw new Error('Unexpected token payload type of string');\n        }\n        // TODO: real version handling\n        let appPrivateKey = tokenPayload.private_key;\n        let coreSessionToken = tokenPayload.core_token;\n        if (utils_1.isLaterVersion(tokenPayload.version, '1.1.0')) {\n            if (transitKey !== undefined && transitKey != null) {\n                if (tokenPayload.private_key !== undefined && tokenPayload.private_key !== null) {\n                    try {\n                        appPrivateKey = authMessages_1.decryptPrivateKey(transitKey, tokenPayload.private_key);\n                    }\n                    catch (e) {\n                        logger_1.Logger.warn('Failed decryption of appPrivateKey, will try to use as given');\n                        try {\n                            utils_1.hexStringToECPair(tokenPayload.private_key);\n                        }\n                        catch (ecPairError) {\n                            throw new errors_1.LoginFailedError('Failed decrypting appPrivateKey. Usually means'\n                                + ' that the transit key has changed during login.');\n                        }\n                    }\n                }\n                if (coreSessionToken !== undefined && coreSessionToken !== null) {\n                    try {\n                        coreSessionToken = authMessages_1.decryptPrivateKey(transitKey, coreSessionToken);\n                    }\n                    catch (e) {\n                        logger_1.Logger.info('Failed decryption of coreSessionToken, will try to use as given');\n                    }\n                }\n            }\n            else {\n                throw new errors_1.LoginFailedError('Authenticating with protocol > 1.1.0 requires transit'\n                    + ' key, and none found.');\n            }\n        }\n        let hubUrl = authConstants_1.BLOCKSTACK_DEFAULT_GAIA_HUB_URL;\n        let gaiaAssociationToken;\n        if (utils_1.isLaterVersion(tokenPayload.version, '1.2.0')\n            && tokenPayload.hubUrl !== null && tokenPayload.hubUrl !== undefined) {\n            hubUrl = tokenPayload.hubUrl;\n        }\n        if (utils_1.isLaterVersion(tokenPayload.version, '1.3.0')\n            && tokenPayload.associationToken !== null && tokenPayload.associationToken !== undefined) {\n            gaiaAssociationToken = tokenPayload.associationToken;\n        }\n        const userData = {\n            username: tokenPayload.username,\n            profile: tokenPayload.profile,\n            email: tokenPayload.email,\n            decentralizedID: tokenPayload.iss,\n            identityAddress: dids_1.getAddressFromDID(tokenPayload.iss),\n            appPrivateKey,\n            coreSessionToken,\n            authResponseToken,\n            hubUrl,\n            gaiaAssociationToken\n        };\n        const profileURL = tokenPayload.profile_url;\n        if (!userData.profile && profileURL) {\n            const response = yield fetchUtil_1.fetchPrivate(profileURL);\n            if (!response.ok) { // return blank profile if we fail to fetch\n                userData.profile = Object.assign({}, DEFAULT_PROFILE);\n            }\n            else {\n                const responseText = yield response.text();\n                const wrappedProfile = JSON.parse(responseText);\n                const profile = profileTokens_1.extractProfile(wrappedProfile[0].token);\n                userData.profile = profile;\n            }\n        }\n        else {\n            userData.profile = tokenPayload.profile;\n        }\n        sessionData.userData = userData;\n        caller.store.setSessionData(sessionData);\n        return userData;\n    });\n}\nexports.handlePendingSignIn = handlePendingSignIn;\n//# sourceMappingURL=authApp.js.map"]},"metadata":{},"sourceType":"script"}