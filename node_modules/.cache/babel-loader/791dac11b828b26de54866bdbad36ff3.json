{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar utils_1 = require(\"../utils\");\n\nvar logger_1 = require(\"../logger\");\n/**\n * Detects if the native auth-browser is installed and is successfully\n * launched via a custom protocol URI.\n * @param {String} authRequest\n * The encoded authRequest to be used as a query param in the custom URI.\n * @param {String} successCallback\n * The callback that is invoked when the protocol handler was detected.\n * @param {String} failCallback\n * The callback that is invoked when the protocol handler was not detected.\n * @return {void}\n */\n\n\nfunction launchCustomProtocol(authRequest, successCallback, failCallback) {\n  // Create a unique ID used for this protocol detection attempt.\n  var echoReplyID = Math.random().toString(36).substr(2, 9);\n  var echoReplyKeyPrefix = 'echo-reply-';\n  var echoReplyKey = \"\".concat(echoReplyKeyPrefix).concat(echoReplyID);\n\n  var _utils_1$getGlobalObj = utils_1.getGlobalObjects(['localStorage', 'document', 'setTimeout', 'clearTimeout', 'addEventListener', 'removeEventListener'], {\n    throwIfUnavailable: true,\n    usageDesc: 'detectProtocolLaunch'\n  }),\n      localStorage = _utils_1$getGlobalObj.localStorage,\n      document = _utils_1$getGlobalObj.document,\n      setTimeout = _utils_1$getGlobalObj.setTimeout,\n      clearTimeout = _utils_1$getGlobalObj.clearTimeout,\n      addEventListener = _utils_1$getGlobalObj.addEventListener,\n      removeEventListener = _utils_1$getGlobalObj.removeEventListener; // Use localStorage as a reliable cross-window communication method.\n  // Create the storage entry to signal a protocol detection attempt for the\n  // next browser window to check.\n\n\n  localStorage.setItem(echoReplyKey, Date.now().toString());\n\n  var cleanUpLocalStorage = function cleanUpLocalStorage() {\n    try {\n      localStorage.removeItem(echoReplyKey); // Also clear out any stale echo-reply keys older than 1 hour.\n\n      for (var i = 0; i < localStorage.length; i++) {\n        var storageKey = localStorage.key(i);\n\n        if (storageKey && storageKey.startsWith(echoReplyKeyPrefix)) {\n          var storageValue = localStorage.getItem(storageKey);\n\n          if (storageValue === 'success' || Date.now() - parseInt(storageValue, 10) > 3600000) {\n            localStorage.removeItem(storageKey);\n          }\n        }\n      }\n    } catch (err) {\n      logger_1.Logger.error('Exception cleaning up echo-reply entries in localStorage');\n      logger_1.Logger.error(err);\n    }\n  };\n\n  var detectionTimeout = 1000;\n  var redirectToWebAuthTimer = 0;\n\n  var cancelWebAuthRedirectTimer = function cancelWebAuthRedirectTimer() {\n    if (redirectToWebAuthTimer) {\n      clearTimeout(redirectToWebAuthTimer);\n      redirectToWebAuthTimer = 0;\n    }\n  };\n\n  var startWebAuthRedirectTimer = function startWebAuthRedirectTimer() {\n    var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : detectionTimeout;\n    cancelWebAuthRedirectTimer();\n    redirectToWebAuthTimer = setTimeout(function () {\n      if (redirectToWebAuthTimer) {\n        cancelWebAuthRedirectTimer();\n        var nextFunc;\n\n        if (localStorage.getItem(echoReplyKey) === 'success') {\n          logger_1.Logger.info('Protocol echo reply detected.');\n          nextFunc = successCallback;\n        } else {\n          logger_1.Logger.info('Protocol handler not detected.');\n          nextFunc = failCallback;\n        }\n\n        failCallback = function failCallback() {};\n\n        successCallback = function successCallback() {};\n\n        cleanUpLocalStorage(); // Briefly wait since localStorage changes can \n        // sometimes be ignored when immediately redirected.\n\n        setTimeout(function () {\n          return nextFunc();\n        }, 100);\n      }\n    }, timeout);\n  };\n\n  startWebAuthRedirectTimer();\n  var inputPromptTracker = document.createElement('input');\n  inputPromptTracker.type = 'text'; // Setting display:none on an element prevents them from being focused/blurred.\n  // So we hide using 0 width/height/opacity, and set position:fixed so that the\n  // page does not scroll when the element is focused. \n\n  var hiddenCssStyle = 'all: initial; position: fixed; top: 0; height: 0; width: 0; opacity: 0;';\n  inputPromptTracker.style.cssText = hiddenCssStyle; // If the the focus of a page element is immediately changed then this likely indicates \n  // the protocol handler is installed, and the browser is prompting the user if they want \n  // to open the application. \n\n  var inputBlurredFunc = function inputBlurredFunc() {\n    // Use a timeout of 100ms to ignore instant toggles between blur and focus.\n    // Browsers often perform an instant blur & focus when the protocol handler is working\n    // but not showing any browser prompts, so we want to ignore those instances.\n    var isRefocused = false;\n    inputPromptTracker.addEventListener('focus', function () {\n      isRefocused = true;\n    }, {\n      once: true,\n      capture: true\n    });\n    setTimeout(function () {\n      if (redirectToWebAuthTimer && !isRefocused) {\n        logger_1.Logger.info('Detected possible browser prompt for opening the protocol handler app.');\n        clearTimeout(redirectToWebAuthTimer);\n        inputPromptTracker.addEventListener('focus', function () {\n          if (redirectToWebAuthTimer) {\n            logger_1.Logger.info('Possible browser prompt closed, restarting auth redirect timeout.');\n            startWebAuthRedirectTimer();\n          }\n        }, {\n          once: true,\n          capture: true\n        });\n      }\n    }, 100);\n  };\n\n  inputPromptTracker.addEventListener('blur', inputBlurredFunc, {\n    once: true,\n    capture: true\n  });\n  setTimeout(function () {\n    return inputPromptTracker.removeEventListener('blur', inputBlurredFunc);\n  }, 200);\n  document.body.appendChild(inputPromptTracker);\n  inputPromptTracker.focus(); // Detect if document.visibility is immediately changed which is a strong \n  // indication that the protocol handler is working. We don't know for sure and \n  // can't predict future browser changes, so only increase the redirect timeout.\n  // This reduces the probability of a false-negative (where local auth works, but \n  // the original page was redirect to web auth because something took too long),\n\n  var pageVisibilityChanged = function pageVisibilityChanged() {\n    if (document.hidden && redirectToWebAuthTimer) {\n      logger_1.Logger.info('Detected immediate page visibility change (protocol handler probably working).');\n      startWebAuthRedirectTimer(3000);\n    }\n  };\n\n  document.addEventListener('visibilitychange', pageVisibilityChanged, {\n    once: true,\n    capture: true\n  });\n  setTimeout(function () {\n    return document.removeEventListener('visibilitychange', pageVisibilityChanged);\n  }, 500); // Listen for the custom protocol echo reply via localStorage update event.\n\n  addEventListener('storage', function replyEventListener(event) {\n    if (event.key === echoReplyKey && localStorage.getItem(echoReplyKey) === 'success') {\n      // Custom protocol worked, cancel the web auth redirect timer.\n      cancelWebAuthRedirectTimer();\n      inputPromptTracker.removeEventListener('blur', inputBlurredFunc);\n      logger_1.Logger.info('Protocol echo reply detected from localStorage event.'); // Clean up event listener and localStorage.\n\n      removeEventListener('storage', replyEventListener);\n      var nextFunc = successCallback;\n\n      successCallback = function successCallback() {};\n\n      failCallback = function failCallback() {};\n\n      cleanUpLocalStorage(); // Briefly wait since localStorage changes can sometimes \n      // be ignored when immediately redirected.\n\n      setTimeout(function () {\n        return nextFunc();\n      }, 100);\n    }\n  }, false); // Use iframe technique for launching the protocol URI rather than setting `window.location`.\n  // This method prevents browsers like Safari, Opera, Firefox from showing error prompts\n  // about unknown protocol handler when app is not installed, and avoids an empty\n  // browser tab when the app is installed. \n\n  logger_1.Logger.info('Attempting protocol launch via iframe injection.');\n  var locationSrc = \"\".concat(utils_1.BLOCKSTACK_HANDLER, \":\").concat(authRequest, \"&echo=\").concat(echoReplyID);\n  var iframe = document.createElement('iframe');\n  var iframeStyle = 'all: initial; display: none; position: fixed; top: 0; height: 0; width: 0; opacity: 0;';\n  iframe.style.cssText = iframeStyle;\n  iframe.src = locationSrc;\n  document.body.appendChild(iframe);\n}\n\nexports.launchCustomProtocol = launchCustomProtocol;","map":{"version":3,"sources":["../../src/auth/protocolLaunch.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"../utils\");\nconst logger_1 = require(\"../logger\");\n/**\n * Detects if the native auth-browser is installed and is successfully\n * launched via a custom protocol URI.\n * @param {String} authRequest\n * The encoded authRequest to be used as a query param in the custom URI.\n * @param {String} successCallback\n * The callback that is invoked when the protocol handler was detected.\n * @param {String} failCallback\n * The callback that is invoked when the protocol handler was not detected.\n * @return {void}\n */\nfunction launchCustomProtocol(authRequest, successCallback, failCallback) {\n    // Create a unique ID used for this protocol detection attempt.\n    const echoReplyID = Math.random().toString(36).substr(2, 9);\n    const echoReplyKeyPrefix = 'echo-reply-';\n    const echoReplyKey = `${echoReplyKeyPrefix}${echoReplyID}`;\n    const { localStorage, document, setTimeout, clearTimeout, addEventListener, removeEventListener } = utils_1.getGlobalObjects(['localStorage', 'document', 'setTimeout', 'clearTimeout', 'addEventListener', 'removeEventListener'], { throwIfUnavailable: true, usageDesc: 'detectProtocolLaunch' });\n    // Use localStorage as a reliable cross-window communication method.\n    // Create the storage entry to signal a protocol detection attempt for the\n    // next browser window to check.\n    localStorage.setItem(echoReplyKey, Date.now().toString());\n    const cleanUpLocalStorage = () => {\n        try {\n            localStorage.removeItem(echoReplyKey);\n            // Also clear out any stale echo-reply keys older than 1 hour.\n            for (let i = 0; i < localStorage.length; i++) {\n                const storageKey = localStorage.key(i);\n                if (storageKey && storageKey.startsWith(echoReplyKeyPrefix)) {\n                    const storageValue = localStorage.getItem(storageKey);\n                    if (storageValue === 'success' || (Date.now() - parseInt(storageValue, 10)) > 3600000) {\n                        localStorage.removeItem(storageKey);\n                    }\n                }\n            }\n        }\n        catch (err) {\n            logger_1.Logger.error('Exception cleaning up echo-reply entries in localStorage');\n            logger_1.Logger.error(err);\n        }\n    };\n    const detectionTimeout = 1000;\n    let redirectToWebAuthTimer = 0;\n    const cancelWebAuthRedirectTimer = () => {\n        if (redirectToWebAuthTimer) {\n            clearTimeout(redirectToWebAuthTimer);\n            redirectToWebAuthTimer = 0;\n        }\n    };\n    const startWebAuthRedirectTimer = (timeout = detectionTimeout) => {\n        cancelWebAuthRedirectTimer();\n        redirectToWebAuthTimer = setTimeout(() => {\n            if (redirectToWebAuthTimer) {\n                cancelWebAuthRedirectTimer();\n                let nextFunc;\n                if (localStorage.getItem(echoReplyKey) === 'success') {\n                    logger_1.Logger.info('Protocol echo reply detected.');\n                    nextFunc = successCallback;\n                }\n                else {\n                    logger_1.Logger.info('Protocol handler not detected.');\n                    nextFunc = failCallback;\n                }\n                failCallback = () => { };\n                successCallback = () => { };\n                cleanUpLocalStorage();\n                // Briefly wait since localStorage changes can \n                // sometimes be ignored when immediately redirected.\n                setTimeout(() => nextFunc(), 100);\n            }\n        }, timeout);\n    };\n    startWebAuthRedirectTimer();\n    const inputPromptTracker = document.createElement('input');\n    inputPromptTracker.type = 'text';\n    // Setting display:none on an element prevents them from being focused/blurred.\n    // So we hide using 0 width/height/opacity, and set position:fixed so that the\n    // page does not scroll when the element is focused. \n    const hiddenCssStyle = 'all: initial; position: fixed; top: 0; height: 0; width: 0; opacity: 0;';\n    inputPromptTracker.style.cssText = hiddenCssStyle;\n    // If the the focus of a page element is immediately changed then this likely indicates \n    // the protocol handler is installed, and the browser is prompting the user if they want \n    // to open the application. \n    const inputBlurredFunc = () => {\n        // Use a timeout of 100ms to ignore instant toggles between blur and focus.\n        // Browsers often perform an instant blur & focus when the protocol handler is working\n        // but not showing any browser prompts, so we want to ignore those instances.\n        let isRefocused = false;\n        inputPromptTracker.addEventListener('focus', () => { isRefocused = true; }, { once: true, capture: true });\n        setTimeout(() => {\n            if (redirectToWebAuthTimer && !isRefocused) {\n                logger_1.Logger.info('Detected possible browser prompt for opening the protocol handler app.');\n                clearTimeout(redirectToWebAuthTimer);\n                inputPromptTracker.addEventListener('focus', () => {\n                    if (redirectToWebAuthTimer) {\n                        logger_1.Logger.info('Possible browser prompt closed, restarting auth redirect timeout.');\n                        startWebAuthRedirectTimer();\n                    }\n                }, { once: true, capture: true });\n            }\n        }, 100);\n    };\n    inputPromptTracker.addEventListener('blur', inputBlurredFunc, { once: true, capture: true });\n    setTimeout(() => inputPromptTracker.removeEventListener('blur', inputBlurredFunc), 200);\n    document.body.appendChild(inputPromptTracker);\n    inputPromptTracker.focus();\n    // Detect if document.visibility is immediately changed which is a strong \n    // indication that the protocol handler is working. We don't know for sure and \n    // can't predict future browser changes, so only increase the redirect timeout.\n    // This reduces the probability of a false-negative (where local auth works, but \n    // the original page was redirect to web auth because something took too long),\n    const pageVisibilityChanged = () => {\n        if (document.hidden && redirectToWebAuthTimer) {\n            logger_1.Logger.info('Detected immediate page visibility change (protocol handler probably working).');\n            startWebAuthRedirectTimer(3000);\n        }\n    };\n    document.addEventListener('visibilitychange', pageVisibilityChanged, { once: true, capture: true });\n    setTimeout(() => document.removeEventListener('visibilitychange', pageVisibilityChanged), 500);\n    // Listen for the custom protocol echo reply via localStorage update event.\n    addEventListener('storage', function replyEventListener(event) {\n        if (event.key === echoReplyKey && localStorage.getItem(echoReplyKey) === 'success') {\n            // Custom protocol worked, cancel the web auth redirect timer.\n            cancelWebAuthRedirectTimer();\n            inputPromptTracker.removeEventListener('blur', inputBlurredFunc);\n            logger_1.Logger.info('Protocol echo reply detected from localStorage event.');\n            // Clean up event listener and localStorage.\n            removeEventListener('storage', replyEventListener);\n            const nextFunc = successCallback;\n            successCallback = () => { };\n            failCallback = () => { };\n            cleanUpLocalStorage();\n            // Briefly wait since localStorage changes can sometimes \n            // be ignored when immediately redirected.\n            setTimeout(() => nextFunc(), 100);\n        }\n    }, false);\n    // Use iframe technique for launching the protocol URI rather than setting `window.location`.\n    // This method prevents browsers like Safari, Opera, Firefox from showing error prompts\n    // about unknown protocol handler when app is not installed, and avoids an empty\n    // browser tab when the app is installed. \n    logger_1.Logger.info('Attempting protocol launch via iframe injection.');\n    const locationSrc = `${utils_1.BLOCKSTACK_HANDLER}:${authRequest}&echo=${echoReplyID}`;\n    const iframe = document.createElement('iframe');\n    const iframeStyle = 'all: initial; display: none; position: fixed; top: 0; height: 0; width: 0; opacity: 0;';\n    iframe.style.cssText = iframeStyle;\n    iframe.src = locationSrc;\n    document.body.appendChild(iframe);\n}\nexports.launchCustomProtocol = launchCustomProtocol;\n//# sourceMappingURL=protocolLaunch.js.map"]},"metadata":{},"sourceType":"script"}