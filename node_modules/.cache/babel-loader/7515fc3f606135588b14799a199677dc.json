{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/aashan/2048/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/aashan/2048/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nrequire(\"cross-fetch/polyfill\");\n\nvar serviceUtils_1 = require(\"./serviceUtils\");\n\nvar fetchUtil_1 = require(\"../../fetchUtil\");\n/**\n * @ignore\n */\n\n\nvar Service =\n/*#__PURE__*/\nfunction () {\n  function Service() {\n    _classCallCheck(this, Service);\n  }\n\n  _createClass(Service, null, [{\n    key: \"validateProof\",\n    value: function validateProof(proof, ownerAddress) {\n      var _this = this;\n\n      var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var proofUrl;\n      return Promise.resolve().then(function () {\n        proofUrl = _this.getProofUrl(proof);\n        return fetchUtil_1.fetchPrivate(proofUrl);\n      }).then(function (res) {\n        if (res.status !== 200) {\n          throw new Error(\"Proof url \".concat(proofUrl, \" returned unexpected http status \").concat(res.status, \".\\n              Unable to validate proof.\"));\n        }\n\n        return res.text();\n      }).then(function (text) {\n        // Validate identity in provided proof body/tags if required\n        if (_this.shouldValidateIdentityInBody() && proof.identifier !== _this.getProofIdentity(text)) {\n          return proof;\n        }\n\n        var proofText = _this.getProofStatement(text);\n\n        proof.valid = serviceUtils_1.containsValidProofStatement(proofText, name) || serviceUtils_1.containsValidAddressProofStatement(proofText, ownerAddress);\n        return proof;\n      }).catch(function (error) {\n        console.error(error);\n        proof.valid = false;\n        return proof;\n      });\n    }\n  }, {\n    key: \"getBaseUrls\",\n    value: function getBaseUrls() {\n      return [];\n    }\n  }, {\n    key: \"getProofIdentity\",\n    value: function getProofIdentity(searchText) {\n      return searchText;\n    }\n  }, {\n    key: \"getProofStatement\",\n    value: function getProofStatement(searchText) {\n      return searchText;\n    }\n  }, {\n    key: \"shouldValidateIdentityInBody\",\n    value: function shouldValidateIdentityInBody() {\n      return false;\n    }\n  }, {\n    key: \"prefixScheme\",\n    value: function prefixScheme(proofUrl) {\n      if (!proofUrl.startsWith('https://') && !proofUrl.startsWith('http://')) {\n        return \"https://\".concat(proofUrl);\n      } else if (proofUrl.startsWith('http://')) {\n        return proofUrl.replace('http://', 'https://');\n      } else {\n        return proofUrl;\n      }\n    }\n  }, {\n    key: \"getProofUrl\",\n    value: function getProofUrl(proof) {\n      var baseUrls = this.getBaseUrls();\n      var proofUrl = proof.proof_url.toLowerCase();\n      proofUrl = this.prefixScheme(proofUrl);\n\n      for (var i = 0; i < baseUrls.length; i++) {\n        var requiredPrefix = \"\".concat(baseUrls[i]).concat(proof.identifier).toLowerCase();\n\n        if (proofUrl.startsWith(requiredPrefix)) {\n          return proofUrl;\n        }\n      }\n\n      throw new Error(\"Proof url \".concat(proof.proof_url, \" is not valid for service \").concat(proof.service));\n    }\n  }]);\n\n  return Service;\n}();\n\nexports.Service = Service;","map":{"version":3,"sources":["../../../src/profiles/services/service.ts"],"names":[],"mappings":";;;;;;;;;;AACA,OAAA,CAAA,sBAAA,CAAA;;AACA,IAAA,cAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;AAEA;;;;;IAGa,O;;;;;;;;;kCACU,K,EACA,Y,EACmB;AAAA;;AAAA,UAAnB,IAAmB,uEAAJ,IAAI;AACtC,UAAI,QAAJ;AACA,aAAO,OAAO,CAAC,OAAR,GACJ,IADI,CACC,YAAK;AACT,QAAA,QAAQ,GAAG,KAAI,CAAC,WAAL,CAAiB,KAAjB,CAAX;AACA,eAAO,WAAA,CAAA,YAAA,CAAa,QAAb,CAAP;AACD,OAJI,EAKJ,IALI,CAKC,UAAC,GAAD,EAAQ;AACZ,YAAI,GAAG,CAAC,MAAJ,KAAe,GAAnB,EAAwB;AACtB,gBAAM,IAAI,KAAJ,qBAAuB,QAAvB,8CAAmE,GAAG,CAAC,MAAvE,gDAAN;AAED;;AACD,eAAO,GAAG,CAAC,IAAJ,EAAP;AACD,OAXI,EAYJ,IAZI,CAYC,UAAC,IAAD,EAAS;AACb;AACA,YAAI,KAAI,CAAC,4BAAL,MACG,KAAK,CAAC,UAAN,KAAqB,KAAI,CAAC,gBAAL,CAAsB,IAAtB,CAD5B,EACyD;AACvD,iBAAO,KAAP;AACD;;AACD,YAAM,SAAS,GAAG,KAAI,CAAC,iBAAL,CAAuB,IAAvB,CAAlB;;AACA,QAAA,KAAK,CAAC,KAAN,GAAc,cAAA,CAAA,2BAAA,CAA4B,SAA5B,EAAuC,IAAvC,KACT,cAAA,CAAA,kCAAA,CAAmC,SAAnC,EAA8C,YAA9C,CADL;AAEA,eAAO,KAAP;AACD,OAtBI,EAuBJ,KAvBI,CAuBE,UAAC,KAAD,EAAU;AACf,QAAA,OAAO,CAAC,KAAR,CAAc,KAAd;AACA,QAAA,KAAK,CAAC,KAAN,GAAc,KAAd;AACA,eAAO,KAAP;AACD,OA3BI,CAAP;AA4BD;;;kCAEiB;AAChB,aAAO,EAAP;AACD;;;qCAEuB,U,EAAkB;AACxC,aAAO,UAAP;AACD;;;sCAEwB,U,EAAkB;AACzC,aAAO,UAAP;AACD;;;mDAEkC;AACjC,aAAO,KAAP;AACD;;;iCAEmB,Q,EAAgB;AAClC,UAAI,CAAC,QAAQ,CAAC,UAAT,CAAoB,UAApB,CAAD,IAAoC,CAAC,QAAQ,CAAC,UAAT,CAAoB,SAApB,CAAzC,EAAyE;AACvE,iCAAkB,QAAlB;AACD,OAFD,MAEO,IAAI,QAAQ,CAAC,UAAT,CAAoB,SAApB,CAAJ,EAAoC;AACzC,eAAO,QAAQ,CAAC,OAAT,CAAiB,SAAjB,EAA4B,UAA5B,CAAP;AACD,OAFM,MAEA;AACL,eAAO,QAAP;AACD;AACF;;;gCAEkB,K,EAAU;AAC3B,UAAM,QAAQ,GAAG,KAAK,WAAL,EAAjB;AAEA,UAAI,QAAQ,GAAG,KAAK,CAAC,SAAN,CAAgB,WAAhB,EAAf;AACA,MAAA,QAAQ,GAAG,KAAK,YAAL,CAAkB,QAAlB,CAAX;;AAEA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,QAAQ,CAAC,MAA7B,EAAqC,CAAC,EAAtC,EAA0C;AACxC,YAAM,cAAc,GAAG,UAAG,QAAQ,CAAC,CAAD,CAAX,SAAiB,KAAK,CAAC,UAAvB,EAAoC,WAApC,EAAvB;;AACA,YAAI,QAAQ,CAAC,UAAT,CAAoB,cAApB,CAAJ,EAAyC;AACvC,iBAAO,QAAP;AACD;AACF;;AACD,YAAM,IAAI,KAAJ,qBAAuB,KAAK,CAAC,SAA7B,uCAAmE,KAAK,CAAC,OAAzE,EAAN;AACD;;;;;;AA1EH,OAAA,CAAA,OAAA,GAAA,OAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nrequire(\"cross-fetch/polyfill\");\nconst serviceUtils_1 = require(\"./serviceUtils\");\nconst fetchUtil_1 = require(\"../../fetchUtil\");\n/**\n * @ignore\n */\nclass Service {\n    static validateProof(proof, ownerAddress, name = null) {\n        let proofUrl;\n        return Promise.resolve()\n            .then(() => {\n            proofUrl = this.getProofUrl(proof);\n            return fetchUtil_1.fetchPrivate(proofUrl);\n        })\n            .then((res) => {\n            if (res.status !== 200) {\n                throw new Error(`Proof url ${proofUrl} returned unexpected http status ${res.status}.\n              Unable to validate proof.`);\n            }\n            return res.text();\n        })\n            .then((text) => {\n            // Validate identity in provided proof body/tags if required\n            if (this.shouldValidateIdentityInBody()\n                && proof.identifier !== this.getProofIdentity(text)) {\n                return proof;\n            }\n            const proofText = this.getProofStatement(text);\n            proof.valid = serviceUtils_1.containsValidProofStatement(proofText, name)\n                || serviceUtils_1.containsValidAddressProofStatement(proofText, ownerAddress);\n            return proof;\n        })\n            .catch((error) => {\n            console.error(error);\n            proof.valid = false;\n            return proof;\n        });\n    }\n    static getBaseUrls() {\n        return [];\n    }\n    static getProofIdentity(searchText) {\n        return searchText;\n    }\n    static getProofStatement(searchText) {\n        return searchText;\n    }\n    static shouldValidateIdentityInBody() {\n        return false;\n    }\n    static prefixScheme(proofUrl) {\n        if (!proofUrl.startsWith('https://') && !proofUrl.startsWith('http://')) {\n            return `https://${proofUrl}`;\n        }\n        else if (proofUrl.startsWith('http://')) {\n            return proofUrl.replace('http://', 'https://');\n        }\n        else {\n            return proofUrl;\n        }\n    }\n    static getProofUrl(proof) {\n        const baseUrls = this.getBaseUrls();\n        let proofUrl = proof.proof_url.toLowerCase();\n        proofUrl = this.prefixScheme(proofUrl);\n        for (let i = 0; i < baseUrls.length; i++) {\n            const requiredPrefix = `${baseUrls[i]}${proof.identifier}`.toLowerCase();\n            if (proofUrl.startsWith(requiredPrefix)) {\n                return proofUrl;\n            }\n        }\n        throw new Error(`Proof url ${proof.proof_url} is not valid for service ${proof.service}`);\n    }\n}\nexports.Service = Service;\n//# sourceMappingURL=service.js.map"]},"metadata":{},"sourceType":"script"}