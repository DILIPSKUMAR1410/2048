{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/aashan/2048/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/aashan/2048/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar base64url_1 = __importDefault(require(\"base64url\"));\n\nvar cryptoClients_1 = require(\"./cryptoClients\");\n\nvar errors_1 = require(\"./errors\");\n\nfunction createSigningInput(payload, header) {\n  var tokenParts = []; // add in the header\n\n  var encodedHeader = base64url_1.default.encode(JSON.stringify(header));\n  tokenParts.push(encodedHeader); // add in the payload\n\n  var encodedPayload = base64url_1.default.encode(JSON.stringify(payload));\n  tokenParts.push(encodedPayload); // prepare the message\n\n  var signingInput = tokenParts.join('.'); // return the signing input\n\n  return signingInput;\n}\n\nfunction createUnsecuredToken(payload) {\n  var header = {\n    typ: 'JWT',\n    alg: 'none'\n  };\n  return createSigningInput(payload, header) + '.';\n}\n\nexports.createUnsecuredToken = createUnsecuredToken;\n\nvar TokenSigner =\n/*#__PURE__*/\nfunction () {\n  function TokenSigner(signingAlgorithm, rawPrivateKey) {\n    _classCallCheck(this, TokenSigner);\n\n    if (!(signingAlgorithm && rawPrivateKey)) {\n      throw new errors_1.MissingParametersError('a signing algorithm and private key are required');\n    }\n\n    if (typeof signingAlgorithm !== 'string') {\n      throw new Error('signing algorithm parameter must be a string');\n    }\n\n    signingAlgorithm = signingAlgorithm.toUpperCase();\n\n    if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n      throw new Error('invalid signing algorithm');\n    }\n\n    this.tokenType = 'JWT';\n    this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n    this.rawPrivateKey = rawPrivateKey;\n  }\n\n  _createClass(TokenSigner, [{\n    key: \"header\",\n    value: function header() {\n      var _header = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var defaultHeader = {\n        typ: this.tokenType,\n        alg: this.cryptoClient.algorithmName\n      };\n      return Object.assign({}, defaultHeader, _header);\n    }\n  }, {\n    key: \"sign\",\n    value: function sign(payload) {\n      var expanded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var customHeader = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      // generate the token header\n      var header = this.header(customHeader); // prepare the message to be signed\n\n      var signingInput = createSigningInput(payload, header);\n      var signingInputHash = this.cryptoClient.createHash(signingInput); // sign the message and add in the signature\n\n      var signature = this.cryptoClient.signHash(signingInputHash, this.rawPrivateKey);\n\n      if (expanded) {\n        return {\n          'header': [base64url_1.default.encode(JSON.stringify(header))],\n          'payload': JSON.stringify(payload),\n          'signature': [signature]\n        };\n      } else {\n        return [signingInput, signature].join('.');\n      }\n    }\n  }]);\n\n  return TokenSigner;\n}();\n\nexports.TokenSigner = TokenSigner;","map":{"version":3,"sources":["signer.ts"],"names":[],"mappings":"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","sourceRoot":"./","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base64url_1 = __importDefault(require(\"base64url\"));\nconst cryptoClients_1 = require(\"./cryptoClients\");\nconst errors_1 = require(\"./errors\");\nfunction createSigningInput(payload, header) {\n    const tokenParts = [];\n    // add in the header\n    const encodedHeader = base64url_1.default.encode(JSON.stringify(header));\n    tokenParts.push(encodedHeader);\n    // add in the payload\n    const encodedPayload = base64url_1.default.encode(JSON.stringify(payload));\n    tokenParts.push(encodedPayload);\n    // prepare the message\n    const signingInput = tokenParts.join('.');\n    // return the signing input\n    return signingInput;\n}\nfunction createUnsecuredToken(payload) {\n    const header = { typ: 'JWT', alg: 'none' };\n    return createSigningInput(payload, header) + '.';\n}\nexports.createUnsecuredToken = createUnsecuredToken;\nclass TokenSigner {\n    constructor(signingAlgorithm, rawPrivateKey) {\n        if (!(signingAlgorithm && rawPrivateKey)) {\n            throw new errors_1.MissingParametersError('a signing algorithm and private key are required');\n        }\n        if (typeof signingAlgorithm !== 'string') {\n            throw new Error('signing algorithm parameter must be a string');\n        }\n        signingAlgorithm = signingAlgorithm.toUpperCase();\n        if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n            throw new Error('invalid signing algorithm');\n        }\n        this.tokenType = 'JWT';\n        this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n        this.rawPrivateKey = rawPrivateKey;\n    }\n    header(header = {}) {\n        const defaultHeader = { typ: this.tokenType,\n            alg: this.cryptoClient.algorithmName };\n        return Object.assign({}, defaultHeader, header);\n    }\n    sign(payload, expanded = false, customHeader = {}) {\n        // generate the token header\n        const header = this.header(customHeader);\n        // prepare the message to be signed\n        const signingInput = createSigningInput(payload, header);\n        const signingInputHash = this.cryptoClient.createHash(signingInput);\n        // sign the message and add in the signature\n        const signature = this.cryptoClient.signHash(signingInputHash, this.rawPrivateKey);\n        if (expanded) {\n            return {\n                'header': [\n                    base64url_1.default.encode(JSON.stringify(header))\n                ],\n                'payload': JSON.stringify(payload),\n                'signature': [\n                    signature\n                ]\n            };\n        }\n        else {\n            return [signingInput, signature].join('.');\n        }\n    }\n}\nexports.TokenSigner = TokenSigner;\n//# sourceMappingURL=signer.js.map"]},"metadata":{},"sourceType":"script"}