{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/aashan/2048/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/aashan/2048/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar elliptic_1 = require(\"elliptic\");\n\nvar crypto_1 = require(\"crypto\");\n\nvar key_encoder_1 = __importDefault(require(\"key-encoder\"));\n\nvar ecdsa_sig_formatter_1 = require(\"ecdsa-sig-formatter\");\n\nvar errors_1 = require(\"../errors\");\n\nvar SECP256K1Client =\n/*#__PURE__*/\nfunction () {\n  function SECP256K1Client() {\n    _classCallCheck(this, SECP256K1Client);\n  }\n\n  _createClass(SECP256K1Client, null, [{\n    key: \"createHash\",\n    value: function createHash(signingInput) {\n      return crypto_1.createHash('sha256').update(signingInput).digest();\n    }\n  }, {\n    key: \"loadPrivateKey\",\n    value: function loadPrivateKey(rawPrivateKey) {\n      if (rawPrivateKey.length === 66) {\n        rawPrivateKey = rawPrivateKey.slice(0, 64);\n      }\n\n      return SECP256K1Client.ec.keyFromPrivate(rawPrivateKey);\n    }\n  }, {\n    key: \"loadPublicKey\",\n    value: function loadPublicKey(rawPublicKey) {\n      return SECP256K1Client.ec.keyFromPublic(rawPublicKey, 'hex');\n    }\n  }, {\n    key: \"encodePublicKey\",\n    value: function encodePublicKey(publicKey, originalFormat, destinationFormat) {\n      return SECP256K1Client.keyEncoder.encodePublic(publicKey, originalFormat, destinationFormat);\n    }\n  }, {\n    key: \"derivePublicKey\",\n    value: function derivePublicKey(privateKey) {\n      var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (typeof privateKey !== 'string') {\n        throw Error('private key must be a string');\n      }\n\n      if (!/^[0-9A-F]+$/i.test(privateKey)) {\n        throw Error('private key must be a hex string');\n      }\n\n      if (privateKey.length == 66) {\n        privateKey = privateKey.slice(0, 64);\n      } else if (privateKey.length <= 64) {// do nothing\n      } else {\n        throw Error('private key must be 66 characters or less');\n      }\n\n      var keypair = SECP256K1Client.ec.keyFromPrivate(privateKey);\n      return keypair.getPublic(compressed, 'hex');\n    }\n  }, {\n    key: \"signHash\",\n    value: function signHash(signingInputHash, rawPrivateKey) {\n      var format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'jose';\n\n      // make sure the required parameters are provided\n      if (!(signingInputHash && rawPrivateKey)) {\n        throw new errors_1.MissingParametersError('a signing input hash and private key are all required');\n      } // prepare the private key\n\n\n      var privateKeyObject = SECP256K1Client.loadPrivateKey(rawPrivateKey); // calculate the signature\n\n      var signatureObject = privateKeyObject.sign(signingInputHash);\n      var derSignature = Buffer.from(signatureObject.toDER());\n\n      if (format === 'der') {\n        return derSignature.toString('hex');\n      } else if (format === 'jose') {\n        // return the JOSE-formatted signature\n        return ecdsa_sig_formatter_1.derToJose(derSignature, 'ES256');\n      } else {\n        throw Error('Invalid signature format');\n      }\n    }\n  }, {\n    key: \"loadSignature\",\n    value: function loadSignature(joseSignature) {\n      // create and return the DER-formatted signature buffer\n      return ecdsa_sig_formatter_1.joseToDer(joseSignature, 'ES256');\n    }\n  }, {\n    key: \"verifyHash\",\n    value: function verifyHash(signingInputHash, derSignatureBuffer, rawPublicKey) {\n      // make sure the required parameters are provided\n      if (!(signingInputHash && derSignatureBuffer && rawPublicKey)) {\n        throw new errors_1.MissingParametersError('a signing input hash, der signature, and public key are all required');\n      } // prepare the public key\n\n\n      var publicKeyObject = SECP256K1Client.loadPublicKey(rawPublicKey); // verify the token\n\n      return publicKeyObject.verify(signingInputHash, derSignatureBuffer);\n    }\n  }]);\n\n  return SECP256K1Client;\n}();\n\nSECP256K1Client.ec = new elliptic_1.ec('secp256k1');\nSECP256K1Client.algorithmName = 'ES256K';\nSECP256K1Client.keyEncoder = new key_encoder_1.default({\n  curveParameters: [1, 3, 132, 0, 10],\n  privatePEMOptions: {\n    label: 'EC PRIVATE KEY'\n  },\n  publicPEMOptions: {\n    label: 'PUBLIC KEY'\n  },\n  curve: SECP256K1Client.ec\n});\nexports.SECP256K1Client = SECP256K1Client;","map":{"version":3,"sources":["cryptoClients/secp256k1.ts"],"names":[],"mappings":"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","sourceRoot":"./","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst elliptic_1 = require(\"elliptic\");\nconst crypto_1 = require(\"crypto\");\nconst key_encoder_1 = __importDefault(require(\"key-encoder\"));\nconst ecdsa_sig_formatter_1 = require(\"ecdsa-sig-formatter\");\nconst errors_1 = require(\"../errors\");\nclass SECP256K1Client {\n    constructor() {\n    }\n    static createHash(signingInput) {\n        return crypto_1.createHash('sha256').update(signingInput).digest();\n    }\n    static loadPrivateKey(rawPrivateKey) {\n        if (rawPrivateKey.length === 66) {\n            rawPrivateKey = rawPrivateKey.slice(0, 64);\n        }\n        return SECP256K1Client.ec.keyFromPrivate(rawPrivateKey);\n    }\n    static loadPublicKey(rawPublicKey) {\n        return SECP256K1Client.ec.keyFromPublic(rawPublicKey, 'hex');\n    }\n    static encodePublicKey(publicKey, originalFormat, destinationFormat) {\n        return SECP256K1Client.keyEncoder.encodePublic(publicKey, originalFormat, destinationFormat);\n    }\n    static derivePublicKey(privateKey, compressed = true) {\n        if (typeof privateKey !== 'string') {\n            throw Error('private key must be a string');\n        }\n        if (!(/^[0-9A-F]+$/i.test(privateKey))) {\n            throw Error('private key must be a hex string');\n        }\n        if (privateKey.length == 66) {\n            privateKey = privateKey.slice(0, 64);\n        }\n        else if (privateKey.length <= 64) {\n            // do nothing\n        }\n        else {\n            throw Error('private key must be 66 characters or less');\n        }\n        const keypair = SECP256K1Client.ec.keyFromPrivate(privateKey);\n        return keypair.getPublic(compressed, 'hex');\n    }\n    static signHash(signingInputHash, rawPrivateKey, format = 'jose') {\n        // make sure the required parameters are provided\n        if (!(signingInputHash && rawPrivateKey)) {\n            throw new errors_1.MissingParametersError('a signing input hash and private key are all required');\n        }\n        // prepare the private key\n        const privateKeyObject = SECP256K1Client.loadPrivateKey(rawPrivateKey);\n        // calculate the signature\n        const signatureObject = privateKeyObject.sign(signingInputHash);\n        const derSignature = Buffer.from(signatureObject.toDER());\n        if (format === 'der') {\n            return derSignature.toString('hex');\n        }\n        else if (format === 'jose') {\n            // return the JOSE-formatted signature\n            return ecdsa_sig_formatter_1.derToJose(derSignature, 'ES256');\n        }\n        else {\n            throw Error('Invalid signature format');\n        }\n    }\n    static loadSignature(joseSignature) {\n        // create and return the DER-formatted signature buffer\n        return ecdsa_sig_formatter_1.joseToDer(joseSignature, 'ES256');\n    }\n    static verifyHash(signingInputHash, derSignatureBuffer, rawPublicKey) {\n        // make sure the required parameters are provided\n        if (!(signingInputHash && derSignatureBuffer && rawPublicKey)) {\n            throw new errors_1.MissingParametersError('a signing input hash, der signature, and public key are all required');\n        }\n        // prepare the public key\n        const publicKeyObject = SECP256K1Client.loadPublicKey(rawPublicKey);\n        // verify the token\n        return publicKeyObject.verify(signingInputHash, derSignatureBuffer);\n    }\n}\nSECP256K1Client.ec = new elliptic_1.ec('secp256k1');\nSECP256K1Client.algorithmName = 'ES256K';\nSECP256K1Client.keyEncoder = new key_encoder_1.default({\n    curveParameters: [1, 3, 132, 0, 10],\n    privatePEMOptions: { label: 'EC PRIVATE KEY' },\n    publicPEMOptions: { label: 'PUBLIC KEY' },\n    curve: SECP256K1Client.ec\n});\nexports.SECP256K1Client = SECP256K1Client;\n//# sourceMappingURL=secp256k1.js.map"]},"metadata":{},"sourceType":"script"}