{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/aashan/2048/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/aashan/2048/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar elliptic_1 = require(\"elliptic\"); // @ts-ignore\n\n\nvar asn1 = require(\"asn1.js\");\n\nvar BN = require('bn.js');\n\nvar ECPrivateKeyASN = asn1.define('ECPrivateKey', function () {\n  // @ts-ignore\n  var self = this;\n  self.seq().obj(self.key('version').int(), self.key('privateKey').octstr(), self.key('parameters').explicit(0).objid().optional(), self.key('publicKey').explicit(1).bitstr().optional());\n});\nvar SubjectPublicKeyInfoASN = asn1.define('SubjectPublicKeyInfo', function () {\n  // @ts-ignore\n  var self = this;\n  self.seq().obj(self.key('algorithm').seq().obj(self.key(\"id\").objid(), self.key(\"curve\").objid()), self.key('pub').bitstr());\n});\nvar curves = {\n  secp256k1: {\n    curveParameters: [1, 3, 132, 0, 10],\n    privatePEMOptions: {\n      label: 'EC PRIVATE KEY'\n    },\n    publicPEMOptions: {\n      label: 'PUBLIC KEY'\n    },\n    curve: new elliptic_1.ec('secp256k1')\n  }\n};\n\nvar KeyEncoder =\n/*#__PURE__*/\nfunction () {\n  function KeyEncoder(options) {\n    _classCallCheck(this, KeyEncoder);\n\n    if (typeof options === 'string') {\n      if (options !== 'secp256k1') {\n        throw new Error('Unknown curve ' + options);\n      }\n\n      options = curves[options];\n    }\n\n    this.options = options;\n    this.algorithmID = [1, 2, 840, 10045, 2, 1];\n  }\n\n  _createClass(KeyEncoder, [{\n    key: \"privateKeyObject\",\n    value: function privateKeyObject(rawPrivateKey, rawPublicKey) {\n      var privateKeyObject = {\n        version: new BN(1),\n        privateKey: Buffer.from(rawPrivateKey, 'hex'),\n        parameters: this.options.curveParameters\n      };\n\n      if (rawPublicKey) {\n        privateKeyObject.publicKey = {\n          unused: 0,\n          data: Buffer.from(rawPublicKey, 'hex')\n        };\n      }\n\n      return privateKeyObject;\n    }\n  }, {\n    key: \"publicKeyObject\",\n    value: function publicKeyObject(rawPublicKey) {\n      return {\n        algorithm: {\n          id: this.algorithmID,\n          curve: this.options.curveParameters\n        },\n        pub: {\n          unused: 0,\n          data: Buffer.from(rawPublicKey, 'hex')\n        }\n      };\n    }\n  }, {\n    key: \"encodePrivate\",\n    value: function encodePrivate(privateKey, originalFormat, destinationFormat) {\n      var privateKeyObject;\n      /* Parse the incoming private key and convert it to a private key object */\n\n      if (originalFormat === 'raw') {\n        if (typeof privateKey !== 'string') {\n          throw 'private key must be a string';\n        }\n\n        var keyPair = this.options.curve.keyFromPrivate(privateKey, 'hex');\n        var rawPublicKey = keyPair.getPublic('hex');\n        privateKeyObject = this.privateKeyObject(privateKey, rawPublicKey);\n      } else if (originalFormat === 'der') {\n        if (typeof privateKey !== 'string') {// do nothing\n        } else if (typeof privateKey === 'string') {\n          privateKey = Buffer.from(privateKey, 'hex');\n        } else {\n          throw 'private key must be a buffer or a string';\n        }\n\n        privateKeyObject = ECPrivateKeyASN.decode(privateKey, 'der');\n      } else if (originalFormat === 'pem') {\n        if (typeof privateKey !== 'string') {\n          throw 'private key must be a string';\n        }\n\n        privateKeyObject = ECPrivateKeyASN.decode(privateKey, 'pem', this.options.privatePEMOptions);\n      } else {\n        throw 'invalid private key format';\n      }\n      /* Export the private key object to the desired format */\n\n\n      if (destinationFormat === 'raw') {\n        return privateKeyObject.privateKey.toString('hex');\n      } else if (destinationFormat === 'der') {\n        return ECPrivateKeyASN.encode(privateKeyObject, 'der').toString('hex');\n      } else if (destinationFormat === 'pem') {\n        return ECPrivateKeyASN.encode(privateKeyObject, 'pem', this.options.privatePEMOptions);\n      } else {\n        throw 'invalid destination format for private key';\n      }\n    }\n  }, {\n    key: \"encodePublic\",\n    value: function encodePublic(publicKey, originalFormat, destinationFormat) {\n      var publicKeyObject;\n      /* Parse the incoming public key and convert it to a public key object */\n\n      if (originalFormat === 'raw') {\n        if (typeof publicKey !== 'string') {\n          throw 'public key must be a string';\n        }\n\n        publicKeyObject = this.publicKeyObject(publicKey);\n      } else if (originalFormat === 'der') {\n        if (typeof publicKey !== 'string') {// do nothing\n        } else if (typeof publicKey === 'string') {\n          publicKey = Buffer.from(publicKey, 'hex');\n        } else {\n          throw 'public key must be a buffer or a string';\n        }\n\n        publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, 'der');\n      } else if (originalFormat === 'pem') {\n        if (typeof publicKey !== 'string') {\n          throw 'public key must be a string';\n        }\n\n        publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, 'pem', this.options.publicPEMOptions);\n      } else {\n        throw 'invalid public key format';\n      }\n      /* Export the private key object to the desired format */\n\n\n      if (destinationFormat === 'raw') {\n        return publicKeyObject.pub.data.toString('hex');\n      } else if (destinationFormat === 'der') {\n        return SubjectPublicKeyInfoASN.encode(publicKeyObject, 'der').toString('hex');\n      } else if (destinationFormat === 'pem') {\n        return SubjectPublicKeyInfoASN.encode(publicKeyObject, 'pem', this.options.publicPEMOptions);\n      } else {\n        throw 'invalid destination format for public key';\n      }\n    }\n  }]);\n\n  return KeyEncoder;\n}();\n\nexports.default = KeyEncoder;\nKeyEncoder.ECPrivateKeyASN = ECPrivateKeyASN;\nKeyEncoder.SubjectPublicKeyInfoASN = SubjectPublicKeyInfoASN;","map":{"version":3,"sources":["key-encoder.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,IAAA,UAAA,GAAA,OAAA,CAAA,UAAA,CAAA,C,CACA;;;AACA,IAAA,IAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AACA,IAAM,EAAE,GAAG,OAAO,CAAC,OAAD,CAAlB;;AAOA,IAAM,eAAe,GAAG,IAAI,CAAC,MAAL,CAAY,cAAZ,EAA4B,YAAA;AAChD;AACA,MAAM,IAAI,GAAG,IAAb;AACA,EAAA,IAAI,CAAC,GAAL,GAAW,GAAX,CACI,IAAI,CAAC,GAAL,CAAS,SAAT,EAAoB,GAApB,EADJ,EAEI,IAAI,CAAC,GAAL,CAAS,YAAT,EAAuB,MAAvB,EAFJ,EAGI,IAAI,CAAC,GAAL,CAAS,YAAT,EAAuB,QAAvB,CAAgC,CAAhC,EAAmC,KAAnC,GAA2C,QAA3C,EAHJ,EAII,IAAI,CAAC,GAAL,CAAS,WAAT,EAAsB,QAAtB,CAA+B,CAA/B,EAAkC,MAAlC,GAA2C,QAA3C,EAJJ;AAMH,CATuB,CAAxB;AAWA,IAAM,uBAAuB,GAAG,IAAI,CAAC,MAAL,CAAY,sBAAZ,EAAoC,YAAA;AAChE;AACA,MAAM,IAAI,GAAG,IAAb;AACA,EAAA,IAAI,CAAC,GAAL,GAAW,GAAX,CACI,IAAI,CAAC,GAAL,CAAS,WAAT,EAAsB,GAAtB,GAA4B,GAA5B,CACI,IAAI,CAAC,GAAL,CAAS,IAAT,EAAe,KAAf,EADJ,EAEI,IAAI,CAAC,GAAL,CAAS,OAAT,EAAkB,KAAlB,EAFJ,CADJ,EAKI,IAAI,CAAC,GAAL,CAAS,KAAT,EAAgB,MAAhB,EALJ;AAOH,CAV+B,CAAhC;AAmBA,IAAM,MAAM,GAAsC;AAC9C,EAAA,SAAS,EAAE;AACP,IAAA,eAAe,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,GAAP,EAAY,CAAZ,EAAe,EAAf,CADV;AAEP,IAAA,iBAAiB,EAAE;AAAE,MAAA,KAAK,EAAE;AAAT,KAFZ;AAGP,IAAA,gBAAgB,EAAE;AAAE,MAAA,KAAK,EAAE;AAAT,KAHX;AAIP,IAAA,KAAK,EAAE,IAAI,UAAA,CAAA,EAAJ,CAAO,WAAP;AAJA;AADmC,CAAlD;;IAqBqB,U;;;AAOjB,sBAAY,OAAZ,EAA0C;AAAA;;AACtC,QAAI,OAAO,OAAP,KAAmB,QAAvB,EAAiC;AAC7B,UAAI,OAAO,KAAK,WAAhB,EAA6B;AACzB,cAAM,IAAI,KAAJ,CAAU,mBAAmB,OAA7B,CAAN;AACH;;AACD,MAAA,OAAO,GAAG,MAAM,CAAC,OAAD,CAAhB;AACH;;AACD,SAAK,OAAL,GAAe,OAAf;AACA,SAAK,WAAL,GAAmB,CAAC,CAAD,EAAI,CAAJ,EAAO,GAAP,EAAY,KAAZ,EAAmB,CAAnB,EAAsB,CAAtB,CAAnB;AACH;;;;qCAEgB,a,EAAuB,Y,EAAoB;AACxD,UAAM,gBAAgB,GAAe;AACjC,QAAA,OAAO,EAAE,IAAI,EAAJ,CAAO,CAAP,CADwB;AAEjC,QAAA,UAAU,EAAE,MAAM,CAAC,IAAP,CAAY,aAAZ,EAA2B,KAA3B,CAFqB;AAGjC,QAAA,UAAU,EAAE,KAAK,OAAL,CAAa;AAHQ,OAArC;;AAMA,UAAI,YAAJ,EAAkB;AACd,QAAA,gBAAgB,CAAC,SAAjB,GAA6B;AACzB,UAAA,MAAM,EAAE,CADiB;AAEzB,UAAA,IAAI,EAAE,MAAM,CAAC,IAAP,CAAY,YAAZ,EAA0B,KAA1B;AAFmB,SAA7B;AAIH;;AAED,aAAO,gBAAP;AACH;;;oCAEe,Y,EAAoB;AAChC,aAAO;AACH,QAAA,SAAS,EAAE;AACP,UAAA,EAAE,EAAE,KAAK,WADF;AAEP,UAAA,KAAK,EAAE,KAAK,OAAL,CAAa;AAFb,SADR;AAKH,QAAA,GAAG,EAAE;AACD,UAAA,MAAM,EAAE,CADP;AAED,UAAA,IAAI,EAAE,MAAM,CAAC,IAAP,CAAY,YAAZ,EAA0B,KAA1B;AAFL;AALF,OAAP;AAUH;;;kCAEa,U,EAA6B,c,EAA2B,iB,EAA4B;AAC9F,UAAI,gBAAJ;AAEA;;AACA,UAAI,cAAc,KAAK,KAAvB,EAA8B;AAC1B,YAAI,OAAO,UAAP,KAAsB,QAA1B,EAAoC;AAChC,gBAAM,8BAAN;AACH;;AACD,YAAI,OAAO,GAAG,KAAK,OAAL,CAAa,KAAb,CAAmB,cAAnB,CAAkC,UAAlC,EAA8C,KAA9C,CAAd;AACA,YAAI,YAAY,GAAG,OAAO,CAAC,SAAR,CAAkB,KAAlB,CAAnB;AACA,QAAA,gBAAgB,GAAG,KAAK,gBAAL,CAAsB,UAAtB,EAAkC,YAAlC,CAAnB;AACH,OAPD,MAOO,IAAI,cAAc,KAAK,KAAvB,EAA8B;AACjC,YAAI,OAAO,UAAP,KAAsB,QAA1B,EAAoC,CAChC;AACH,SAFD,MAEO,IAAI,OAAO,UAAP,KAAsB,QAA1B,EAAoC;AACvC,UAAA,UAAU,GAAG,MAAM,CAAC,IAAP,CAAY,UAAZ,EAAwB,KAAxB,CAAb;AACH,SAFM,MAEA;AACH,gBAAM,0CAAN;AACH;;AACD,QAAA,gBAAgB,GAAG,eAAe,CAAC,MAAhB,CAAuB,UAAvB,EAAmC,KAAnC,CAAnB;AACH,OATM,MASA,IAAI,cAAc,KAAK,KAAvB,EAA8B;AACjC,YAAI,OAAO,UAAP,KAAsB,QAA1B,EAAoC;AAChC,gBAAM,8BAAN;AACH;;AACD,QAAA,gBAAgB,GAAG,eAAe,CAAC,MAAhB,CAAuB,UAAvB,EAAmC,KAAnC,EAA0C,KAAK,OAAL,CAAa,iBAAvD,CAAnB;AACH,OALM,MAKA;AACH,cAAM,4BAAN;AACH;AAED;;;AACA,UAAI,iBAAiB,KAAK,KAA1B,EAAiC;AAC7B,eAAO,gBAAgB,CAAC,UAAjB,CAA4B,QAA5B,CAAqC,KAArC,CAAP;AACH,OAFD,MAEO,IAAI,iBAAiB,KAAK,KAA1B,EAAiC;AACpC,eAAO,eAAe,CAAC,MAAhB,CAAuB,gBAAvB,EAAyC,KAAzC,EAAgD,QAAhD,CAAyD,KAAzD,CAAP;AACH,OAFM,MAEA,IAAI,iBAAiB,KAAK,KAA1B,EAAiC;AACpC,eAAO,eAAe,CAAC,MAAhB,CAAuB,gBAAvB,EAAyC,KAAzC,EAAgD,KAAK,OAAL,CAAa,iBAA7D,CAAP;AACH,OAFM,MAEA;AACH,cAAM,4CAAN;AACH;AACJ;;;iCAEY,S,EAA4B,c,EAA2B,iB,EAA4B;AAC5F,UAAI,eAAJ;AAEA;;AACA,UAAI,cAAc,KAAK,KAAvB,EAA8B;AAC1B,YAAI,OAAO,SAAP,KAAqB,QAAzB,EAAmC;AAC/B,gBAAM,6BAAN;AACH;;AACD,QAAA,eAAe,GAAG,KAAK,eAAL,CAAqB,SAArB,CAAlB;AACH,OALD,MAKO,IAAI,cAAc,KAAK,KAAvB,EAA8B;AACjC,YAAI,OAAO,SAAP,KAAqB,QAAzB,EAAmC,CAC/B;AACH,SAFD,MAEO,IAAI,OAAO,SAAP,KAAqB,QAAzB,EAAmC;AACtC,UAAA,SAAS,GAAG,MAAM,CAAC,IAAP,CAAY,SAAZ,EAAuB,KAAvB,CAAZ;AACH,SAFM,MAEA;AACH,gBAAM,yCAAN;AACH;;AACD,QAAA,eAAe,GAAG,uBAAuB,CAAC,MAAxB,CAA+B,SAA/B,EAA0C,KAA1C,CAAlB;AACH,OATM,MASA,IAAI,cAAc,KAAK,KAAvB,EAA8B;AACjC,YAAI,OAAO,SAAP,KAAqB,QAAzB,EAAmC;AAC/B,gBAAM,6BAAN;AACH;;AACD,QAAA,eAAe,GAAG,uBAAuB,CAAC,MAAxB,CAA+B,SAA/B,EAA0C,KAA1C,EAAiD,KAAK,OAAL,CAAa,gBAA9D,CAAlB;AACH,OALM,MAKA;AACH,cAAM,2BAAN;AACH;AAED;;;AACA,UAAI,iBAAiB,KAAK,KAA1B,EAAiC;AAC7B,eAAO,eAAe,CAAC,GAAhB,CAAoB,IAApB,CAAyB,QAAzB,CAAkC,KAAlC,CAAP;AACH,OAFD,MAEO,IAAI,iBAAiB,KAAK,KAA1B,EAAiC;AACpC,eAAO,uBAAuB,CAAC,MAAxB,CAA+B,eAA/B,EAAgD,KAAhD,EAAuD,QAAvD,CAAgE,KAAhE,CAAP;AACH,OAFM,MAEA,IAAI,iBAAiB,KAAK,KAA1B,EAAiC;AACpC,eAAO,uBAAuB,CAAC,MAAxB,CAA+B,eAA/B,EAAgD,KAAhD,EAAuD,KAAK,OAAL,CAAa,gBAApE,CAAP;AACH,OAFM,MAEA;AACH,cAAM,2CAAN;AACH;AACJ;;;;;;AA9HL,OAAA,CAAA,OAAA,GAAA,UAAA;AACW,UAAA,CAAA,eAAA,GAAkB,eAAlB;AACA,UAAA,CAAA,uBAAA,GAA0B,uBAA1B","sourceRoot":"./","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst elliptic_1 = require(\"elliptic\");\n// @ts-ignore\nconst asn1 = require(\"asn1.js\");\nconst BN = require('bn.js');\nconst ECPrivateKeyASN = asn1.define('ECPrivateKey', function () {\n    // @ts-ignore\n    const self = this;\n    self.seq().obj(self.key('version').int(), self.key('privateKey').octstr(), self.key('parameters').explicit(0).objid().optional(), self.key('publicKey').explicit(1).bitstr().optional());\n});\nconst SubjectPublicKeyInfoASN = asn1.define('SubjectPublicKeyInfo', function () {\n    // @ts-ignore\n    const self = this;\n    self.seq().obj(self.key('algorithm').seq().obj(self.key(\"id\").objid(), self.key(\"curve\").objid()), self.key('pub').bitstr());\n});\nconst curves = {\n    secp256k1: {\n        curveParameters: [1, 3, 132, 0, 10],\n        privatePEMOptions: { label: 'EC PRIVATE KEY' },\n        publicPEMOptions: { label: 'PUBLIC KEY' },\n        curve: new elliptic_1.ec('secp256k1')\n    }\n};\nclass KeyEncoder {\n    constructor(options) {\n        if (typeof options === 'string') {\n            if (options !== 'secp256k1') {\n                throw new Error('Unknown curve ' + options);\n            }\n            options = curves[options];\n        }\n        this.options = options;\n        this.algorithmID = [1, 2, 840, 10045, 2, 1];\n    }\n    privateKeyObject(rawPrivateKey, rawPublicKey) {\n        const privateKeyObject = {\n            version: new BN(1),\n            privateKey: Buffer.from(rawPrivateKey, 'hex'),\n            parameters: this.options.curveParameters\n        };\n        if (rawPublicKey) {\n            privateKeyObject.publicKey = {\n                unused: 0,\n                data: Buffer.from(rawPublicKey, 'hex')\n            };\n        }\n        return privateKeyObject;\n    }\n    publicKeyObject(rawPublicKey) {\n        return {\n            algorithm: {\n                id: this.algorithmID,\n                curve: this.options.curveParameters\n            },\n            pub: {\n                unused: 0,\n                data: Buffer.from(rawPublicKey, 'hex')\n            }\n        };\n    }\n    encodePrivate(privateKey, originalFormat, destinationFormat) {\n        let privateKeyObject;\n        /* Parse the incoming private key and convert it to a private key object */\n        if (originalFormat === 'raw') {\n            if (typeof privateKey !== 'string') {\n                throw 'private key must be a string';\n            }\n            let keyPair = this.options.curve.keyFromPrivate(privateKey, 'hex');\n            let rawPublicKey = keyPair.getPublic('hex');\n            privateKeyObject = this.privateKeyObject(privateKey, rawPublicKey);\n        }\n        else if (originalFormat === 'der') {\n            if (typeof privateKey !== 'string') {\n                // do nothing\n            }\n            else if (typeof privateKey === 'string') {\n                privateKey = Buffer.from(privateKey, 'hex');\n            }\n            else {\n                throw 'private key must be a buffer or a string';\n            }\n            privateKeyObject = ECPrivateKeyASN.decode(privateKey, 'der');\n        }\n        else if (originalFormat === 'pem') {\n            if (typeof privateKey !== 'string') {\n                throw 'private key must be a string';\n            }\n            privateKeyObject = ECPrivateKeyASN.decode(privateKey, 'pem', this.options.privatePEMOptions);\n        }\n        else {\n            throw 'invalid private key format';\n        }\n        /* Export the private key object to the desired format */\n        if (destinationFormat === 'raw') {\n            return privateKeyObject.privateKey.toString('hex');\n        }\n        else if (destinationFormat === 'der') {\n            return ECPrivateKeyASN.encode(privateKeyObject, 'der').toString('hex');\n        }\n        else if (destinationFormat === 'pem') {\n            return ECPrivateKeyASN.encode(privateKeyObject, 'pem', this.options.privatePEMOptions);\n        }\n        else {\n            throw 'invalid destination format for private key';\n        }\n    }\n    encodePublic(publicKey, originalFormat, destinationFormat) {\n        let publicKeyObject;\n        /* Parse the incoming public key and convert it to a public key object */\n        if (originalFormat === 'raw') {\n            if (typeof publicKey !== 'string') {\n                throw 'public key must be a string';\n            }\n            publicKeyObject = this.publicKeyObject(publicKey);\n        }\n        else if (originalFormat === 'der') {\n            if (typeof publicKey !== 'string') {\n                // do nothing\n            }\n            else if (typeof publicKey === 'string') {\n                publicKey = Buffer.from(publicKey, 'hex');\n            }\n            else {\n                throw 'public key must be a buffer or a string';\n            }\n            publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, 'der');\n        }\n        else if (originalFormat === 'pem') {\n            if (typeof publicKey !== 'string') {\n                throw 'public key must be a string';\n            }\n            publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, 'pem', this.options.publicPEMOptions);\n        }\n        else {\n            throw 'invalid public key format';\n        }\n        /* Export the private key object to the desired format */\n        if (destinationFormat === 'raw') {\n            return publicKeyObject.pub.data.toString('hex');\n        }\n        else if (destinationFormat === 'der') {\n            return SubjectPublicKeyInfoASN.encode(publicKeyObject, 'der').toString('hex');\n        }\n        else if (destinationFormat === 'pem') {\n            return SubjectPublicKeyInfoASN.encode(publicKeyObject, 'pem', this.options.publicPEMOptions);\n        }\n        else {\n            throw 'invalid destination format for public key';\n        }\n    }\n}\nexports.default = KeyEncoder;\nKeyEncoder.ECPrivateKeyASN = ECPrivateKeyASN;\nKeyEncoder.SubjectPublicKeyInfoASN = SubjectPublicKeyInfoASN;\n//# sourceMappingURL=key-encoder.js.map"]},"metadata":{},"sourceType":"script"}